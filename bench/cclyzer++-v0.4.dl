#line 1 ".cclyzerpp/datalog/debug.project"
#line 1 "subset-and-unification.project"
#line 1 "common.project"
#line 1 "schema/schema.project"
#line 1 "debug.dl"
.type File <: symbol
.type Line <: number


.decl schema_sanity()
#line 2 "schema/schema.project"
#line 1 "attr.dl"

.type Attribute <: symbol
.decl attr(attr:Attribute)
.decl target_dependent_attr(attr:Attribute)

attr(a) :- target_dependent_attr(a).


.decl parameter_attr__zeroext(attr:Attribute)
.decl parameter_attr__signext(attr:Attribute)
.decl parameter_attr__inreg(attr:Attribute)
.decl parameter_attr__byval(attr:Attribute)
.decl parameter_attr__inalloca(attr:Attribute)
.decl parameter_attr__sret(attr:Attribute)
.decl parameter_attr__noalias(attr:Attribute)
.decl parameter_attr__nocapture(attr:Attribute)
.decl parameter_attr__nest(attr:Attribute)
.decl parameter_attr__returned(attr:Attribute)
.decl parameter_attr__nonnull(attr:Attribute)
.decl parameter_attr__dereferenceable(attr:Attribute)
.decl parameter_attr__dereferenceable_or_null(attr:Attribute)
.decl parameter_attr__align(attr:Attribute)


attr("zeroext"). parameter_attr__zeroext("zeroext").
attr("signext"). parameter_attr__signext("signext").
attr("inreg"). parameter_attr__inreg("inreg").
attr("byval"). parameter_attr__byval("byval").
attr("inalloca"). parameter_attr__inalloca("inalloca").
attr("sret"). parameter_attr__sret("sret").
attr("noalias"). parameter_attr__noalias("noalias").
attr("nocapture"). parameter_attr__nocapture("nocapture").
attr("nest"). parameter_attr__nest("nest").
attr("returned"). parameter_attr__returned("returned").
attr("nonnull"). parameter_attr__nonnull("nonnull").

parameter_attr__dereferenceable(Attr) :-
   attr(Attr),
   substr(Attr, 0, strlen("dereferenceable")) = "dereferenceable".

parameter_attr__dereferenceable_or_null(Attr) :-
   attr(Attr),
   substr(Attr, 0, strlen("dereferenceable_or_null")) = "dereferenceable_or_null".

parameter_attr__align(Attr) :-
   attr(Attr),
   substr(Attr, 0, strlen("align ")) = "align ".



.decl func_func_attr__alwaysinline(attr:Attribute)
.decl func_func_attr__builtin(attr:Attribute)
.decl func_func_attr__cold(attr:Attribute)
.decl func_func_attr__convergent(attr:Attribute)
.decl func_func_attr__inaccessiblememonly(attr:Attribute)
.decl func_func_attr__inaccessiblemem_or_argmemonly(attr:Attribute)
.decl func_func_attr__inlinehint(attr:Attribute)
.decl func_func_attr__jumptable(attr:Attribute)
.decl func_func_attr__minsize(attr:Attribute)
.decl func_func_attr__naked(attr:Attribute)
.decl func_func_attr__nobuiltin(attr:Attribute)
.decl func_func_attr__noduplicate(attr:Attribute)
.decl func_func_attr__noimplicitfloat(attr:Attribute)
.decl func_func_attr__noinline(attr:Attribute)
.decl func_func_attr__nonlazybind(attr:Attribute)
.decl func_func_attr__noredzone(attr:Attribute)
.decl func_func_attr__noreturn(attr:Attribute)
.decl func_func_attr__norecurse(attr:Attribute)
.decl func_func_attr__nounwind(attr:Attribute)
.decl func_func_attr__optnone(attr:Attribute)
.decl func_func_attr__optsize(attr:Attribute)
.decl func_func_attr__readnone(attr:Attribute)
.decl func_func_attr__readonly(attr:Attribute)
.decl func_func_attr__argmemonly(attr:Attribute)
.decl func_func_attr__returns_twice(attr:Attribute)
.decl func_func_attr__safestack(attr:Attribute)
.decl func_func_attr__sanitize_address(attr:Attribute)
.decl func_func_attr__sanitize_memory(attr:Attribute)
.decl func_func_attr__sanitize_thread(attr:Attribute)
.decl func_func_attr__ssp(attr:Attribute)
.decl func_func_attr__sspreq(attr:Attribute)
.decl func_func_attr__sspstrong(attr:Attribute)
.decl func_func_attr__uwtable(attr:Attribute)
.decl func_func_attr__alignstack(attr:Attribute)


attr("alwaysinline"). func_func_attr__alwaysinline("alwaysinline").
attr("builtin"). func_func_attr__builtin("builtin").
attr("cold"). func_func_attr__cold("cold").
attr("convergent"). func_func_attr__convergent("convergent").
attr("inaccessiblememonly"). func_func_attr__inaccessiblememonly("inaccessiblememonly").
attr("inaccessiblemem_or_argmemonly").
func_func_attr__inaccessiblemem_or_argmemonly("inaccessiblemem_or_argmemonly").
attr("inlinehint"). func_func_attr__inlinehint("inlinehint").
attr("jumptable"). func_func_attr__jumptable("jumptable").
attr("minsize"). func_func_attr__minsize("minsize").
attr("naked"). func_func_attr__naked("naked").
attr("nobuiltin"). func_func_attr__nobuiltin("nobuiltin").
attr("noduplicate"). func_func_attr__noduplicate("noduplicate").
attr("noimplicitfloat"). func_func_attr__noimplicitfloat("noimplicitfloat").
attr("noinline"). func_func_attr__noinline("noinline").
attr("nonlazybind"). func_func_attr__nonlazybind("nonlazybind").
attr("noredzone"). func_func_attr__noredzone("noredzone").
attr("noreturn"). func_func_attr__noreturn("noreturn").
attr("norecurse"). func_func_attr__norecurse("norecurse").
attr("nounwind"). func_func_attr__nounwind("nounwind").
attr("optnone"). func_func_attr__optnone("optnone").
attr("optsize"). func_func_attr__optsize("optsize").
attr("readnone"). func_func_attr__readnone("readnone").
attr("readonly"). func_func_attr__readonly("readonly").
attr("argmemonly"). func_func_attr__argmemonly("argmemonly").
attr("returns_twice"). func_func_attr__returns_twice("returns_twice").
attr("safestack"). func_func_attr__safestack("safestack").
attr("sanitize_address"). func_func_attr__sanitize_address("sanitize_address").
attr("sanitize_memory"). func_func_attr__sanitize_memory("sanitize_memory").
attr("sanitize_thread"). func_func_attr__sanitize_thread("sanitize_thread").
attr("ssp"). func_func_attr__ssp("ssp").
attr("sspreq"). func_func_attr__sspreq("sspreq").
attr("sspstrong"). func_func_attr__sspstrong("sspstrong").
attr("uwtable"). func_func_attr__uwtable("uwtable").

func_func_attr__alignstack(Attr) :-
   attr(Attr),
   substr(Attr, 0, strlen("alignstack")) = "alignstack".
#line 3 "schema/schema.project"
#line 1 "calling-convention.dl"



.type CallingConvention <: symbol
.decl calling_convention(conv:CallingConvention)

.decl fast_calling_convention(conv:CallingConvention)
.decl cold_calling_convention(conv:CallingConvention)
.decl x86_fastcall_calling_convention(conv:CallingConvention)
.decl x86_stdcall_calling_convention(conv:CallingConvention)
.decl x86_thiscall_calling_convention(conv:CallingConvention)
.decl intel_ocl_bi_calling_convention(conv:CallingConvention)
.decl arm_aapcs_calling_convention(conv:CallingConvention)
.decl arm_aapcs_vfp_calling_convention(conv:CallingConvention)
.decl arm_apcs_calling_convention(conv:CallingConvention)
.decl msp430_intr_calling_convention(conv:CallingConvention)
.decl ptx_device_calling_convention(conv:CallingConvention)
.decl ptx_kernel_calling_convention(conv:CallingConvention)

calling_convention(cc) :- fast_calling_convention(cc).
calling_convention(cc) :- cold_calling_convention(cc).
calling_convention(cc) :- x86_fastcall_calling_convention(cc).
calling_convention(cc) :- x86_stdcall_calling_convention(cc).
calling_convention(cc) :- x86_thiscall_calling_convention(cc).
calling_convention(cc) :- intel_ocl_bi_calling_convention(cc).
calling_convention(cc) :- arm_aapcs_calling_convention(cc).
calling_convention(cc) :- arm_aapcs_vfp_calling_convention(cc).
calling_convention(cc) :- arm_apcs_calling_convention(cc).
calling_convention(cc) :- msp430_intr_calling_convention(cc).
calling_convention(cc) :- ptx_device_calling_convention(cc).
calling_convention(cc) :- ptx_kernel_calling_convention(cc).

fast_calling_convention("fastcc").
cold_calling_convention("coldcc").
x86_fastcall_calling_convention("x86_fastcallcc").
x86_stdcall_calling_convention("x86_stdcallcc").
x86_thiscall_calling_convention("x86_thiscallcc").
intel_ocl_bi_calling_convention("intel_ocl_bicc").
arm_aapcs_calling_convention("arm_aapcscc").
arm_aapcs_vfp_calling_convention("arm_aapcs_vfpcc").
arm_apcs_calling_convention("arm_apcscc").
msp430_intr_calling_convention("msp430_intrcc").
ptx_device_calling_convention("ptx_device").
ptx_kernel_calling_convention("ptx_kernel").
#line 4 "schema/schema.project"
#line 1 "ordering.dl"

.type Ordering <: symbol
.decl ordering(o:Ordering)

.decl unordered_ordering(o:Ordering)
.decl monotonic_ordering(o:Ordering)
.decl acquire_ordering(o:Ordering)
.decl release_ordering(o:Ordering)
.decl acq_rel_ordering(o:Ordering)
.decl seq_cst_ordering(o:Ordering)

ordering(o) :- unordered_ordering(o).
ordering(o) :- monotonic_ordering(o).
ordering(o) :- acquire_ordering(o).
ordering(o) :- release_ordering(o).
ordering(o) :- acq_rel_ordering(o).
ordering(o) :- seq_cst_ordering(o).

unordered_ordering("unordered").
monotonic_ordering("monotonic").
acquire_ordering("acquire").
release_ordering("release").
acq_rel_ordering("acq_rel").
seq_cst_ordering("seq_cst").
#line 5 "schema/schema.project"
#line 1 "type.dl"




.type Type
  = PrimitiveType
  | IntegerType
  | FPType
  | VoidType
  | LabelType
  | MetadataType
  | DerivedType
.decl type(t:Type)



.decl type_has_size(t:Type, size:Bytes)
.decl type_has_unpadded_size(t:Type, size:Bytes)


.decl schema_invalid_type(type:Type, file:File, line:Line)






.type PrimitiveType
  = IntegerType
  | FPType
  | VoidType
  | LabelType
  | MetadataType

.type IntegerType <: symbol
.type FPType <: symbol
.type VoidType <: symbol
.type LabelType <: symbol
.type MetadataType <: symbol

.decl primitive_type(type:PrimitiveType)
.decl integer_type(type:IntegerType)
.decl fp_type(type:FPType)
.decl void_type(type:VoidType)
.decl label_type(type:LabelType)
.decl metadata_type(type:MetadataType)
.decl x86mmx_type(type:PrimitiveType)

type(t) :- primitive_type(t).
primitive_type(t) :- integer_type(t).
primitive_type(t) :- fp_type(t).
primitive_type(t) :- void_type(t).
primitive_type(t) :- label_type(t).
primitive_type(t) :- metadata_type(t).
primitive_type(t) :- x86mmx_type(t).




void_type("void").
label_type("label").
metadata_type("metadata").
x86mmx_type("x86mmx").






.decl int1_type(type:IntegerType)
.decl int8_type(type:IntegerType)
.decl int32_type(type:IntegerType)
.decl int64_type(type:IntegerType)
.decl boolean_type(type:IntegerType)

integer_type(t) :- int1_type(t).
integer_type(t) :- int8_type(t).
integer_type(t) :- int32_type(t).
integer_type(t) :- int64_type(t).

int1_type("i1").
int8_type("i8").
int32_type("i32").
int64_type("i64").

type_has_size(t, 1) :- int1_type(t).
type_has_size(t, 1) :- int8_type(t).
type_has_size(t, 4) :- int32_type(t).
type_has_size(t, 8) :- int64_type(t).


boolean_type(t) :- int1_type(t).





.decl double_type(type:FPType)
.decl float_type(type:FPType)
.decl half_type(type:FPType)
.decl fp128_type(type:FPType)
.decl x86_fp80_type(type:FPType)
.decl ppc_fp128_type(type:FPType)

fp_type(t) :- double_type(t).
fp_type(t) :- float_type(t).
fp_type(t) :- half_type(t).
fp_type(t) :- fp128_type(t).

double_type("double").
float_type("float").
half_type("half").
fp128_type("fp128").
x86_fp80_type("x86_fp80").
ppc_fp128_type("ppc_fp128").

type_has_size(t, 8) :- double_type(t).
type_has_size(t, 4) :- float_type(t).
type_has_size(t, 2) :- half_type(t).
type_has_size(t, 16) :- fp128_type(t).
type_has_size(t, 10) :- x86_fp80_type(t).
type_has_size(t, 16) :- ppc_fp128_type(t).
#line 137 "type.dl"
.type DerivedType
  = FunctionType
  | PointerType
  | VectorType
  | AggregateType

.type AggregateType
  = ArrayType
  | StructType
  | OpaqueStructType

.type FunctionType <: symbol
.type PointerType <: symbol
.type VectorType <: symbol
.type ArrayType <: symbol

.type StructType
  = TransparentStructType
  | OpaqueStructType

.type TransparentStructType <: symbol
.type OpaqueStructType <: symbol

.decl derived_type(type:DerivedType)
.decl func_type(type:FunctionType)
.decl pointer_type(type:PointerType)
.decl vector_type(type:VectorType)
.decl aggregate_type(type:AggregateType)
.decl array_type(type:ArrayType)
.decl struct_type(type:StructType)
.decl opaque_struct_type(type:OpaqueStructType)

type(t) :- derived_type(t).
derived_type(t) :- func_type(t).
derived_type(t) :- pointer_type(t).
derived_type(t) :- vector_type(t).
derived_type(t) :- aggregate_type(t).
aggregate_type(t) :- array_type(t).
aggregate_type(t) :- struct_type(t).
struct_type(t) :- opaque_struct_type(t).






.decl type_is_firstclass(type:Type)

type_is_firstclass(Type) :-
   type(Type),
   !func_type(Type),
   !void_type(Type).






.decl array_type_has_component(type:ArrayType, comp:Type)
.decl array_type_has_size(type:ArrayType, size:number)

schema_invalid_type(Type,  "type.dl" ,  198 ) :-
   schema_sanity(),
   array_type(Type),
   !array_type_has_component(Type, _).

schema_invalid_type(Type,  "type.dl" ,  203 ) :-
   schema_sanity(),
   array_type(Type),
   !array_type_has_size(Type, _).


.decl int8_array_type(type:ArrayType)

int8_array_type(Type) :-
   array_type_has_component(Type, Comp),
   int8_type(Comp).






.decl func_type_has_varargs(type:FunctionType)
.decl func_type_return(type:FunctionType, ret:Type)
.decl func_type_param(type:FunctionType, index:ArgumentIndex, param:Type)
.decl func_type_nparams(type:FunctionType, total:number)

schema_invalid_type(Type,  "type.dl" ,  225 ) :-
   schema_sanity(),
   func_type(Type),
   !func_type_nparams(Type, _).

schema_invalid_type(Type,  "type.dl" ,  230 ) :-
   schema_sanity(),
   func_type(Type),
   func_type_return(Type, RetType),
   (metadata_type(RetType) ; label_type(RetType)).






.decl pointer_type_has_component(type:PointerType, comp:Type)
.decl pointer_type_has_addr_space(type:PointerType, addr:number)

.decl integer_pointer_type(type:PointerType)
.decl fp_pointer_type(type:PointerType)
.decl struct_pointer_type(type:PointerType)
.decl array_pointer_type(type:PointerType)
.decl vector_pointer_type(type:PointerType)
.decl pointer_type_to_firstclass(type:PointerType)
.decl pointer_type_base_component(type:PointerType, baseComp:Type)

integer_pointer_type(Type) :-
   pointer_type_has_component(Type, Comp),
   integer_type(Comp).

fp_pointer_type(Type) :-
   pointer_type_has_component(Type, Comp),
   fp_type(Comp).

struct_pointer_type(Type) :-
   pointer_type_has_component(Type, Comp),
   struct_type(Comp).

array_pointer_type(Type) :-
   pointer_type_has_component(Type, Comp),
   array_type(Comp).

vector_pointer_type(Type) :-
   pointer_type_has_component(Type, Comp),
   vector_type(Comp).

pointer_type_to_firstclass(Type) :-
   pointer_type_has_component(Type, Comp),
   type_is_firstclass(Comp).


schema_invalid_type(Type,  "type.dl" ,  277 ) :-
   schema_sanity(),
   pointer_type(Type),
   !pointer_type_has_component(Type, _).

schema_invalid_type(Type,  "type.dl" ,  282 ) :-
   schema_sanity(),
   pointer_type(Type),
   pointer_type_has_component(Type, Comp),
   (void_type(Comp) ; label_type(Comp)).


pointer_type_base_component(Type, BaseComp) :-
   pointer_type_has_component(Type, BaseComp),
   !pointer_type(BaseComp).

pointer_type_base_component(Type, BaseComp) :-
   pointer_type_has_component(Type, Comp),
   pointer_type_base_component(Comp,BaseComp).






.decl struct_type_field(type:StructType, index:FieldIndex, field:Type)
.decl struct_type_nfields(type:StructType, total:number)
.decl struct_type_has_name(type:StructType, name:symbol)

schema_invalid_type(Type,  "type.dl" ,  306 ) :-
   schema_sanity(),
   struct_type(Type),
   !opaque_struct_type(Type),
   !struct_type_nfields(Type, _).


.type SubregionOffset <: number
.decl struct_type_field_offset(type:StructType, index:FieldIndex, offset:SubregionOffset)
.decl struct_type_field_bit_offset(type:StructType, index:FieldIndex, offset:number)





.decl vector_type_has_component(type:VectorType, comp:Type)
.decl vector_type_has_size(type:VectorType, size:number)

.decl integer_vector_type(type:VectorType)
.decl fp_vector_type(type:VectorType)
.decl int32_vector_type(type:VectorType)
.decl boolean_vector_type(type:VectorType)
.decl pointer_vector_type(type:VectorType)

integer_vector_type(Type) :-
   vector_type_has_component(Type, Comp),
   integer_type(Comp).

fp_vector_type(Type) :-
   vector_type_has_component(Type, Comp),
   fp_type(Comp).

int32_vector_type(Type) :-
   vector_type_has_component(Type, Comp),
   int32_type(Comp).

boolean_vector_type(Type) :-
   vector_type_has_component(Type, Comp),
   boolean_type(Comp).

pointer_vector_type(Type) :-
   vector_type_has_component(Type, Comp),
   pointer_type(Comp).
#line 362 "type.dl"
schema_invalid_type(Type,  "type.dl" ,  362 ) :-
   schema_sanity(),
   vector_type(Type),
   !vector_type_has_component(Type, _).

schema_invalid_type(Type,  "type.dl" ,  367 ) :-
   schema_sanity(),
   vector_type(Type),
   !vector_type_has_size(Type, _).

schema_invalid_type(Type,  "type.dl" ,  372 ) :-
   schema_sanity(),
   vector_type(Type),
   vector_type_has_size(Type, Size),
   Size <= 0.

schema_invalid_type(Type,  "type.dl" ,  378 ) :-
   schema_sanity(),
   vector_type(Type),
   vector_type_has_component(Type, CompType),
   !integer_type(CompType), !fp_type(CompType), !pointer_type(CompType).
#line 402 "type.dl"
.decl eq_size_vector_types(type1:VectorType, type2:VectorType)
.decl eq_size_vector_types_(type1:VectorType, type2:VectorType, type3:VectorType)

eq_size_vector_types(Type1, Type2) :-
   vector_type_has_size(Type1, Size),
   vector_type_has_size(Type2, Size).

eq_size_vector_types_(Type1, Type2, Type3) :-
   vector_type_has_size(Type1, Size),
   vector_type_has_size(Type2, Size),
   vector_type_has_size(Type3, Size).





.decl vector_compatible_types(type1:Type, type2:Type) inline

vector_compatible_types(Type1, Type2) :-
   type(Type1),
   type(Type2),
   !vector_type(Type1),
   !vector_type(Type2).

vector_compatible_types(Type1, Type2) :-
   eq_size_vector_types(Type1, Type2).
#line 6 "schema/schema.project"
#line 1 "operand.dl"









.type Variable <: symbol
.decl variable(v:Variable)

.decl variable_has_type(v:Variable, type:Type)
.decl variable_has_name(v:Variable, name:symbol)
.decl variable_is_label(v:Variable)
.decl variable_is_pointer(v:Variable)
.decl variable_is_firstclass(v:Variable)

variable_is_label(Var) :-
   variable_has_type(Var, Type),
   label_type(Type).

variable_is_pointer(Var) :-
   variable_has_type(Var, Type),
   pointer_type(Type).

variable_is_firstclass(Var) :-
   variable_has_type(Var, Type),
   type_is_firstclass(Type).

variable_in_func(Variable, Function) :-
   variable_in_func_name(Variable, FuncName),
   func_name(Function, FuncName).


.decl variable_has_debug_source_name(v:Variable, name:symbol)
.decl variable_has_debug_decl_pos(v:Variable, line:LineNumber, column:ColumnNumber)









.decl constant(c:Constant)

.decl constant_has_type(c:Constant, type:Type)
.decl constant_has_value(c:Constant, val:symbol)


.decl constant_hashes_to(c:Constant, hashcode:number)
#line 61 "operand.dl"
.decl constant_to_int(c:Constant, val:number)



.decl operand_to_int(c:Operand, val:number)
operand_to_int(c, x) :- constant_to_int(c, x).


.decl schema_invalid_constant(c:Constant, file:File, line:Line)

schema_invalid_constant(Constant,  "operand.dl" ,  71 ) :-
   schema_sanity(),
   constant(Constant),
   !constant_has_type(Constant, _).

schema_invalid_constant(Constant,  "operand.dl" ,  76 ) :-
   schema_sanity(),
   constant(Constant),
   !constant_has_value(Constant, _).







schema_invalid_constant(Constant,  "operand.dl" ,  87 ) :-
   schema_sanity(),
   constant_has_type(Constant, Type),
   label_type(Type).






.type Operand = Constant | Variable
.decl operand(op:Operand)

operand(c) :- constant(c).
operand(v) :- variable(v).




.decl operand_has_type(op:Operand, type:Type)

operand_has_type(var, type) :-
   variable_has_type(var, type).

operand_has_type(c, type) :-
   constant_has_type(c, type).




.decl operand_is_firstclass(op:Operand)
.decl operand_is_pointer(op:Operand)

operand_is_firstclass(Op) :-
   operand_has_type(Op, Type),
   type_is_firstclass(Type).

operand_is_pointer(Op) :-
   operand_has_type(Op, Type),
   pointer_type(Type).
#line 7 "schema/schema.project"
#line 1 "asm.dl"








.type InlineASM = Constant
.decl inline_asm(asm:InlineASM)

constant(asm) :- inline_asm(asm).

.decl inline_asm_text(asm:InlineASM, text:symbol)
.decl inline_asm_constraints(asm:InlineASM, constraints:symbol)
#line 8 "schema/schema.project"
#line 1 "global.dl"


.type GlobalVariable <: symbol
.decl global_var(gv:GlobalVariable)
.decl global_var_type(gv:GlobalVariable, type:Type)
.decl global_var_name(gv:GlobalVariable, name:GlobalVarName)
.decl global_var_demangled_name(gv:GlobalVariable, name:symbol)
.decl global_var_flag(gv:GlobalVariable, flag:Flag)
.decl global_var_linkage(gv:GlobalVariable, link:LinkageType)
.decl global_var_initializer(gv:GlobalVariable, init:Constant)
.decl global_var_visibility(gv:GlobalVariable, vis:Visibility)
.decl global_var_section(gv:GlobalVariable, sect:symbol)
.decl global_var_threadlocal_mode(gv:GlobalVariable, mode:ThreadLocalMode)
.decl global_var_aligned_to(gv:GlobalVariable, alignment:number)

flag(Flag) :- global_var_flag(_, Flag).



.decl schema_invalid_global_var(gv:GlobalVariable, file:File, line:Line)

schema_invalid_global_var(GVar,  "global.dl" ,  22 ) :-
   schema_sanity(),
   global_var(GVar),
   !global_var_visibility(GVar, _).

schema_invalid_global_var(GVar,  "global.dl" ,  27 ) :-
   schema_sanity(),
   global_var(GVar),
   !global_var_linkage(GVar, _).
#line 45 "global.dl"
.decl global_var_is_constant(gv:GlobalVariable)

global_var_is_constant(GVar) :-
   global_var_flag(GVar, "constant").






.type LinkageType <: symbol
.decl linkage_type(link:LinkageType)

.decl external_linkage_type(link:LinkageType)
.decl private_linkage_type(link:LinkageType)
.decl internal_linkage_type(link:LinkageType)
.decl linkonce_linkage_type(link:LinkageType)
.decl linker_private_linkage_type(link:LinkageType)
.decl linkonce_odr_linkage_type(link:LinkageType)
.decl weak_linkage_type(link:LinkageType)
.decl weak_odr_linkage_type(link:LinkageType)
.decl common_linkage_type(link:LinkageType)
.decl appending_linkage_type(link:LinkageType)
.decl dllimport_linkage_type(link:LinkageType)
.decl dllexport_linkage_type(link:LinkageType)
.decl extern_weak_linkage_type(link:LinkageType)
.decl linker_private_weak_linkage_type(link:LinkageType)
.decl available_externally_linkage_type(link:LinkageType)

linkage_type("external"). external_linkage_type("external").
linkage_type("private"). private_linkage_type("private").
linkage_type("internal"). internal_linkage_type("internal").
linkage_type("linkonce"). linkonce_linkage_type("linkonce").
linkage_type("linker_private"). linker_private_linkage_type("linker_private").
linkage_type("linkonce_odr"). linkonce_odr_linkage_type("linkonce_odr").
linkage_type("weak"). weak_linkage_type("weak").
linkage_type("weak_odr"). weak_odr_linkage_type("weak_odr").
linkage_type("common"). common_linkage_type("common").
linkage_type("appending"). appending_linkage_type("appending").
linkage_type("dllimport"). dllimport_linkage_type("dllimport").
linkage_type("dllexport"). dllexport_linkage_type("dllexport").
linkage_type("extern_weak"). extern_weak_linkage_type("extern_weak").
linkage_type("linker_private_weak"). linker_private_weak_linkage_type("linker_private_weak").
linkage_type("available_externally"). available_externally_linkage_type("available_externally").






.type Visibility <: symbol
.decl visibility(vis:Visibility)

.decl default_visibility(vis:Visibility)
.decl hidden_visibility(vis:Visibility)
.decl protected_visibility(vis:Visibility)

visibility("default"). default_visibility("default").
visibility("hidden"). hidden_visibility("hidden").
visibility("protected"). protected_visibility("protected").






.type ThreadLocalMode <: symbol
.decl threadlocal_mode(mode:ThreadLocalMode)
.decl local_dynamic_threadlocal_mode(mode:ThreadLocalMode)
.decl initial_exec_threadlocal_mode(mode:ThreadLocalMode)
.decl local_exec_threadlocal_mode(mode:ThreadLocalMode)

threadlocal_mode("thread_local").
threadlocal_mode("thread_local(localdynamic)").
threadlocal_mode("thread_local(initialexec)").
threadlocal_mode("thread_local(localexec)").
local_dynamic_threadlocal_mode("thread_local(localdynamic)").
initial_exec_threadlocal_mode("thread_local(initialexec)").
local_exec_threadlocal_mode("thread_local(localexec)").










.type Alias <: symbol
.decl alias(x:Alias)
.decl alias_aliasee(x:Alias, y:Constant)
.decl alias_name(x:Alias, name:symbol)
.decl alias_type(x:Alias, type:Type)
.decl alias_linkage(x:Alias, link:LinkageType)
.decl alias_visibility(x:Alias, vis:Visibility)


.decl schema_invalid_alias(x:Alias, file:File, line:Line)

schema_invalid_alias(Var,  "global.dl" ,  145 ) :-
   schema_sanity(),
   alias(Var),
   !alias_type(Var, _).

schema_invalid_alias(Var,  "global.dl" ,  150 ) :-
   schema_sanity(),
   alias(Var),
   !alias_name(Var, _).

schema_invalid_alias(Var,  "global.dl" ,  155 ) :-
   schema_sanity(),
   alias_linkage(Var, Link),
   !private_linkage_type(Link),
   !linker_private_linkage_type(Link),
   !linker_private_weak_linkage_type(Link),
   !internal_linkage_type(Link),
   !linkonce_linkage_type(Link),
   !weak_linkage_type(Link),
   !linkonce_odr_linkage_type(Link),
   !weak_odr_linkage_type(Link),
   !external_linkage_type(Link).
#line 9 "schema/schema.project"
#line 1 "func.dl"






.type FunctionDecl <: symbol
.type Function = FunctionDecl

.decl func_decl(func:FunctionDecl)
.decl func(func:Function)

func_decl(Func) :- func(Func).





.decl schema_invalid_func(func:FunctionDecl, file:File, line:Line)









.decl func_ty(func:FunctionDecl, type:FunctionType)
.decl func_name(func:FunctionDecl, name:FunctionName)


.decl func_signature(func:FunctionDecl, signature:symbol)

schema_invalid_func(Func,  "func.dl" ,  35 ) :-
   schema_sanity(),
   func_decl(Func),
   !func_ty(Func, _).

schema_invalid_func(Func,  "func.dl" ,  40 ) :-
   schema_sanity(),
   func_decl(Func),
   !func_name(Func, _).

.decl schema_multiple_func_names(Func: FunctionDecl, file:File, line:Line)
schema_multiple_func_names(Func,  "func.dl" ,  46 ) :-
   schema_sanity(),
   func_decl(Func),
   func_name(Func,name1),
   func_name(Func,name2),
   name1!=name2.





.decl constant_in_func(c:Constant, func:Function)
.decl variable_in_func(v:Variable, func:Function)







.decl func_alignment(func:FunctionDecl, alignment:number)
.decl func_linkage(func:FunctionDecl, link:LinkageType)
.decl func_visibility(func:FunctionDecl, vis:Visibility)
.decl func_calling_conv(func:FunctionDecl, cc:CallingConvention)
.decl func_unnamed_addr(func:FunctionDecl)
.decl func_gc(func:FunctionDecl, collector:symbol)
.decl func_pers_fn(func:FunctionDecl, persfn:Constant)

calling_convention(cc) :- func_calling_conv(_, cc).
linkage_type(link) :- func_linkage(_, link).
visibility(vis) :- func_visibility(_, vis).





.decl func_section(func:Function, section:symbol)






.decl func_nparams(func:Function, total:number)

func_nparams(Func, Total) :-
   func(Func),
   func_ty(Func, Type),
   func_type_nparams(Type, Total).


.decl func_param(func:Function, index:ArgumentIndex, param:Variable)






.decl func_func_attr(func:FunctionDecl, attr:Attribute)
.decl func_return_attr(func:FunctionDecl, attr:Attribute)
.decl func_param_attr(func:FunctionDecl, index:ArgumentIndex, attr:Attribute)

attr(Attr) :- func_func_attr(_, Attr).
attr(Attr) :- func_return_attr(_, Attr).
attr(Attr) :- func_param_attr(_, _, Attr).


.decl func_param_by_value(func:Function, index:number)

func_param_by_value(Func, Index) :-
   func_param(Func, Index, _),
   func_param_attr(Func, Index, ByValueAttr),
   parameter_attr__byval(ByValueAttr).
#line 132 "func.dl"
schema_invalid_func(Func,  "func.dl" ,  132 ) :-
   schema_sanity(),
   func_ty(Func, Type),
   func_param(Func, Index, Param),
   func_type_param(Type, Index, ParamType),
   !variable_has_type(Param, ParamType).

schema_invalid_func(Func,  "func.dl" ,  139 ) :-
   schema_sanity(),
   func(Func),
   func_ty(Func, Type),
   func_type_param(Type, Index, _),
   !func_param(Func, Index, _).

schema_invalid_func(Func,  "func.dl" ,  146 ) :-
   schema_sanity(),
   func_ty(Func, Type),
   func_param(Func, Index, _),
   !func_type_param(Type, Index, _).
#line 10 "schema/schema.project"
#line 1 "constants.dl"




.type Constant
  = IntegerConstant
  | FPConstant
  | NullPtrConstant
  | FunctionConstant
  | GlobalVariableConstant
  | ConstantArray
  | ConstantStruct
  | ConstantVector
  | ConstantExpression

.type IntegerConstant <: symbol
.type FPConstant <: symbol
.type NullPtrConstant <: symbol
.type FunctionConstant <: symbol
.type GlobalVariableConstant <: symbol
.type ConstantArray <: symbol
.type ConstantStruct <: symbol
.type ConstantVector <: symbol

.type ConstantExpression
  = BitcastConstantExpression
  | IntToPtrConstantExpression
  | PtrToIntConstantExpression
  | GetElementPtrConstantExpression

.type BitcastConstantExpression <: symbol
.type IntToPtrConstantExpression <: symbol
.type PtrToIntConstantExpression <: symbol
.type GetElementPtrConstantExpression <: symbol

.decl integer_constant(c:IntegerConstant)
.decl fp_constant(c:FPConstant)
.decl nullptr_constant(c:NullPtrConstant)
.decl func_constant(c:FunctionConstant)
.decl global_var_constant(c:GlobalVariableConstant)
.decl constant_array(c:ConstantArray)
.decl constant_struct(c:ConstantStruct)
.decl constant_vector(c:ConstantVector)
.decl constant_expression(c:ConstantExpression)
.decl bitcast_constant_expression(c:BitcastConstantExpression)
.decl inttoptr_constant_expression(c:IntToPtrConstantExpression)
.decl ptrtoint_constant_expression(c:PtrToIntConstantExpression)
.decl getelementptr_constant_expression(c:GetElementPtrConstantExpression)


constant(c) :-
   constant_expression(c)
 ; constant_array(c)
 ; constant_struct(c)
 ; global_var_constant(c)
 ; integer_constant(c)
 ; fp_constant(c)
 ; nullptr_constant(c)
 ; func_constant(c)
 ; undef_constant(c)
 ; poison_constant(c).

constant_expression(c) :-
   bitcast_constant_expression(c)
 ; inttoptr_constant_expression(c)
 ; ptrtoint_constant_expression(c)
 ; getelementptr_constant_expression(c).

constant_in_func(Constant, Function) :-
   constant_in_func_name(Constant, FuncName),
   func_name(Function, FuncName).





.decl func_constant_fn_name(fc:FunctionConstant, name:symbol)

schema_invalid_constant(Constant,  "constants.dl" ,  79 ) :-
   schema_sanity(),
   func_constant(Constant),
   !func_constant_fn_name(Constant, _).






.decl global_var_constant_name(c:GlobalVariableConstant, name:symbol)
.decl global_var_constant_reference(c:GlobalVariableConstant, gv:GlobalVariable)

global_var_constant_reference(C, GVar) :-
   global_var_constant_name(C, Name),
   global_var_name(GVar, Name).

schema_invalid_constant(Constant,  "constants.dl" ,  96 ) :-
   schema_sanity(),
   global_var_constant(Constant),
   !global_var_constant_name(Constant, _).

schema_invalid_constant(Constant,  "constants.dl" ,  101 ) :-
   schema_sanity(),
   global_var_constant(Constant),
   !global_var_constant_reference(Constant, _).

schema_invalid_constant(Constant,  "constants.dl" ,  106 ) :-
   schema_sanity(),
   global_var_constant(Constant),
   global_var_constant_reference(Constant, GVar),
   global_var_type(GVar, Type),
   constant_has_type(Constant, PtrType),
   !pointer_type_has_component(PtrType, Type).






.decl constant_array_index(c:ConstantArray, i:number, ic:Constant)
.decl constant_array_has_size(c:ConstantArray, size:number)

schema_invalid_constant(Constant,  "constants.dl" ,  122 ) :-
   schema_sanity(),
   constant_array(Constant),
   !constant_array_has_size(Constant, _).






.decl constant_struct_index(c:ConstantStruct, i:number, ic:Constant)
.decl constant_struct_has_size(c:ConstantStruct, size:number)

schema_invalid_constant(Constant,  "constants.dl" ,  135 ) :-
   schema_sanity(),
   constant_struct(Constant),
   !constant_struct_has_size(Constant, _).






.decl constant_vector_index(c:ConstantVector, i:number, ic:Constant)
.decl constant_vector_has_size(c:ConstantVector, size:number)

schema_invalid_constant(Constant,  "constants.dl" ,  148 ) :-
   schema_sanity(),
   constant_vector(Constant),
   !constant_vector_has_size(Constant, _).





.decl undef_constant(c:Constant)





.decl poison_constant(c:Constant)





.decl bitcast_constant_expression_from(cexpr:BitcastConstantExpression, val:Constant)
.decl bitcast_constant_expression_to_type(cexpr:BitcastConstantExpression, type:Type)

bitcast_constant_expression_to_type(CExpr, Type) :-
   bitcast_constant_expression(CExpr),
   constant_has_type(CExpr, Type).

schema_invalid_constant(Constant,  "constants.dl" ,  176 ) :-
   schema_sanity(),
   bitcast_constant_expression(Constant),
   !bitcast_constant_expression_from(Constant, _).

schema_invalid_constant(Constant,  "constants.dl" ,  181 ) :-
   schema_sanity(),
   bitcast_constant_expression(Constant),
   !bitcast_constant_expression_to_type(Constant, _).






.decl inttoptr_constant_expression_from(cexpr:IntToPtrConstantExpression, val:Constant)

schema_invalid_constant(Constant,  "constants.dl" ,  193 ) :-
   schema_sanity(),
   inttoptr_constant_expression(Constant),
   !inttoptr_constant_expression_from(Constant, _).






.decl ptrtoint_constant_expression_from(cexpr:IntToPtrConstantExpression, val:Constant)

schema_invalid_constant(Constant,  "constants.dl" ,  205 ) :-
   schema_sanity(),
   ptrtoint_constant_expression(Constant),
   !ptrtoint_constant_expression_from(Constant, _).






.decl getelementptr_constant_expression_base(cexpr:GetElementPtrConstantExpression, base:Constant)
.decl getelementptr_constant_expression_index(cexpr:GetElementPtrConstantExpression, i:GepIndex, c:Constant)
.decl getelementptr_constant_expression_nindices(cexpr:GetElementPtrConstantExpression, size:number)


schema_invalid_constant(Constant,  "constants.dl" ,  220 ) :-
   schema_sanity(),
   getelementptr_constant_expression(Constant),
   !getelementptr_constant_expression_nindices(Constant, _).

schema_invalid_constant(Constant,  "constants.dl" ,  225 ) :-
   schema_sanity(),
   getelementptr_constant_expression(Constant),
   !getelementptr_constant_expression_base(Constant, _).



.decl _getelementptr_constant_expression_base_type(cexpr:GetElementPtrConstantExpression, type:Type)
.decl _getelementptr_constant_expression_index_type(cexpr:GetElementPtrConstantExpression, type:Type)
.decl _getelementptr_constant_expression_value_type(cexpr:GetElementPtrConstantExpression, type:Type)
.decl _getelementptr_constant_expression_interm_type(cexpr:GetElementPtrConstantExpression, i:number, type:Type)

_getelementptr_constant_expression_base_type(CExpr, PtrType) :-
   getelementptr_constant_expression_base(CExpr, BaseConstant),
   constant_has_type(BaseConstant, PtrType).

_getelementptr_constant_expression_index_type(CExpr, Type) :-
   getelementptr_constant_expression_index(CExpr, _, IdxConstant),
   constant_has_type(IdxConstant, Type).



.decl _constant_expression_next_index(cexpr:ConstantExpression, i:number, j:number)

_constant_expression_next_index(CExpr, Index, Index + 1) :-
   getelementptr_constant_expression_index(CExpr, Index, _).




_getelementptr_constant_expression_interm_type(CExpr, 1, Type) :-
   getelementptr_constant_expression_base(CExpr, BaseConstant),
   constant_has_type(BaseConstant, PtrType),
   pointer_type_has_component(PtrType, Type).

_getelementptr_constant_expression_interm_type(CExpr, 1, Type) :-
   getelementptr_constant_expression_base(CExpr, BaseConstant),
   constant_has_type(BaseConstant, VectorType),
   vector_type_has_component(VectorType, PtrType),
   pointer_type_has_component(PtrType, Type).

_getelementptr_constant_expression_interm_type(CExpr, NextIndex, Type) :-
   _getelementptr_constant_expression_interm_type(CExpr, Index, ArrayType),
   array_type_has_component(ArrayType, Type),
   _constant_expression_next_index(CExpr, Index, NextIndex).

_getelementptr_constant_expression_interm_type(CExpr, NextIndex, Type) :-
   _getelementptr_constant_expression_interm_type(CExpr, Index, VectorType),
   vector_type_has_component(VectorType, Type),
   _constant_expression_next_index(CExpr, Index, NextIndex).

_getelementptr_constant_expression_interm_type(CExpr, NextIndex, Type) :-
   _getelementptr_constant_expression_interm_type(CExpr, Index, StructType),
   getelementptr_constant_expression_index(CExpr, Index, IdxConstant),
   constant_has_type(IdxConstant, IdxType),
   constant_to_int(IdxConstant, IdxConstantValue),
   int32_type(IdxType),
   struct_type_field(StructType, IdxConstantValue, Type),
   _constant_expression_next_index(CExpr, Index, NextIndex).

_getelementptr_constant_expression_value_type(CExpr, Type) :-
   getelementptr_constant_expression_nindices(CExpr, Total),
   _getelementptr_constant_expression_interm_type(CExpr, Total, Type).



schema_invalid_constant(Constant,  "constants.dl" ,  291 ) :-
   schema_sanity(),
   getelementptr_constant_expression(Constant),
   !_getelementptr_constant_expression_value_type(Constant, _).
#line 11 "schema/schema.project"
#line 12 "schema/schema.project"
#line 1 "instr.dl"




.type Instruction
  = AShrInstruction
  | AddInstruction
  | AllocaInstruction
  | AndInstruction
  | AtomicRMWInstruction
  | BitcastInstruction
  | BrCondInstruction
  | BrUncondInstruction
  | CallInstruction
  | CmpXchgInstruction
  | ExtractElementInstruction
  | ExtractValueInstruction
  | FAddInstruction
  | FCmpInstruction
  | FDivInstruction
  | FMulInstruction
  | FPExtInstruction
  | FPToSIInstruction
  | FPToUIInstruction
  | FPTruncInstruction
  | FRemInstruction
  | FSubInstruction
  | FenceInstruction
  | GetElementPtrInstruction
  | ICmpInstruction
  | IndirectBrInstruction
  | InsertElementInstruction
  | InsertValueInstruction
  | IntToPtrInstruction
  | InvokeInstruction
  | LShrInstruction
  | LandingPadInstruction
  | LoadInstruction
  | MulInstruction
  | OrInstruction
  | PhiInstruction
  | PtrToIntInstruction
  | ResumeInstruction
  | RetInstruction
  | SDivInstruction
  | SExtInstruction
  | SIToFPInstruction
  | SRemInstruction
  | SelectInstruction
  | ShlInstruction
  | ShuffleVectorInstruction
  | StoreInstruction
  | SubInstruction
  | SwitchInstruction
  | TruncInstruction
  | UDivInstruction
  | UIToFPInstruction
  | URemInstruction
  | UnreachableInstruction
  | VaArgInstruction
  | XorInstruction
  | ZExtInstruction


.type CallBase
  = CallInstruction
  | InvokeInstruction

.decl instr(instr:Instruction)


.decl schema_invalid_instr(instr:Instruction, file:File, line:Line)




.decl instr_assigns_to(instr:Instruction, var:Variable)


.decl instr_returns_type(instr:Instruction, type:Type)

instr_returns_type(Instr, Type) :-
   instr_assigns_to(Instr, Var),
   variable_has_type(Var, Type).


.decl terminator_instr(instr:Instruction)



.type Flag <: symbol
.decl flag(flag:Flag)
.decl instr_flag(instr:Instruction, flag:Flag)

flag(Flag) :- instr_flag(_, Flag).



.decl instr_successor_index(instr:Instruction, index:number, next_index:number)


.decl instr_pos(instr:Instruction, line:LineNumber, column:ColumnNumber)







.decl instr_successor(instr:Instruction, next:Instruction)


.decl instr_func(instr:Instruction, func:Function)

schema_invalid_instr(Instr,  "instr.dl" ,  115 ) :-
   schema_sanity(),
   instr(Instr),
   !instr_func(Instr, _).
#line 13 "schema/schema.project"
#line 1 "basic-block.dl"




.type BasicBlock <: symbol
.decl block(bb:BasicBlock)

.decl block_predecessor(v0:symbol, v1:symbol)
block_predecessors(bb0, bb1) :-
  block_predecessor(e0, e1),
  variable_is_label(e0),
  variable_is_label(e1),
  block_of_label(bb0, e0),
  block_of_label(bb1, e1).

.decl instr_bb_entry(v0:symbol, v1:symbol)
instr_block(e0, bb) :-
  instr_bb_entry(e0, e1),
  instr(e0),
  variable_is_label(e1),
  block_of_label(bb, e1).


.decl instr_block(instr:Instruction, bb:BasicBlock)

schema_invalid_instr(Instr,  "basic-block.dl" ,  26 ) :-
   schema_sanity(),
   instr(Instr),
   !instr_block(Instr, _).


.decl block_of_label(bb:BasicBlock, label:Variable)
.decl block_predecessors(bb:BasicBlock, bbpred:BasicBlock)
.decl block_first_instr(bb:BasicBlock, instr:Instruction)
.decl block_last_instr(bb:BasicBlock, instr:Instruction)

block(BB) :- block_of_label(BB, _).
block_of_label(cat("block:", Label), Label) :-
   variable_is_label(Label).

block_first_instr(BB, First) :-
   instr_block(First, BB),
   !instr_successor(_, First).

block_first_instr(BB2, First) :-
   instr_successor(Last, First),
   instr_block(Last, BB1),
   instr_block(First, BB2),
   BB1 != BB2.

block_last_instr(BB1, Last) :-
   instr_successor(Last, First),
   instr_block(Last, BB1),
   instr_block(First, BB2),
   BB1 != BB2.

block_last_instr(BB, Last) :-
   instr_block(Last, BB),
   !instr_successor(Last, _).










schema_invalid_instr(Instr,  "basic-block.dl" ,  70 ) :-
   schema_sanity(),
   instr_successor(Instr, NextInstr),
   instr_block(Instr, BB1),
   instr_block(NextInstr, BB2),
   !terminator_instr(Instr),
   BB1 != BB2.
#line 14 "schema/schema.project"
#line 1 "add-instr.dl"



.type AddInstruction <: symbol
.decl add_instr(instr:AddInstruction)

instr(v) :-
   add_instr(v).

.decl add_instr_first_operand(instr:AddInstruction, op:Operand)
.decl add_instr_second_operand(instr:AddInstruction, op:Operand)
#line 26 "add-instr.dl"
schema_invalid_instr(Instr,  "add-instr.dl" ,  26 ) :-
   schema_sanity(),
   add_instr(Instr),
   !add_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "add-instr.dl" ,  31 ) :-
   schema_sanity(),
   add_instr(Instr),
   !add_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "add-instr.dl" ,  36 ) :-
   schema_sanity(),
   add_instr(Instr),
   instr_returns_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "add-instr.dl" ,  43 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   add_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "add-instr.dl" ,  49 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   add_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 15 "schema/schema.project"
#line 1 "sub-instr.dl"



.type SubInstruction <: symbol
.decl sub_instr(instr:SubInstruction)

instr(v) :- sub_instr(v).

.decl sub_instr_first_operand(instr:SubInstruction, op:Operand)
.decl sub_instr_second_operand(instr:SubInstruction, op:Operand)
#line 25 "sub-instr.dl"
schema_invalid_instr(Instr,  "sub-instr.dl" ,  25 ) :-
   schema_sanity(),
   sub_instr(Instr),
   !sub_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "sub-instr.dl" ,  30 ) :-
   schema_sanity(),
   sub_instr(Instr),
   !sub_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "sub-instr.dl" ,  35 ) :-
   schema_sanity(),
   sub_instr(Instr),
   instr_returns_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "sub-instr.dl" ,  42 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   sub_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "sub-instr.dl" ,  48 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   sub_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 16 "schema/schema.project"
#line 1 "mul-instr.dl"



.type MulInstruction <: symbol
.decl mul_instr(instr:MulInstruction)

instr(v) :- mul_instr(v).

.decl mul_instr_first_operand(instr:MulInstruction, op:Operand)
.decl mul_instr_second_operand(instr:MulInstruction, op:Operand)
#line 25 "mul-instr.dl"
schema_invalid_instr(Instr,  "mul-instr.dl" ,  25 ) :-
   schema_sanity(),
   mul_instr(Instr),
   !mul_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "mul-instr.dl" ,  30 ) :-
   schema_sanity(),
   mul_instr(Instr),
   !mul_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "mul-instr.dl" ,  35 ) :-
   schema_sanity(),
   mul_instr(Instr),
   instr_returns_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "mul-instr.dl" ,  42 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   mul_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "mul-instr.dl" ,  48 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   mul_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 17 "schema/schema.project"
#line 1 "sdiv-instr.dl"



.type SDivInstruction <: symbol
.decl sdiv_instr(instr:SDivInstruction)

instr(v) :- sdiv_instr(v).

.decl sdiv_instr_first_operand(instr:SDivInstruction, op:Operand)
.decl sdiv_instr_second_operand(instr:SDivInstruction, op:Operand)
#line 25 "sdiv-instr.dl"
schema_invalid_instr(Instr,  "sdiv-instr.dl" ,  25 ) :-
   schema_sanity(),
   sdiv_instr(Instr),
   !sdiv_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "sdiv-instr.dl" ,  30 ) :-
   schema_sanity(),
   sdiv_instr(Instr),
   !sdiv_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "sdiv-instr.dl" ,  35 ) :-
   schema_sanity(),
   sdiv_instr(Instr),
   instr_returns_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "sdiv-instr.dl" ,  42 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   sdiv_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "sdiv-instr.dl" ,  48 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   sdiv_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 18 "schema/schema.project"
#line 1 "srem-instr.dl"



.type SRemInstruction <: symbol
.decl srem_instr(instr:SRemInstruction)

instr(v) :- srem_instr(v).

.decl srem_instr_first_operand(instr:SRemInstruction, op:Operand)
.decl srem_instr_second_operand(instr:SRemInstruction, op:Operand)
#line 25 "srem-instr.dl"
schema_invalid_instr(Instr,  "srem-instr.dl" ,  25 ) :-
   schema_sanity(),
   srem_instr(Instr),
   !srem_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "srem-instr.dl" ,  30 ) :-
   schema_sanity(),
   srem_instr(Instr),
   !srem_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "srem-instr.dl" ,  35 ) :-
   schema_sanity(),
   srem_instr(Instr),
   instr_returns_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "srem-instr.dl" ,  42 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   srem_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "srem-instr.dl" ,  48 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   srem_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 19 "schema/schema.project"
#line 1 "udiv-instr.dl"



.type UDivInstruction <: symbol
.decl udiv_instr(instr:UDivInstruction)

instr(v) :- udiv_instr(v).

.decl udiv_instr_first_operand(instr:UDivInstruction, op:Operand)
.decl udiv_instr_second_operand(instr:UDivInstruction, op:Operand)
#line 25 "udiv-instr.dl"
schema_invalid_instr(Instr,  "udiv-instr.dl" ,  25 ) :-
   schema_sanity(),
   udiv_instr(Instr),
   !udiv_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "udiv-instr.dl" ,  30 ) :-
   schema_sanity(),
   udiv_instr(Instr),
   !udiv_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "udiv-instr.dl" ,  35 ) :-
   schema_sanity(),
   udiv_instr(Instr),
   instr_returns_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "udiv-instr.dl" ,  42 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   udiv_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "udiv-instr.dl" ,  48 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   udiv_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 20 "schema/schema.project"
#line 1 "urem-instr.dl"



.type URemInstruction <: symbol
.decl urem_instr(instr:URemInstruction)

instr(v) :- urem_instr(v).

.decl urem_instr_first_operand(instr:URemInstruction, op:Operand)
.decl urem_instr_second_operand(instr:URemInstruction, op:Operand)
#line 25 "urem-instr.dl"
schema_invalid_instr(Instr,  "urem-instr.dl" ,  25 ) :-
   schema_sanity(),
   urem_instr(Instr),
   !urem_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "urem-instr.dl" ,  30 ) :-
   schema_sanity(),
   urem_instr(Instr),
   !urem_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "urem-instr.dl" ,  35 ) :-
   schema_sanity(),
   urem_instr(Instr),
   instr_returns_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "urem-instr.dl" ,  42 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   urem_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "urem-instr.dl" ,  48 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   urem_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 21 "schema/schema.project"
#line 1 "fadd-instr.dl"



.type FAddInstruction <: symbol
.decl fadd_instr(instr:FAddInstruction)

instr(v) :- fadd_instr(v).

.decl fadd_instr_first_operand(instr:FAddInstruction, op:Operand)
.decl fadd_instr_second_operand(instr:FAddInstruction, op:Operand)
#line 25 "fadd-instr.dl"
schema_invalid_instr(Instr,  "fadd-instr.dl" ,  25 ) :-
   schema_sanity(),
   fadd_instr(Instr),
   !fadd_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "fadd-instr.dl" ,  30 ) :-
   schema_sanity(),
   fadd_instr(Instr),
   !fadd_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "fadd-instr.dl" ,  35 ) :-
   schema_sanity(),
   fadd_instr(Instr),
   instr_returns_type(Instr, Type),
   !fp_type(Type),
   !fp_vector_type(Type).

schema_invalid_instr(Instr,  "fadd-instr.dl" ,  42 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   fadd_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "fadd-instr.dl" ,  48 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   fadd_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 22 "schema/schema.project"
#line 1 "fsub-instr.dl"



.type FSubInstruction <: symbol
.decl fsub_instr(instr:FSubInstruction)

instr(v) :- fsub_instr(v).

.decl fsub_instr_first_operand(instr:FSubInstruction, op:Operand)
.decl fsub_instr_second_operand(instr:FSubInstruction, op:Operand)
#line 25 "fsub-instr.dl"
schema_invalid_instr(Instr,  "fsub-instr.dl" ,  25 ) :-
   schema_sanity(),
   fsub_instr(Instr),
   !fsub_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "fsub-instr.dl" ,  30 ) :-
   schema_sanity(),
   fsub_instr(Instr),
   !fsub_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "fsub-instr.dl" ,  35 ) :-
   schema_sanity(),
   fsub_instr(Instr),
   instr_returns_type(Instr, Type),
   !fp_type(Type),
   !fp_vector_type(Type).

schema_invalid_instr(Instr,  "fsub-instr.dl" ,  42 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   fsub_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "fsub-instr.dl" ,  48 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   fsub_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 23 "schema/schema.project"
#line 1 "fmul-instr.dl"



.type FMulInstruction <: symbol
.decl fmul_instr(instr:FMulInstruction)

instr(v) :- fmul_instr(v).

.decl fmul_instr_first_operand(instr:FMulInstruction, op:Operand)
.decl fmul_instr_second_operand(instr:FMulInstruction, op:Operand)
#line 25 "fmul-instr.dl"
schema_invalid_instr(Instr,  "fmul-instr.dl" ,  25 ) :-
   schema_sanity(),
   fmul_instr(Instr),
   !fmul_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "fmul-instr.dl" ,  30 ) :-
   schema_sanity(),
   fmul_instr(Instr),
   !fmul_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "fmul-instr.dl" ,  35 ) :-
   schema_sanity(),
   fmul_instr(Instr),
   instr_returns_type(Instr, Type),
   !fp_type(Type),
   !fp_vector_type(Type).

schema_invalid_instr(Instr,  "fmul-instr.dl" ,  42 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   fmul_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "fmul-instr.dl" ,  48 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   fmul_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 24 "schema/schema.project"
#line 1 "fdiv-instr.dl"



.type FDivInstruction <: symbol
.decl fdiv_instr(instr:FDivInstruction)

instr(v) :- fdiv_instr(v).

.decl fdiv_instr_first_operand(instr:FDivInstruction, op:Operand)
.decl fdiv_instr_second_operand(instr:FDivInstruction, op:Operand)
#line 25 "fdiv-instr.dl"
schema_invalid_instr(Instr,  "fdiv-instr.dl" ,  25 ) :-
   schema_sanity(),
   fdiv_instr(Instr),
   !fdiv_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "fdiv-instr.dl" ,  30 ) :-
   schema_sanity(),
   fdiv_instr(Instr),
   !fdiv_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "fdiv-instr.dl" ,  35 ) :-
   schema_sanity(),
   fdiv_instr(Instr),
   instr_returns_type(Instr, Type),
   !fp_type(Type),
   !fp_vector_type(Type).

schema_invalid_instr(Instr,  "fdiv-instr.dl" ,  42 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   fdiv_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "fdiv-instr.dl" ,  48 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   fdiv_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 25 "schema/schema.project"
#line 1 "frem-instr.dl"



.type FRemInstruction <: symbol
.decl frem_instr(instr:FRemInstruction)

instr(v) :- frem_instr(v).

.decl frem_instr_first_operand(instr:FRemInstruction, op:Operand)
.decl frem_instr_second_operand(instr:FRemInstruction, op:Operand)
#line 25 "frem-instr.dl"
schema_invalid_instr(Instr,  "frem-instr.dl" ,  25 ) :-
   schema_sanity(),
   frem_instr(Instr),
   !frem_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "frem-instr.dl" ,  30 ) :-
   schema_sanity(),
   frem_instr(Instr),
   !frem_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "frem-instr.dl" ,  35 ) :-
   schema_sanity(),
   frem_instr(Instr),
   instr_returns_type(Instr, Type),
   !fp_type(Type),
   !fp_vector_type(Type).

schema_invalid_instr(Instr,  "frem-instr.dl" ,  42 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   frem_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "frem-instr.dl" ,  48 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   frem_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 26 "schema/schema.project"
#line 1 "and-instr.dl"



.type AndInstruction <: symbol
.decl and_instr(instr:AndInstruction)

instr(v) :-
   and_instr(v).

.decl and_instr_first_operand(instr:AndInstruction, op:Operand)
.decl and_instr_second_operand(instr:AndInstruction, op:Operand)
#line 26 "and-instr.dl"
schema_invalid_instr(Instr,  "and-instr.dl" ,  26 ) :-
   schema_sanity(),
   and_instr(Instr),
   !and_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "and-instr.dl" ,  31 ) :-
   schema_sanity(),
   and_instr(Instr),
   !and_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "and-instr.dl" ,  36 ) :-
   schema_sanity(),
   and_instr(Instr),
   instr_returns_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "and-instr.dl" ,  43 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   and_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "and-instr.dl" ,  49 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   and_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 27 "schema/schema.project"
#line 1 "or-instr.dl"



.type OrInstruction <: symbol
.decl or_instr(instr:OrInstruction)

instr(v) :-
   or_instr(v).

.decl or_instr_first_operand(instr:OrInstruction, op:Operand)
.decl or_instr_second_operand(instr:OrInstruction, op:Operand)
#line 26 "or-instr.dl"
schema_invalid_instr(Instr,  "or-instr.dl" ,  26 ) :-
   schema_sanity(),
   or_instr(Instr),
   !or_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "or-instr.dl" ,  31 ) :-
   schema_sanity(),
   or_instr(Instr),
   !or_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "or-instr.dl" ,  36 ) :-
   schema_sanity(),
   or_instr(Instr),
   instr_returns_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "or-instr.dl" ,  43 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   or_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "or-instr.dl" ,  49 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   or_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 28 "schema/schema.project"
#line 1 "xor-instr.dl"



.type XorInstruction <: symbol
.decl xor_instr(instr:XorInstruction)

instr(v) :-
   xor_instr(v).

.decl xor_instr_first_operand(instr:XorInstruction, op:Operand)
.decl xor_instr_second_operand(instr:XorInstruction, op:Operand)
#line 26 "xor-instr.dl"
schema_invalid_instr(Instr,  "xor-instr.dl" ,  26 ) :-
   schema_sanity(),
   xor_instr(Instr),
   !xor_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "xor-instr.dl" ,  31 ) :-
   schema_sanity(),
   xor_instr(Instr),
   !xor_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "xor-instr.dl" ,  36 ) :-
   schema_sanity(),
   xor_instr(Instr),
   instr_returns_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "xor-instr.dl" ,  43 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   xor_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "xor-instr.dl" ,  49 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   xor_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 29 "schema/schema.project"
#line 1 "ashr-instr.dl"



.type AShrInstruction <: symbol
.decl ashr_instr(instr:AShrInstruction)

instr(v) :-
   ashr_instr(v).

.decl ashr_instr_first_operand(instr:AShrInstruction, op:Operand)
.decl ashr_instr_second_operand(instr:AShrInstruction, op:Operand)
#line 26 "ashr-instr.dl"
schema_invalid_instr(Instr,  "ashr-instr.dl" ,  26 ) :-
   schema_sanity(),
   ashr_instr(Instr),
   !ashr_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "ashr-instr.dl" ,  31 ) :-
   schema_sanity(),
   ashr_instr(Instr),
   !ashr_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "ashr-instr.dl" ,  36 ) :-
   schema_sanity(),
   ashr_instr(Instr),
   instr_returns_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "ashr-instr.dl" ,  43 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   ashr_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "ashr-instr.dl" ,  49 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   ashr_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 30 "schema/schema.project"
#line 1 "lshr-instr.dl"



.type LShrInstruction <: symbol
.decl lshr_instr(instr:LShrInstruction)

instr(v) :-
   lshr_instr(v).

.decl lshr_instr_first_operand(instr:LShrInstruction, op:Operand)
.decl lshr_instr_second_operand(instr:LShrInstruction, op:Operand)
#line 26 "lshr-instr.dl"
schema_invalid_instr(Instr,  "lshr-instr.dl" ,  26 ) :-
   schema_sanity(),
   lshr_instr(Instr),
   !lshr_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "lshr-instr.dl" ,  31 ) :-
   schema_sanity(),
   lshr_instr(Instr),
   !lshr_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "lshr-instr.dl" ,  36 ) :-
   schema_sanity(),
   lshr_instr(Instr),
   instr_returns_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "lshr-instr.dl" ,  43 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   lshr_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "lshr-instr.dl" ,  49 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   lshr_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 31 "schema/schema.project"
#line 1 "shl-instr.dl"



.type ShlInstruction <: symbol
.decl shl_instr(instr:ShlInstruction)

instr(v) :-
   shl_instr(v).

.decl shl_instr_first_operand(instr:ShlInstruction, op:Operand)
.decl shl_instr_second_operand(instr:ShlInstruction, op:Operand)
#line 26 "shl-instr.dl"
schema_invalid_instr(Instr,  "shl-instr.dl" ,  26 ) :-
   schema_sanity(),
   shl_instr(Instr),
   !shl_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "shl-instr.dl" ,  31 ) :-
   schema_sanity(),
   shl_instr(Instr),
   !shl_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "shl-instr.dl" ,  36 ) :-
   schema_sanity(),
   shl_instr(Instr),
   instr_returns_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "shl-instr.dl" ,  43 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   shl_instr_first_operand(Instr, LeftOp),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "shl-instr.dl" ,  49 ) :-
   schema_sanity(),
   instr_returns_type(Instr, Type),
   shl_instr_second_operand(Instr, RightOp),
   !operand_has_type(RightOp, Type).
#line 32 "schema/schema.project"
#line 1 "icmp-instr.dl"



.type ICmpInstruction <: symbol
.decl icmp_instr(instr:ICmpInstruction)

instr(v) :- icmp_instr(v).

.type ICmpCondition <: symbol

.decl icmp_instr_condition(instr:ICmpInstruction, cond:ICmpCondition)
.decl icmp_instr_first_operand(instr:ICmpInstruction, op:Operand)
.decl icmp_instr_second_operand(instr:ICmpInstruction, op:Operand)



.decl icmp_condition(cond:ICmpCondition)
icmp_condition(Cond) :- icmp_instr_condition(_, Cond).

.decl icmp_condition__eq(cond:ICmpCondition)
.decl icmp_condition__ne(cond:ICmpCondition)
.decl icmp_condition__sgt(cond:ICmpCondition)
.decl icmp_condition__sge(cond:ICmpCondition)
.decl icmp_condition__slt(cond:ICmpCondition)
.decl icmp_condition__sle(cond:ICmpCondition)
.decl icmp_condition__ugt(cond:ICmpCondition)
.decl icmp_condition__ule(cond:ICmpCondition)
.decl icmp_condition__uge(cond:ICmpCondition)
.decl icmp_condition__ult(cond:ICmpCondition)

icmp_condition__eq("eq") :- icmp_condition("eq").
icmp_condition__ne("ne") :- icmp_condition("ne") .
icmp_condition__sgt("sgt") :- icmp_condition("sgt").
icmp_condition__sge("sge") :- icmp_condition("sge").
icmp_condition__slt("slt") :- icmp_condition("slt").
icmp_condition__sle("sle") :- icmp_condition("sle").
icmp_condition__ugt("ugt") :- icmp_condition("ugt").
icmp_condition__ule("ule") :- icmp_condition("ule").
icmp_condition__uge("uge") :- icmp_condition("uge").
icmp_condition__ult("ult") :- icmp_condition("ult").

schema_invalid_instr(Instr,  "icmp-instr.dl" ,  42 ) :-
   schema_sanity(), icmp_instr_condition(Instr, Cond),
   !icmp_condition__eq(Cond), !icmp_condition__ne(Cond),
   !icmp_condition__sgt(Cond), !icmp_condition__sge(Cond),
   !icmp_condition__slt(Cond), !icmp_condition__sle(Cond),
   !icmp_condition__ugt(Cond), !icmp_condition__ule(Cond),
   !icmp_condition__uge(Cond), !icmp_condition__ult(Cond).




.decl icmp_instr_from_type(instr:ICmpInstruction, type:Type)
.decl icmp_instr_to_type(instr:ICmpInstruction, type:Type)

icmp_instr_from_type(Instr, Type) :-
   icmp_instr_first_operand(Instr, Operand),
   operand_has_type(Operand, Type).

icmp_instr_to_type(Instr, Type) :-
   icmp_instr(Instr),
   instr_returns_type(Instr, Type).
#line 81 "icmp-instr.dl"
schema_invalid_instr(Instr,  "icmp-instr.dl" ,  81 ) :-
   schema_sanity(),
   icmp_instr(Instr),
   !icmp_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "icmp-instr.dl" ,  86 ) :-
   schema_sanity(),
   icmp_instr(Instr),
   !icmp_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "icmp-instr.dl" ,  91 ) :-
   schema_sanity(),
   icmp_instr(Instr),
   !icmp_instr_condition(Instr, _).

schema_invalid_instr(Instr,  "icmp-instr.dl" ,  96 ) :-
   schema_sanity(),
   icmp_instr_to_type(Instr, Type),
   !boolean_type(Type),
   !boolean_vector_type(Type).

schema_invalid_instr(Instr,  "icmp-instr.dl" ,  102 ) :-
   schema_sanity(),
   icmp_instr_from_type(Instr, Type),
   !integer_type(Type),
   !pointer_type(Type),
   !integer_vector_type(Type),
   !pointer_vector_type(Type).

schema_invalid_instr(Instr,  "icmp-instr.dl" ,  110 ) :-
   schema_sanity(),
   icmp_instr(Instr),
   icmp_instr_first_operand(Instr, LeftOp),
   icmp_instr_second_operand(Instr, RightOp),
   operand_has_type(LeftOp, LeftType),
   operand_has_type(RightOp, RightType),
   LeftType != RightType.

schema_invalid_instr(Instr,  "icmp-instr.dl" ,  119 ) :-
   schema_sanity(),
   icmp_instr_from_type(Instr, FromType),
   icmp_instr_to_type(Instr, ToType),
   !vector_compatible_types(FromType, ToType).
#line 33 "schema/schema.project"
#line 1 "fcmp-instr.dl"



.type FCmpInstruction <: symbol
.decl fcmp_instr(instr:FCmpInstruction)

instr(v) :- fcmp_instr(v).

.type FCmpCondition <: symbol

.decl fcmp_instr_condition(instr:FCmpInstruction, cond:FCmpCondition)
.decl fcmp_instr_first_operand(instr:FCmpInstruction, op:Operand)
.decl fcmp_instr_second_operand(instr:FCmpInstruction, op:Operand)









.decl fcmp_condition(cond:FCmpCondition)
fcmp_condition(Cond) :- fcmp_instr_condition(_, Cond).

.decl fcmp_condition__false(cond:FCmpCondition)
.decl fcmp_condition__true(cond:FCmpCondition)
.decl fcmp_condition__oeq(cond:FCmpCondition)
.decl fcmp_condition__ogt(cond:FCmpCondition)
.decl fcmp_condition__oge(cond:FCmpCondition)
.decl fcmp_condition__olt(cond:FCmpCondition)
.decl fcmp_condition__ole(cond:FCmpCondition)
.decl fcmp_condition__one(cond:FCmpCondition)
.decl fcmp_condition__ord(cond:FCmpCondition)
.decl fcmp_condition__ueq(cond:FCmpCondition)
.decl fcmp_condition__ugt(cond:FCmpCondition)
.decl fcmp_condition__uge(cond:FCmpCondition)
.decl fcmp_condition__ult(cond:FCmpCondition)
.decl fcmp_condition__ule(cond:FCmpCondition)
.decl fcmp_condition__une(cond:FCmpCondition)
.decl fcmp_condition__uno(cond:FCmpCondition)

fcmp_condition__false("false") :- fcmp_condition("false").
fcmp_condition__true("true") :- fcmp_condition("true").
fcmp_condition__oeq("oeq") :- fcmp_condition("oeq").
fcmp_condition__ogt("ogt") :- fcmp_condition("ogt").
fcmp_condition__oge("oge") :- fcmp_condition("oge").
fcmp_condition__olt("olt") :- fcmp_condition("olt").
fcmp_condition__ole("ole") :- fcmp_condition("ole").
fcmp_condition__one("one") :- fcmp_condition("one").
fcmp_condition__ord("ord") :- fcmp_condition("ord").
fcmp_condition__ueq("ueq") :- fcmp_condition("ueq").
fcmp_condition__ugt("ugt") :- fcmp_condition("ugt").
fcmp_condition__uge("uge") :- fcmp_condition("uge").
fcmp_condition__ult("ult") :- fcmp_condition("ult").
fcmp_condition__ule("ule") :- fcmp_condition("ule").
fcmp_condition__une("une") :- fcmp_condition("une").
fcmp_condition__uno("uno") :- fcmp_condition("uno").


schema_invalid_instr(Instr,  "fcmp-instr.dl" ,  61 ) :-
   schema_sanity(), fcmp_instr_condition(Instr, Cond),
   !fcmp_condition__false(Cond), !fcmp_condition__true(Cond),
   !fcmp_condition__oeq(Cond), !fcmp_condition__ogt(Cond),
   !fcmp_condition__oge(Cond), !fcmp_condition__olt(Cond),
   !fcmp_condition__ole(Cond), !fcmp_condition__one(Cond),
   !fcmp_condition__ord(Cond), !fcmp_condition__ueq(Cond),
   !fcmp_condition__ugt(Cond), !fcmp_condition__uge(Cond),
   !fcmp_condition__ult(Cond), !fcmp_condition__ule(Cond),
   !fcmp_condition__une(Cond), !fcmp_condition__uno(Cond).




.decl fcmp_instr_from_type(instr:FCmpInstruction, type:Type)
.decl fcmp_instr_to_type(instr:FCmpInstruction, type:Type)

fcmp_instr_from_type(Instr, Type) :-
   fcmp_instr_first_operand(Instr, Operand),
   operand_has_type(Operand, Type).

fcmp_instr_to_type(Instr, Type) :-
   fcmp_instr(Instr),
   instr_returns_type(Instr, Type).
#line 105 "fcmp-instr.dl"
schema_invalid_instr(Instr,  "fcmp-instr.dl" ,  105 ) :-
   schema_sanity(),
   fcmp_instr(Instr),
   !fcmp_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "fcmp-instr.dl" ,  110 ) :-
   schema_sanity(),
   fcmp_instr(Instr),
   !fcmp_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "fcmp-instr.dl" ,  115 ) :-
   schema_sanity(),
   fcmp_instr(Instr),
   !fcmp_instr_condition(Instr, _).

schema_invalid_instr(Instr,  "fcmp-instr.dl" ,  120 ) :-
   schema_sanity(),
   fcmp_instr_to_type(Instr, Type),
   !boolean_type(Type),
   !boolean_vector_type(Type).

schema_invalid_instr(Instr,  "fcmp-instr.dl" ,  126 ) :-
   schema_sanity(),
   fcmp_instr_from_type(Instr, Type),
   !fp_type(Type),
   !fp_vector_type(Type).

schema_invalid_instr(Instr,  "fcmp-instr.dl" ,  132 ) :-
   schema_sanity(),
   fcmp_instr(Instr),
   fcmp_instr_first_operand(Instr, LeftOp),
   fcmp_instr_second_operand(Instr, RightOp),
   operand_has_type(LeftOp, LeftType),
   operand_has_type(RightOp, RightType),
   LeftType != RightType.

schema_invalid_instr(Instr,  "fcmp-instr.dl" ,  141 ) :-
   schema_sanity(),
   fcmp_instr_from_type(Instr, FromType),
   fcmp_instr_to_type(Instr, ToType),
   !vector_compatible_types(FromType, ToType).
#line 34 "schema/schema.project"
#line 1 "bitcast-instr.dl"



.type BitcastInstruction <: symbol
.decl bitcast_instr(instr:BitcastInstruction)

instr(v) :- bitcast_instr(v).

.decl bitcast_instr_from_operand(instr:BitcastInstruction, val:Operand)
.decl bitcast_instr_to_type(instr:BitcastInstruction, type:Type)




.decl bitcast_instr_from_type(instr:BitcastInstruction, type:Type)

bitcast_instr_from_type(Instr, Type) :-
   bitcast_instr_from_operand(Instr, Operand),
   operand_has_type(Operand, Type).
#line 35 "bitcast-instr.dl"
schema_invalid_instr(Instr,  "bitcast-instr.dl" ,  35 ) :-
   schema_sanity(),
   bitcast_instr(Instr),
   !bitcast_instr_from_operand(Instr, _).

schema_invalid_instr(Instr,  "bitcast-instr.dl" ,  40 ) :-
   schema_sanity(),
   bitcast_instr(Instr),
   !bitcast_instr_to_type(Instr, _).

schema_invalid_instr(Instr,  "bitcast-instr.dl" ,  45 ) :-
   schema_sanity(),
   bitcast_instr(Instr),
   bitcast_instr_to_type(Instr, Type),
   !instr_returns_type(Instr, Type).

schema_invalid_instr(Instr,  "bitcast-instr.dl" ,  51 ) :-
   schema_sanity(),
   bitcast_instr(Instr),
   bitcast_instr_from_type(Instr, Type),
   ( !type_is_firstclass(Type)
   ; aggregate_type(Type) ).

schema_invalid_instr(Instr,  "bitcast-instr.dl" ,  58 ) :-
   schema_sanity(),
   bitcast_instr(Instr),
   bitcast_instr_to_type(Instr, Type),
   ( !type_is_firstclass(Type)
   ; aggregate_type(Type) ).

schema_invalid_instr(Instr,  "bitcast-instr.dl" ,  65 ) :-
   schema_sanity(),
   bitcast_instr(Instr),
   bitcast_instr_from_type(Instr, FromType),
   bitcast_instr_to_type(Instr, ToType),
   pointer_type(FromType),
   !pointer_type(ToType).

schema_invalid_instr(Instr,  "bitcast-instr.dl" ,  73 ) :-
   schema_sanity(),
   bitcast_instr(Instr),
   bitcast_instr_from_type(Instr, FromType),
   bitcast_instr_to_type(Instr, ToType),
   !pointer_type(FromType),
   pointer_type(ToType).
#line 35 "schema/schema.project"
#line 1 "inttoptr-instr.dl"



.type IntToPtrInstruction <: symbol
.decl inttoptr_instr(instr:IntToPtrInstruction)

instr(v) :- inttoptr_instr(v).

.decl inttoptr_instr_from_operand(instr:IntToPtrInstruction, val:Operand)
.decl inttoptr_instr_to_type(instr:IntToPtrInstruction, type:Type)




.decl inttoptr_instr_from_type(instr:IntToPtrInstruction, type:Type)

inttoptr_instr_from_type(Instr, Type) :-
   inttoptr_instr_from_operand(Instr, Operand),
   operand_has_type(Operand, Type).
#line 35 "inttoptr-instr.dl"
schema_invalid_instr(Instr,  "inttoptr-instr.dl" ,  35 ) :-
   schema_sanity(),
   inttoptr_instr(Instr),
   !inttoptr_instr_from_operand(Instr, _).

schema_invalid_instr(Instr,  "inttoptr-instr.dl" ,  40 ) :-
   schema_sanity(),
   inttoptr_instr(Instr),
   !inttoptr_instr_to_type(Instr, _).

schema_invalid_instr(Instr,  "inttoptr-instr.dl" ,  45 ) :-
   schema_sanity(),
   inttoptr_instr(Instr),
   inttoptr_instr_to_type(Instr, Type),
   !instr_returns_type(Instr, Type).

schema_invalid_instr(Instr,  "inttoptr-instr.dl" ,  51 ) :-
   schema_sanity(),
   inttoptr_instr(Instr),
   inttoptr_instr_from_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "inttoptr-instr.dl" ,  58 ) :-
   schema_sanity(),
   inttoptr_instr(Instr),
   inttoptr_instr_to_type(Instr, Type),
   !pointer_type(Type),
   !pointer_vector_type(Type).

schema_invalid_instr(Instr,  "inttoptr-instr.dl" ,  65 ) :-
   schema_sanity(),
   inttoptr_instr(Instr),
   inttoptr_instr_from_type(Instr, FromType),
   inttoptr_instr_to_type(Instr, ToType),
   !vector_compatible_types(FromType, ToType).
#line 36 "schema/schema.project"
#line 1 "ptrtoint-instr.dl"



.type PtrToIntInstruction <: symbol
.decl ptrtoint_instr(instr:PtrToIntInstruction)

instr(v) :- ptrtoint_instr(v).

.decl ptrtoint_instr_from_operand(instr:PtrToIntInstruction, val:Operand)
.decl ptrtoint_instr_to_type(instr:PtrToIntInstruction, type:Type)




.decl ptrtoint_instr_from_type(instr:PtrToIntInstruction, type:Type)

ptrtoint_instr_from_type(Instr, Type) :-
   ptrtoint_instr_from_operand(Instr, Operand),
   operand_has_type(Operand, Type).
#line 35 "ptrtoint-instr.dl"
schema_invalid_instr(Instr,  "ptrtoint-instr.dl" ,  35 ) :-
   schema_sanity(),
   ptrtoint_instr(Instr),
   !ptrtoint_instr_from_operand(Instr, _).

schema_invalid_instr(Instr,  "ptrtoint-instr.dl" ,  40 ) :-
   schema_sanity(),
   ptrtoint_instr(Instr),
   !ptrtoint_instr_to_type(Instr, _).

schema_invalid_instr(Instr,  "ptrtoint-instr.dl" ,  45 ) :-
   schema_sanity(),
   ptrtoint_instr(Instr),
   ptrtoint_instr_to_type(Instr, Type),
   !instr_returns_type(Instr, Type).

schema_invalid_instr(Instr,  "ptrtoint-instr.dl" ,  51 ) :-
   schema_sanity(),
   ptrtoint_instr(Instr),
   ptrtoint_instr_from_type(Instr, Type),
   !pointer_type(Type),
   !pointer_vector_type(Type).

schema_invalid_instr(Instr,  "ptrtoint-instr.dl" ,  58 ) :-
   schema_sanity(),
   ptrtoint_instr(Instr),
   ptrtoint_instr_to_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "ptrtoint-instr.dl" ,  65 ) :-
   schema_sanity(),
   ptrtoint_instr(Instr),
   ptrtoint_instr_from_type(Instr, FromType),
   ptrtoint_instr_to_type(Instr, ToType),
   !vector_compatible_types(FromType, ToType).
#line 37 "schema/schema.project"
#line 1 "fpext-instr.dl"



.type FPExtInstruction <: symbol
.decl fpext_instr(instr:FPExtInstruction)

instr(v) :- fpext_instr(v).

.decl fpext_instr_from_operand(instr:FPExtInstruction, val:Operand)
.decl fpext_instr_to_type(instr:FPExtInstruction, type:Type)




.decl fpext_instr_from_type(instr:FPExtInstruction, type:Type)

fpext_instr_from_type(Instr, Type) :-
   fpext_instr_from_operand(Instr, Operand),
   operand_has_type(Operand, Type).
#line 32 "fpext-instr.dl"
schema_invalid_instr(Instr,  "fpext-instr.dl" ,  32 ) :-
   schema_sanity(),
   fpext_instr(Instr),
   !fpext_instr_from_operand(Instr, _).

schema_invalid_instr(Instr,  "fpext-instr.dl" ,  37 ) :-
   schema_sanity(),
   fpext_instr(Instr),
   !fpext_instr_to_type(Instr, _).

schema_invalid_instr(Instr,  "fpext-instr.dl" ,  42 ) :-
   schema_sanity(),
   fpext_instr(Instr),
   fpext_instr_to_type(Instr, Type),
   !instr_returns_type(Instr, Type).

schema_invalid_instr(Instr,  "fpext-instr.dl" ,  48 ) :-
   schema_sanity(),
   fpext_instr(Instr),
   fpext_instr_from_type(Instr, Type),
   !fp_type(Type).

schema_invalid_instr(Instr,  "fpext-instr.dl" ,  54 ) :-
   schema_sanity(),
   fpext_instr(Instr),
   fpext_instr_to_type(Instr, Type),
   !fp_type(Type).
#line 38 "schema/schema.project"
#line 1 "sext-instr.dl"



.type SExtInstruction <: symbol
.decl sext_instr(instr:SExtInstruction)

instr(v) :- sext_instr(v).

.decl sext_instr_from_operand(instr:SExtInstruction, val:Operand)
.decl sext_instr_to_type(instr:SExtInstruction, type:Type)




.decl sext_instr_from_type(instr:SExtInstruction, type:Type)

sext_instr_from_type(Instr, Type) :-
   sext_instr_from_operand(Instr, Operand),
   operand_has_type(Operand, Type).
#line 36 "sext-instr.dl"
schema_invalid_instr(Instr,  "sext-instr.dl" ,  36 ) :-
   schema_sanity(),
   sext_instr(Instr),
   !sext_instr_from_operand(Instr, _).

schema_invalid_instr(Instr,  "sext-instr.dl" ,  41 ) :-
   schema_sanity(),
   sext_instr(Instr),
   !sext_instr_to_type(Instr, _).

schema_invalid_instr(Instr,  "sext-instr.dl" ,  46 ) :-
   schema_sanity(),
   sext_instr(Instr),
   sext_instr_to_type(Instr, Type),
   !instr_returns_type(Instr, Type).

schema_invalid_instr(Instr,  "sext-instr.dl" ,  52 ) :-
   schema_sanity(),
   sext_instr(Instr),
   sext_instr_from_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "sext-instr.dl" ,  59 ) :-
   schema_sanity(),
   sext_instr(Instr),
   sext_instr_to_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "sext-instr.dl" ,  66 ) :-
   schema_sanity(),
   sext_instr(Instr),
   sext_instr_from_type(Instr, FromType),
   sext_instr_to_type(Instr, ToType),
   !vector_compatible_types(FromType, ToType).
#line 39 "schema/schema.project"
#line 1 "zext-instr.dl"



.type ZExtInstruction <: symbol
.decl zext_instr(instr:ZExtInstruction)

instr(v) :- zext_instr(v).

.decl zext_instr_from_operand(instr:ZExtInstruction, val:Operand)
.decl zext_instr_to_type(instr:ZExtInstruction, type:Type)




.decl zext_instr_from_type(instr:ZExtInstruction, type:Type)

zext_instr_from_type(Instr, Type) :-
   zext_instr_from_operand(Instr, Operand),
   operand_has_type(Operand, Type).
#line 36 "zext-instr.dl"
schema_invalid_instr(Instr,  "zext-instr.dl" ,  36 ) :-
   schema_sanity(),
   zext_instr(Instr),
   !zext_instr_from_operand(Instr, _).

schema_invalid_instr(Instr,  "zext-instr.dl" ,  41 ) :-
   schema_sanity(),
   zext_instr(Instr),
   !zext_instr_to_type(Instr, _).

schema_invalid_instr(Instr,  "zext-instr.dl" ,  46 ) :-
   schema_sanity(),
   zext_instr(Instr),
   zext_instr_to_type(Instr, Type),
   !instr_returns_type(Instr, Type).

schema_invalid_instr(Instr,  "zext-instr.dl" ,  52 ) :-
   schema_sanity(),
   zext_instr(Instr),
   zext_instr_from_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "zext-instr.dl" ,  59 ) :-
   schema_sanity(),
   zext_instr(Instr),
   zext_instr_to_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "zext-instr.dl" ,  66 ) :-
   schema_sanity(),
   zext_instr(Instr),
   zext_instr_from_type(Instr, FromType),
   zext_instr_to_type(Instr, ToType),
   !vector_compatible_types(FromType, ToType).
#line 40 "schema/schema.project"
#line 1 "fptosi-instr.dl"



.type FPToSIInstruction <: symbol
.decl fptosi_instr(instr:FPToSIInstruction)

instr(v) :- fptosi_instr(v).

.decl fptosi_instr_from_operand(instr:FPToSIInstruction, val:Operand)
.decl fptosi_instr_to_type(instr:FPToSIInstruction, type:Type)




.decl fptosi_instr_from_type(instr:FPToSIInstruction, type:Type)

fptosi_instr_from_type(Instr, Type) :-
   fptosi_instr_from_operand(Instr, Operand),
   operand_has_type(Operand, Type).
#line 36 "fptosi-instr.dl"
schema_invalid_instr(Instr,  "fptosi-instr.dl" ,  36 ) :-
   schema_sanity(),
   fptosi_instr(Instr),
   !fptosi_instr_from_operand(Instr, _).

schema_invalid_instr(Instr,  "fptosi-instr.dl" ,  41 ) :-
   schema_sanity(),
   fptosi_instr(Instr),
   !fptosi_instr_to_type(Instr, _).

schema_invalid_instr(Instr,  "fptosi-instr.dl" ,  46 ) :-
   schema_sanity(),
   fptosi_instr(Instr),
   fptosi_instr_to_type(Instr, Type),
   !instr_returns_type(Instr, Type).

schema_invalid_instr(Instr,  "fptosi-instr.dl" ,  52 ) :-
   schema_sanity(),
   fptosi_instr(Instr),
   fptosi_instr_from_type(Instr, Type),
   !fp_type(Type),
   !fp_vector_type(Type).

schema_invalid_instr(Instr,  "fptosi-instr.dl" ,  59 ) :-
   schema_sanity(),
   fptosi_instr(Instr),
   fptosi_instr_to_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "fptosi-instr.dl" ,  66 ) :-
   schema_sanity(),
   fptosi_instr(Instr),
   fptosi_instr_from_type(Instr, FromType),
   fptosi_instr_to_type(Instr, ToType),
   !vector_compatible_types(FromType, ToType).
#line 41 "schema/schema.project"
#line 1 "fptoui-instr.dl"



.type FPToUIInstruction <: symbol
.decl fptoui_instr(instr:FPToUIInstruction)

instr(v) :- fptoui_instr(v).

.decl fptoui_instr_from_operand(instr:FPToUIInstruction, val:Operand)
.decl fptoui_instr_to_type(instr:FPToUIInstruction, type:Type)




.decl fptoui_instr_from_type(instr:FPToUIInstruction, type:Type)

fptoui_instr_from_type(Instr, Type) :-
   fptoui_instr_from_operand(Instr, Operand),
   operand_has_type(Operand, Type).
#line 36 "fptoui-instr.dl"
schema_invalid_instr(Instr,  "fptoui-instr.dl" ,  36 ) :-
   schema_sanity(),
   fptoui_instr(Instr),
   !fptoui_instr_from_operand(Instr, _).

schema_invalid_instr(Instr,  "fptoui-instr.dl" ,  41 ) :-
   schema_sanity(),
   fptoui_instr(Instr),
   !fptoui_instr_to_type(Instr, _).

schema_invalid_instr(Instr,  "fptoui-instr.dl" ,  46 ) :-
   schema_sanity(),
   fptoui_instr(Instr),
   fptoui_instr_to_type(Instr, Type),
   !instr_returns_type(Instr, Type).

schema_invalid_instr(Instr,  "fptoui-instr.dl" ,  52 ) :-
   schema_sanity(),
   fptoui_instr(Instr),
   fptoui_instr_from_type(Instr, Type),
   !fp_type(Type),
   !fp_vector_type(Type).

schema_invalid_instr(Instr,  "fptoui-instr.dl" ,  59 ) :-
   schema_sanity(),
   fptoui_instr(Instr),
   fptoui_instr_to_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "fptoui-instr.dl" ,  66 ) :-
   schema_sanity(),
   fptoui_instr(Instr),
   fptoui_instr_from_type(Instr, FromType),
   fptoui_instr_to_type(Instr, ToType),
   !vector_compatible_types(FromType, ToType).
#line 42 "schema/schema.project"
#line 1 "sitofp-instr.dl"



.type SIToFPInstruction <: symbol
.decl sitofp_instr(instr:SIToFPInstruction)

instr(v) :- sitofp_instr(v).

.decl sitofp_instr_from_operand(instr:SIToFPInstruction, val:Operand)
.decl sitofp_instr_to_type(instr:SIToFPInstruction, type:Type)




.decl sitofp_instr_from_type(instr:SIToFPInstruction, type:Type)

sitofp_instr_from_type(Instr, Type) :-
   sitofp_instr_from_operand(Instr, Operand),
   operand_has_type(Operand, Type).
#line 34 "sitofp-instr.dl"
schema_invalid_instr(Instr,  "sitofp-instr.dl" ,  34 ) :-
   schema_sanity(),
   sitofp_instr(Instr),
   !sitofp_instr_from_operand(Instr, _).

schema_invalid_instr(Instr,  "sitofp-instr.dl" ,  39 ) :-
   schema_sanity(),
   sitofp_instr(Instr),
   !sitofp_instr_to_type(Instr, _).

schema_invalid_instr(Instr,  "sitofp-instr.dl" ,  44 ) :-
   schema_sanity(),
   sitofp_instr(Instr),
   sitofp_instr_to_type(Instr, Type),
   !instr_returns_type(Instr, Type).

schema_invalid_instr(Instr,  "sitofp-instr.dl" ,  50 ) :-
   schema_sanity(),
   sitofp_instr(Instr),
   sitofp_instr_from_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "sitofp-instr.dl" ,  57 ) :-
   schema_sanity(),
   sitofp_instr(Instr),
   sitofp_instr_to_type(Instr, Type),
   !fp_type(Type),
   !fp_vector_type(Type).

schema_invalid_instr(Instr,  "sitofp-instr.dl" ,  64 ) :-
   schema_sanity(),
   sitofp_instr(Instr),
   sitofp_instr_from_type(Instr, FromType),
   sitofp_instr_to_type(Instr, ToType),
   !vector_compatible_types(FromType, ToType).
#line 43 "schema/schema.project"
#line 1 "uitofp-instr.dl"



.type UIToFPInstruction <: symbol
.decl uitofp_instr(instr:UIToFPInstruction)

instr(v) :- uitofp_instr(v).

.decl uitofp_instr_from_operand(instr:UIToFPInstruction, val:Operand)
.decl uitofp_instr_to_type(instr:UIToFPInstruction, type:Type)




.decl uitofp_instr_from_type(instr:UIToFPInstruction, type:Type)

uitofp_instr_from_type(Instr, Type) :-
   uitofp_instr_from_operand(Instr, Operand),
   operand_has_type(Operand, Type).
#line 34 "uitofp-instr.dl"
schema_invalid_instr(Instr,  "uitofp-instr.dl" ,  34 ) :-
   schema_sanity(),
   uitofp_instr(Instr),
   !uitofp_instr_from_operand(Instr, _).

schema_invalid_instr(Instr,  "uitofp-instr.dl" ,  39 ) :-
   schema_sanity(),
   uitofp_instr(Instr),
   !uitofp_instr_to_type(Instr, _).

schema_invalid_instr(Instr,  "uitofp-instr.dl" ,  44 ) :-
   schema_sanity(),
   uitofp_instr(Instr),
   uitofp_instr_to_type(Instr, Type),
   !instr_returns_type(Instr, Type).

schema_invalid_instr(Instr,  "uitofp-instr.dl" ,  50 ) :-
   schema_sanity(),
   uitofp_instr(Instr),
   uitofp_instr_from_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "uitofp-instr.dl" ,  57 ) :-
   schema_sanity(),
   uitofp_instr(Instr),
   uitofp_instr_to_type(Instr, Type),
   !fp_type(Type),
   !fp_vector_type(Type).

schema_invalid_instr(Instr,  "uitofp-instr.dl" ,  64 ) :-
   schema_sanity(),
   uitofp_instr(Instr),
   uitofp_instr_from_type(Instr, FromType),
   uitofp_instr_to_type(Instr, ToType),
   !vector_compatible_types(FromType, ToType).
#line 44 "schema/schema.project"
#line 1 "trunc-instr.dl"



.type TruncInstruction <: symbol
.decl trunc_instr(instr:TruncInstruction)

instr(v) :- trunc_instr(v).

.decl trunc_instr_from_operand(instr:TruncInstruction, val:Operand)
.decl trunc_instr_to_type(instr:TruncInstruction, type:Type)




.decl trunc_instr_from_type(instr:TruncInstruction, type:Type)

trunc_instr_from_type(Instr, Type) :-
   trunc_instr_from_operand(Instr, Operand),
   operand_has_type(Operand, Type).
#line 36 "trunc-instr.dl"
schema_invalid_instr(Instr,  "trunc-instr.dl" ,  36 ) :-
   schema_sanity(),
   trunc_instr(Instr),
   !trunc_instr_from_operand(Instr, _).

schema_invalid_instr(Instr,  "trunc-instr.dl" ,  41 ) :-
   schema_sanity(),
   trunc_instr(Instr),
   !trunc_instr_to_type(Instr, _).

schema_invalid_instr(Instr,  "trunc-instr.dl" ,  46 ) :-
   schema_sanity(),
   trunc_instr(Instr),
   trunc_instr_to_type(Instr, Type),
   !instr_returns_type(Instr, Type).

schema_invalid_instr(Instr,  "trunc-instr.dl" ,  52 ) :-
   schema_sanity(),
   trunc_instr(Instr),
   trunc_instr_from_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "trunc-instr.dl" ,  59 ) :-
   schema_sanity(),
   trunc_instr(Instr),
   trunc_instr_to_type(Instr, Type),
   !integer_type(Type),
   !integer_vector_type(Type).

schema_invalid_instr(Instr,  "trunc-instr.dl" ,  66 ) :-
   schema_sanity(),
   trunc_instr(Instr),
   trunc_instr_from_type(Instr, FromType),
   trunc_instr_to_type(Instr, ToType),
   !vector_compatible_types(FromType, ToType).
#line 45 "schema/schema.project"
#line 1 "fptrunc-instr.dl"



.type FPTruncInstruction <: symbol
.decl fptrunc_instr(instr:FPTruncInstruction)

instr(v) :- fptrunc_instr(v).

.decl fptrunc_instr_from_operand(instr:FPTruncInstruction, val:Operand)
.decl fptrunc_instr_to_type(instr:FPTruncInstruction, type:FPType)




.decl fptrunc_instr_from_type(instr:FPTruncInstruction, type:Type)

fptrunc_instr_from_type(Instr, Type) :-
   fptrunc_instr_from_operand(Instr, Operand),
   operand_has_type(Operand, Type).
#line 33 "fptrunc-instr.dl"
schema_invalid_instr(Instr,  "fptrunc-instr.dl" ,  33 ) :-
   schema_sanity(),
   fptrunc_instr(Instr),
   !fptrunc_instr_from_operand(Instr, _).

schema_invalid_instr(Instr,  "fptrunc-instr.dl" ,  38 ) :-
   schema_sanity(),
   fptrunc_instr(Instr),
   !fptrunc_instr_to_type(Instr, _).

schema_invalid_instr(Instr,  "fptrunc-instr.dl" ,  43 ) :-
   schema_sanity(),
   fptrunc_instr(Instr),
   fptrunc_instr_to_type(Instr, Type),
   !instr_returns_type(Instr, Type).

schema_invalid_instr(Instr,  "fptrunc-instr.dl" ,  49 ) :-
   schema_sanity(),
   fptrunc_instr(Instr),
   fptrunc_instr_from_type(Instr, Type),
   !fp_type(Type).
#line 46 "schema/schema.project"
#line 1 "br-instr.dl"



.type BrInstruction
  = BrCondInstruction
  | BrUncondInstruction

.type BrCondInstruction <: symbol
.type BrUncondInstruction <: symbol

.decl br_instr(instr:BrInstruction)
.decl br_instr_cond(instr:BrCondInstruction)
.decl br_instr_uncond(instr:BrUncondInstruction)


instr(v) :- br_instr(v).
terminator_instr(v) :- br_instr(v).
br_instr(v) :- br_instr_cond(v).
br_instr(v) :- br_instr_uncond(v).






.decl br_instr_condition(instr:Instruction, cond:Operand)
.decl br_instr_true_label(instr:Instruction, label:Variable)
.decl br_instr_false_label(instr:Instruction, label:Variable)






.decl br_instr_uncond_label(instr:Instruction, label:Variable)
#line 49 "br-instr.dl"
schema_invalid_instr(Instr,  "br-instr.dl" ,  49 ) :-
   schema_sanity(),
   br_instr_cond(Instr),
   !br_instr_condition(Instr, _).

schema_invalid_instr(Instr,  "br-instr.dl" ,  54 ) :-
   schema_sanity(),
   br_instr_cond(Instr),
   br_instr_condition(Instr, Cond),
   operand_has_type(Cond, CondType),
   !int1_type(CondType).

schema_invalid_instr(Instr,  "br-instr.dl" ,  61 ) :-
   schema_sanity(),
   br_instr_cond(Instr),
   !br_instr_true_label(Instr, _).

schema_invalid_instr(Instr,  "br-instr.dl" ,  66 ) :-
   schema_sanity(),
   br_instr_cond(Instr),
   !br_instr_false_label(Instr, _).

schema_invalid_instr(Instr,  "br-instr.dl" ,  71 ) :-
   schema_sanity(),
   br_instr_cond(Instr),
   br_instr_true_label(Instr, Label),
   !variable_is_label(Label).

schema_invalid_instr(Instr,  "br-instr.dl" ,  77 ) :-
   schema_sanity(),
   br_instr_cond(Instr),
   br_instr_false_label(Instr, Label),
   !variable_is_label(Label).

schema_invalid_instr(Instr,  "br-instr.dl" ,  83 ) :-
   schema_sanity(),
   br_instr_uncond(Instr),
   !br_instr_uncond_label(Instr, _).

schema_invalid_instr(Instr,  "br-instr.dl" ,  88 ) :-
   schema_sanity(),
   br_instr_uncond(Instr),
   br_instr_uncond_label(Instr, Label),
   !variable_is_label(Label).
#line 47 "schema/schema.project"
#line 1 "indirectbr-instr.dl"



.type IndirectBrInstruction <: symbol
.decl indirectbr_instr(instr:IndirectBrInstruction)

instr(v) :- indirectbr_instr(v).
terminator_instr(v) :- indirectbr_instr(v).



.decl indirectbr_instr_address(instr:Instruction, address:Operand)







.decl indirectbr_instr_label(instr:Instruction, index:number, label:Variable)
.decl indirectbr_instr_nlabels(instr:Instruction, total:number)
#line 34 "indirectbr-instr.dl"
schema_invalid_instr(Instr,  "indirectbr-instr.dl" ,  34 ) :-
   schema_sanity(),
   indirectbr_instr(Instr),
   !indirectbr_instr_address(Instr, _).

schema_invalid_instr(Instr,  "indirectbr-instr.dl" ,  39 ) :-
   schema_sanity(),
   indirectbr_instr(Instr),
   !indirectbr_instr_nlabels(Instr, _).

schema_invalid_instr(Instr,  "indirectbr-instr.dl" ,  44 ) :-
   schema_sanity(),
   indirectbr_instr(Instr),
   indirectbr_instr_label(Instr, _, Label),
   !variable_is_label(Label).

schema_invalid_instr(Instr,  "indirectbr-instr.dl" ,  50 ) :-
   schema_sanity(),
   indirectbr_instr(Instr),
   indirectbr_instr_label(Instr, Index, _),
   Index < 0.

schema_invalid_instr(Instr,  "indirectbr-instr.dl" ,  56 ) :-
   schema_sanity(),
   indirectbr_instr(Instr),
   indirectbr_instr_label(Instr, Index, _),
   indirectbr_instr_nlabels(Instr, Total),
   Index >= Total.

schema_invalid_instr(Instr,  "indirectbr-instr.dl" ,  63 ) :-
   schema_sanity(),
   indirectbr_instr(Instr),
   indirectbr_instr_address(Instr, Address),
   operand_has_type(Address, Type),
   !int8_type(Type).
#line 48 "schema/schema.project"
#line 1 "phi-instr.dl"



.type PhiInstruction <: symbol
.decl phi_instr(instr:PhiInstruction)

instr(v) :- phi_instr(v).

.decl phi_instr_type(instr:PhiInstruction, type:Type)
.decl phi_instr_npairs(instr:PhiInstruction, total:number)
.decl phi_instr_pair(instr:PhiInstruction, index:number, value:Operand, label:Variable)

.decl phi_instr_pair_label(v0:symbol, v1:number, v2:symbol)
.decl phi_instr_pair_value(v0:symbol, v1:number, v2:symbol)
phi_instr_pair(v0, v1, v2, v3) :-
   phi_instr_pair_value(v0, v1, v2),
   phi_instr(v0),
   operand(v2),
   phi_instr_pair_label(v0, v1, v3),
   variable(v3).
#line 32 "phi-instr.dl"
schema_invalid_instr(Instr,  "phi-instr.dl" ,  32 ) :-
   schema_sanity(),
   phi_instr(Instr),
   !phi_instr_npairs(Instr, _).

schema_invalid_instr(Instr,  "phi-instr.dl" ,  37 ) :-
   schema_sanity(),
   phi_instr(Instr),
   phi_instr_type(Instr, Type),
   !instr_returns_type(Instr, Type).

schema_invalid_instr(Instr,  "phi-instr.dl" ,  43 ) :-
   schema_sanity(),
   phi_instr(Instr),
   phi_instr_pair(Instr, _, Value, Label),
   operand(Value),
   !variable_is_label(Label).

schema_invalid_instr(Instr,  "phi-instr.dl" ,  50 ) :-
   schema_sanity(),
   phi_instr(Instr),
   phi_instr_pair(Instr, _, Value, Label),
   variable(Label),
   !operand_is_firstclass(Value).

schema_invalid_instr(Instr,  "phi-instr.dl" ,  57 ) :-
   schema_sanity(),
   phi_instr_type(Instr, Type),
   phi_instr_pair(Instr, _, Value, Label),
   operand(Value),
   variable(Label),
   !operand_has_type(Value, Type).

schema_invalid_instr(Instr,  "phi-instr.dl" ,  65 ) :-
   schema_sanity(),
   phi_instr_pair(Instr, Index, _, _),
   Index < 0.

schema_invalid_instr(Instr,  "phi-instr.dl" ,  70 ) :-
   schema_sanity(),
   phi_instr_npairs(Instr, Total),
   phi_instr_pair(Instr, Index, _, _),
   Index >= Total.
#line 49 "schema/schema.project"
#line 1 "switch-instr.dl"



.type SwitchInstruction <: symbol
.decl switch_instr(instr:SwitchInstruction)

instr(v) :- switch_instr(v).
terminator_instr(v) :- switch_instr(v).

.decl switch_instr_operand(instr:SwitchInstruction, value:Operand)
.decl switch_instr_ncases(instr:SwitchInstruction, total:number)
.decl switch_instr_case(instr:SwitchInstruction, index:number, constant:Constant, label:Variable)
.decl switch_instr_default_label(instr:SwitchInstruction, label:Variable)

.decl switch_instr_case_label(v0:symbol, v1:number, v2:symbol)
.decl switch_instr_case_value(v0:symbol, v1:number, v2:symbol)
switch_instr_case(v0, v1, v2, v3) :-
   switch_instr_case_value(v0, v1, v2),
   switch_instr(v0),
   constant(v2),
   switch_instr_case_label(v0, v1, v3),
   variable(v3).
#line 37 "switch-instr.dl"
schema_invalid_instr(Instr,  "switch-instr.dl" ,  37 ) :-
   schema_sanity(),
   switch_instr(Instr),
   !switch_instr_ncases(Instr, _).

schema_invalid_instr(Instr,  "switch-instr.dl" ,  42 ) :-
   schema_sanity(),
   switch_instr(Instr),
   !switch_instr_default_label(Instr, _).

schema_invalid_instr(Instr,  "switch-instr.dl" ,  47 ) :-
   schema_sanity(),
   switch_instr(Instr),
   switch_instr_default_label(Instr, Label),
   !variable_is_label(Label).

schema_invalid_instr(Instr,  "switch-instr.dl" ,  53 ) :-
   schema_sanity(),
   switch_instr(Instr),
   switch_instr_operand(Instr, Value),
   operand_has_type(Value, Type),
   !integer_type(Type).

schema_invalid_instr(Instr,  "switch-instr.dl" ,  60 ) :-
   schema_sanity(),
   switch_instr(Instr),
   switch_instr_case(Instr, _, Constant, Label),
   constant(Constant),
   !variable_is_label(Label).

schema_invalid_instr(Instr,  "switch-instr.dl" ,  67 ) :-
   schema_sanity(),
   switch_instr(Instr),
   switch_instr_case(Instr, _, Constant, Label),
   variable(Label),
   constant_has_type(Constant, Type),
   !integer_type(Type).

schema_invalid_instr(Instr,  "switch-instr.dl" ,  75 ) :-
   schema_sanity(),
   switch_instr(Instr),
   switch_instr_case(Instr, Index1, Constant1, Label1),
   switch_instr_case(Instr, Index2, Constant2, Label2),
   Index1 != Index2,
   variable(Label1),
   variable(Label2),
   (constant_has_value(Constant1, CCLYZER_SOME_MACRO_VALUE__), constant_has_value(Constant2, CCLYZER_SOME_MACRO_VALUE__)) .

schema_invalid_instr(Instr,  "switch-instr.dl" ,  85 ) :-
   schema_sanity(),
   switch_instr_case(Instr, Index, _, _),
   Index < 0.

schema_invalid_instr(Instr,  "switch-instr.dl" ,  90 ) :-
   schema_sanity(),
   switch_instr_ncases(Instr, Total),
   switch_instr_case(Instr, Index, _, _),
   Index >= Total.
#line 50 "schema/schema.project"
#line 1 "select-instr.dl"



.type SelectInstruction <: symbol
.decl select_instr(instr:SelectInstruction)

instr(v) :- select_instr(v).





.decl select_instr_condition(instr:SelectInstruction, condition:Operand)
.decl select_instr_first_operand(instr:SelectInstruction, op:Operand)
.decl select_instr_second_operand(instr:SelectInstruction, op:Operand)
#line 35 "select-instr.dl"
schema_invalid_instr(Instr,  "select-instr.dl" ,  35 ) :-
   schema_sanity(),
   select_instr(Instr),
   !select_instr_condition(Instr, _).

schema_invalid_instr(Instr,  "select-instr.dl" ,  40 ) :-
   schema_sanity(),
   select_instr(Instr),
   !select_instr_first_operand(Instr, _).

schema_invalid_instr(Instr,  "select-instr.dl" ,  45 ) :-
   schema_sanity(),
   select_instr(Instr),
   !select_instr_second_operand(Instr, _).

schema_invalid_instr(Instr,  "select-instr.dl" ,  50 ) :-
   schema_sanity(),
   select_instr_condition(Instr, Cond),
   operand_has_type(Cond, CondType),
   !boolean_type(CondType),
   !boolean_vector_type(CondType).


schema_invalid_instr(Instr,  "select-instr.dl" ,  58 ) :-
   schema_sanity(),
   select_instr(Instr),
   instr_returns_type(Instr, Type),
   !type_is_firstclass(Type).

schema_invalid_instr(Instr,  "select-instr.dl" ,  64 ) :-
   schema_sanity(),
   select_instr_first_operand(Instr, LeftOp),
   instr_returns_type(Instr, Type),
   !operand_has_type(LeftOp, Type).

schema_invalid_instr(Instr,  "select-instr.dl" ,  70 ) :-
   schema_sanity(),
   select_instr_second_operand(Instr, RightOp),
   instr_returns_type(Instr, Type),
   !operand_has_type(RightOp, Type).



schema_invalid_instr(Instr,  "select-instr.dl" ,  78 ) :-
   schema_sanity(),
   select_instr(Instr),
   select_instr_condition(Instr, Cond),
   instr_returns_type(Instr, Type),
   operand_has_type(Cond, CondType),
   !vector_compatible_types(CondType, Type).
#line 51 "schema/schema.project"
#line 1 "alloca-instr.dl"



.type AllocaInstruction <: symbol
.decl alloca_instr(instr:AllocaInstruction)

instr(v) :- alloca_instr(v).

.decl alloca_instr_alignment(instr:AllocaInstruction, alignment:number)
.decl alloca_instr_size(instr:AllocaInstruction, size:Operand)
.decl alloca_instr_type(instr:AllocaInstruction, type:Type)








schema_invalid_instr(Instr,  "alloca-instr.dl" ,  20 ) :-
   schema_sanity(),
   alloca_instr(Instr),
   !alloca_instr_type(Instr, _).

schema_invalid_instr(Instr,  "alloca-instr.dl" ,  25 ) :-
   schema_sanity(),
   alloca_instr(Instr),
   alloca_instr_type(Instr, Type),
   instr_returns_type(Instr, PtrType),
   !pointer_type_has_component(PtrType, Type).
#line 52 "schema/schema.project"
#line 1 "load-instr.dl"



.type LoadInstruction <: symbol
.decl load_instr(instr:LoadInstruction)

instr(v) :- load_instr(v).

.decl load_instr_alignment(instr:LoadInstruction, alignment:number)
.decl load_instr_ordering(instr:LoadInstruction, ordering:Ordering)





.decl load_instr_is_volatile(instr:LoadInstruction)





.decl load_instr_is_atomic(instr:LoadInstruction)

load_instr_is_atomic(Instr) :-
   load_instr_ordering(Instr, _).





.decl load_instr_address(instr:LoadInstruction, pointer:Operand)




.decl load_instr_address_ptr_type(instr:LoadInstruction, type:Type)

load_instr_address_ptr_type(Instr, PtrType) :-
   load_instr_address(Instr, PtrAddress),
   operand_has_type(PtrAddress, PtrType).










schema_invalid_instr(Instr,  "load-instr.dl" ,  51 ) :-
   schema_sanity(),
   load_instr(Instr),
   !load_instr_address(Instr, _).

schema_invalid_instr(Instr,  "load-instr.dl" ,  56 ) :-
   schema_sanity(),
   load_instr(Instr),
   load_instr_address_ptr_type(Instr, PtrType),
   !pointer_type_to_firstclass(PtrType).

schema_invalid_instr(Instr,  "load-instr.dl" ,  62 ) :-
   schema_sanity(),
   load_instr(Instr),
   load_instr_address_ptr_type(Instr, PtrType),
   pointer_type_has_component(PtrType, CompType),
   !instr_returns_type(Instr, CompType).

schema_invalid_instr(Instr,  "load-instr.dl" ,  69 ) :-
   schema_sanity(),
   load_instr(Instr),
   load_instr_ordering(Instr, Ord),
   ( release_ordering(Ord)
   ; acq_rel_ordering(Ord) ).
#line 53 "schema/schema.project"
#line 1 "store-instr.dl"



.type StoreInstruction <: symbol
.decl store_instr(instr:StoreInstruction)

instr(v) :- store_instr(v).

.decl store_instr_alignment(instr:StoreInstruction, alignment:number)
.decl store_instr_ordering(instr:StoreInstruction, ordering:Ordering)





.decl store_instr_is_volatile(instr:StoreInstruction)





.decl store_instr_is_atomic(instr:StoreInstruction)

store_instr_is_atomic(Instr) :-
   store_instr_ordering(Instr, _).






.decl store_instr_value(instr:StoreInstruction, value:Operand)
.decl store_instr_address(instr:StoreInstruction, pointer:Operand)




.decl store_instr_address_ptr_type(instr:StoreInstruction, type:Type)
.decl store_instr_value_type(instr:StoreInstruction, type:Type)

store_instr_address_ptr_type(Instr, PtrType) :-
   store_instr_address(Instr, PtrAddress),
   operand_has_type(PtrAddress, PtrType).

store_instr_value_type(Instr, PtrType) :-
   store_instr_value(Instr, PtrAddress),
   operand_has_type(PtrAddress, PtrType).
#line 60 "store-instr.dl"
schema_invalid_instr(Instr,  "store-instr.dl" ,  60 ) :-
   schema_sanity(),
   store_instr(Instr),
   !store_instr_address(Instr, _).

schema_invalid_instr(Instr,  "store-instr.dl" ,  65 ) :-
   schema_sanity(),
   store_instr(Instr),
   !store_instr_value(Instr, _).

schema_invalid_instr(Instr,  "store-instr.dl" ,  70 ) :-
   schema_sanity(),
   store_instr(Instr),
   instr_assigns_to(Instr, _).

schema_invalid_instr(Instr,  "store-instr.dl" ,  75 ) :-
   schema_sanity(),
   store_instr(Instr),
   store_instr_address_ptr_type(Instr, PtrType),
   !pointer_type_to_firstclass(PtrType).

schema_invalid_instr(Instr,  "store-instr.dl" ,  81 ) :-
   schema_sanity(),
   store_instr(Instr),
   store_instr_address_ptr_type(Instr, PtrType),
   store_instr_value_type(Instr, Type),
   !pointer_type_has_component(PtrType, Type).

schema_invalid_instr(Instr,  "store-instr.dl" ,  88 ) :-
   schema_sanity(),
   store_instr(Instr),
   store_instr_ordering(Instr, Ord),
   ( acquire_ordering(Ord)
   ; acq_rel_ordering(Ord) ).
#line 54 "schema/schema.project"
#line 1 "atomicrmw-instr.dl"



.type AtomicRMWInstruction <: symbol
.decl atomicrmw_instr(instr:AtomicRMWInstruction)

instr(v) :- atomicrmw_instr(v).

.decl atomicrmw_instr_ordering(instr:AtomicRMWInstruction, ordering:Ordering)






.decl atomicrmw_instr_is_volatile(instr:AtomicRMWInstruction)







.decl atomicrmw_instr_operation(instr:AtomicRMWInstruction, op:AtomicOperation)
.decl atomicrmw_instr_address(instr:AtomicRMWInstruction, ptr:Operand)
.decl atomicrmw_instr_value(instr:AtomicRMWInstruction, value:Operand)









.type AtomicOperation <: symbol
.decl atomic_operation(op:AtomicOperation)

atomic_operation(op) :- atomicrmw_instr_operation(_, op).

.decl atomic_operation_xchg(op:AtomicOperation)
.decl atomic_operation_add(op:AtomicOperation)
.decl atomic_operation_sub(op:AtomicOperation)
.decl atomic_operation_and(op:AtomicOperation)
.decl atomic_operation_nand(op:AtomicOperation)
.decl atomic_operation_nor(op:AtomicOperation)
.decl atomic_operation_or(op:AtomicOperation)
.decl atomic_operation_xor(op:AtomicOperation)
.decl atomic_operation_max(op:AtomicOperation)
.decl atomic_operation_min(op:AtomicOperation)
.decl atomic_operation_umax(op:AtomicOperation)
.decl atomic_operation_umin(op:AtomicOperation)

atomic_operation("xchg"). atomic_operation_xchg("xchg").
atomic_operation("add"). atomic_operation_add("add").
atomic_operation("sub"). atomic_operation_sub("sub").
atomic_operation("and"). atomic_operation_and("and").
atomic_operation("nand"). atomic_operation_nand("nand").
atomic_operation("nor"). atomic_operation_nor("nor").
atomic_operation("or"). atomic_operation_or("or").
atomic_operation("xor"). atomic_operation_xor("xor").
atomic_operation("max"). atomic_operation_max("max").
atomic_operation("min"). atomic_operation_min("min").
atomic_operation("umax"). atomic_operation_umax("umax").
atomic_operation("umin"). atomic_operation_umin("umin").

schema_invalid_instr(Instr,  "atomicrmw-instr.dl" ,  67 ) :-
   schema_sanity(),
   atomicrmw_instr_operation(Instr, Operation),
   !atomic_operation_add(Operation), !atomic_operation_sub(Operation),
   !atomic_operation_and(Operation), !atomic_operation_or(Operation),
   !atomic_operation_nand(Operation), !atomic_operation_nor(Operation),
   !atomic_operation_xor(Operation), !atomic_operation_xchg(Operation),
   !atomic_operation_max(Operation), !atomic_operation_min(Operation),
   !atomic_operation_umax(Operation), !atomic_operation_umin(Operation).









schema_invalid_instr(Instr,  "atomicrmw-instr.dl" ,  85 ) :-
   schema_sanity(),
   atomicrmw_instr(Instr),
   !atomicrmw_instr_ordering(Instr, _).

schema_invalid_instr(Instr,  "atomicrmw-instr.dl" ,  90 ) :-
   schema_sanity(),
   atomicrmw_instr(Instr),
   !atomicrmw_instr_operation(Instr, _).

schema_invalid_instr(Instr,  "atomicrmw-instr.dl" ,  95 ) :-
   schema_sanity(),
   atomicrmw_instr(Instr),
   !atomicrmw_instr_address(Instr, _).

schema_invalid_instr(Instr,  "atomicrmw-instr.dl" ,  100 ) :-
   schema_sanity(),
   atomicrmw_instr(Instr),
   !atomicrmw_instr_value(Instr, _).

schema_invalid_instr(Instr,  "atomicrmw-instr.dl" ,  105 ) :-
   schema_sanity(),
   atomicrmw_instr_value(Instr, Value),
   operand_has_type(Value, Type),
   !integer_type(Type).

schema_invalid_instr(Instr,  "atomicrmw-instr.dl" ,  111 ) :-
   schema_sanity(),
   atomicrmw_instr_address(Instr, AddressPtr),
   operand_has_type(AddressPtr, PtrType),
   !pointer_type(PtrType).

schema_invalid_instr(Instr,  "atomicrmw-instr.dl" ,  117 ) :-
   schema_sanity(),
   atomicrmw_instr_address(Instr, AddressPtr),
   atomicrmw_instr_value(Instr, Value),
   operand_has_type(AddressPtr, PtrType),
   operand_has_type(Value, ValueType),
   !pointer_type_has_component(PtrType, ValueType).
#line 55 "schema/schema.project"
#line 1 "cmpxchg-instr.dl"
#line 13 "cmpxchg-instr.dl"
.type CmpXchgInstruction <: symbol
.decl cmpxchg_instr(instr:CmpXchgInstruction)

instr(v) :- cmpxchg_instr(v).

.decl cmpxchg_instr_ordering(instr:CmpXchgInstruction, ordering:Ordering)






.decl cmpxchg_instr_is_volatile(instr:CmpXchgInstruction)









.decl cmpxchg_instr_address(instr:CmpXchgInstruction, ptr:Operand)
.decl cmpxchg_instr_cmp_value(instr:CmpXchgInstruction, val:Operand)
.decl cmpxchg_instr_new_value(instr:CmpXchgInstruction, val:Operand)




.decl cmpxchg_instr_type(instr:CmpXchgInstruction, type:Type)

.decl cmpxchg_instr_cmp_value_type(instr:CmpXchgInstruction, type:Type)

cmpxchg_instr_cmp_value_type(Instr, Type) :-
   cmpxchg_instr_cmp_value(Instr, Value),
   operand_has_type(Value, Type).
#line 65 "cmpxchg-instr.dl"
schema_invalid_instr(Instr,  "cmpxchg-instr.dl" ,  65 ) :-
   schema_sanity(),
   cmpxchg_instr(Instr),
   !cmpxchg_instr_ordering(Instr, _).

schema_invalid_instr(Instr,  "cmpxchg-instr.dl" ,  70 ) :-
   schema_sanity(),
   cmpxchg_instr(Instr),
   !cmpxchg_instr_address(Instr, _).

schema_invalid_instr(Instr,  "cmpxchg-instr.dl" ,  75 ) :-
   schema_sanity(),
   cmpxchg_instr(Instr),
   !cmpxchg_instr_cmp_value(Instr, _).

schema_invalid_instr(Instr,  "cmpxchg-instr.dl" ,  80 ) :-
   schema_sanity(),
   cmpxchg_instr(Instr),
   !cmpxchg_instr_new_value(Instr, _).




schema_invalid_instr(Instr,  "cmpxchg-instr.dl" ,  88 ) :-
   schema_sanity(),
   cmpxchg_instr_cmp_value_type(Instr, Type),
   !integer_type(Type),
   !pointer_type(Type).




schema_invalid_instr(Instr,  "cmpxchg-instr.dl" ,  97 ) :-
   schema_sanity(),
   cmpxchg_instr_cmp_value(Instr, CmpValue),
   cmpxchg_instr_new_value(Instr, NewValue),
   operand_has_type(CmpValue, CmpType),
   operand_has_type(NewValue, NewType),
   CmpType != NewType.




schema_invalid_instr(Instr,  "cmpxchg-instr.dl" ,  108 ) :-
   schema_sanity(),
   cmpxchg_instr_address(Instr, AddressPtr),
   cmpxchg_instr_cmp_value_type(Instr, Type),
   operand_has_type(AddressPtr, PtrType),
   !pointer_type_has_component(PtrType, Type).




schema_invalid_instr(Instr,  "cmpxchg-instr.dl" ,  118 ) :-
   schema_sanity(),
   cmpxchg_instr(Instr),
   instr_returns_type(Instr, RetType),
   !struct_type_nfields(RetType, 2).

schema_invalid_instr(Instr,  "cmpxchg-instr.dl" ,  124 ) :-
   schema_sanity(),
   cmpxchg_instr_cmp_value_type(Instr, Type),
   instr_returns_type(Instr, RetType),
   !struct_type_field(RetType, 0, Type).

schema_invalid_instr(Instr,  "cmpxchg-instr.dl" ,  130 ) :-
   schema_sanity(),
   cmpxchg_instr(Instr),
   instr_returns_type(Instr, RetType),
   struct_type_field(RetType, 1, FlagType),
   !int1_type(FlagType).
#line 56 "schema/schema.project"
#line 1 "ret-instr.dl"



.type RetInstruction <: symbol
.decl ret_instr(instr:RetInstruction)

instr(v) :- ret_instr(v).
terminator_instr(v) :- ret_instr(v).




.decl ret_instr_operand(instr:RetInstruction, val:Operand)
.decl ret_instr_void_(instr:RetInstruction)

schema_invalid_instr(Instr,  "ret-instr.dl" ,  16 ) :-
   schema_sanity(),
   ret_instr_void_(Instr),
   ret_instr_operand(Instr, _).
#line 35 "ret-instr.dl"
.decl func_is_wellformed(func:Function)
.decl func_is_illformed(func:Function)

func_is_wellformed(Func):-
   func(Func),
   !func_is_illformed(Func).

func_is_illformed(Func) :-
   ret_instr_void_(Instr),
   instr_func(Instr, Func),
   func_ty(Func, FuncType),
   func_type_return(FuncType, RetType),
   !void_type(RetType).

func_is_illformed(Func) :-
   ret_instr_operand(Instr, Value),
   instr_func(Instr, Func),
   func_ty(Func, FuncType),
   func_type_return(FuncType, RetType),
   !void_type(RetType),
   !operand_has_type(Value, RetType).

func_is_illformed(Func) :-
   ret_instr(Instr),
   !ret_instr_void_(Instr),
   instr_func(Instr, Func),
   func_ty(Func, FuncType),
   func_type_return(FuncType, RetType),
   void_type(RetType).








schema_invalid_instr(Instr,  "ret-instr.dl" ,  72 ) :-
   schema_sanity(),
   ret_instr_operand(Instr, Value),
   !operand_is_firstclass(Value).
#line 57 "schema/schema.project"
#line 1 "call-instr.dl"



.type CallInstruction <: symbol
.decl call_instr(instr:CallInstruction)

instr(v) :- call_instr(v).


.decl call_instr_func_operand(instr:CallInstruction, op:Operand)


.decl call_instr_fn_target(instr:CallInstruction, func:FunctionDecl)


.decl call_instr_tail_opt(instr:CallInstruction)




.decl call_instr_calling_conv(instr:CallInstruction, cc:CallingConvention)
calling_convention(cc) :- call_instr_calling_conv(_, cc).










.decl direct_call_instr(instr:CallInstruction)
.decl indirect_call_instr(instr:CallInstruction)
.decl asm_call_instr(instr:CallInstruction)

direct_call_instr(Instr) :-
   call_instr_func_operand(Instr, Constant),
   constant(Constant), !inline_asm(Constant).

indirect_call_instr(Instr) :-
   call_instr_func_operand(Instr, Variable),
   variable(Variable).

asm_call_instr(Instr) :-
   call_instr_func_operand(Instr, Constant),
   inline_asm(Constant).






.decl call_instr_arg(instr:CallInstruction, i:ArgumentIndex, arg:Operand)
.decl call_instr_return_attr(instr:CallInstruction, attr:Attribute)
.decl call_instr_param_attr(instr:CallInstruction, i:ArgumentIndex, attr:Attribute)
.decl call_instr_func_attr(instr:CallInstruction, attr:Attribute)

attr(Attr) :- call_instr_func_attr(_, Attr).
attr(Attr) :- call_instr_return_attr(_, Attr).
attr(Attr) :- call_instr_param_attr(_, _, Attr).






.decl call_instr_fn_type(instr:CallInstruction, type:Type)
.decl call_instr_return_type(instr:CallInstruction, type:Type)

call_instr_fn_type(Instr, FnType) :-
   call_instr_func_operand(Instr, FnOp),
   operand_has_type(FnOp, PtrType),
   pointer_type_has_component(PtrType, FnType),
   func_type(FnType).

call_instr_return_type(Instr, Type) :-
   call_instr_fn_type(Instr, FnType),
   func_type_return(FnType, Type).
#line 100 "call-instr.dl"
schema_invalid_instr(Instr,  "call-instr.dl" ,  100 ) :-
   schema_sanity(),
   call_instr(Instr),
   !call_instr_func_operand(Instr, _).

schema_invalid_instr(Instr,  "call-instr.dl" ,  105 ) :-
   schema_sanity(),
   call_instr(Instr),
   !call_instr_fn_type(Instr, _).


schema_invalid_instr(Instr,  "call-instr.dl" ,  111 ) :-
   schema_sanity(),
   call_instr_return_attr(Instr, Attr),
   !parameter_attr__zeroext(Attr),
   !parameter_attr__signext(Attr),
   !parameter_attr__inreg(Attr),
   !parameter_attr__noalias(Attr),
   !parameter_attr__dereferenceable(Attr).

schema_invalid_instr(Instr,  "call-instr.dl" ,  120 ) :-
   schema_sanity(),
   call_instr_func_attr(Instr, Attr),
   !func_func_attr__noreturn(Attr),
   !func_func_attr__nounwind(Attr),
   !func_func_attr__readonly(Attr),
   !func_func_attr__readnone(Attr),
   !func_func_attr__cold(Attr),
   !func_func_attr__returns_twice(Attr),
   !func_func_attr__builtin(Attr),
   !target_dependent_attr(Attr).
#line 145 "call-instr.dl"
schema_invalid_instr(Instr,  "call-instr.dl" ,  145 ) :-
   schema_sanity(),
   call_instr_arg(Instr, Index, _),
   call_instr_fn_type(Instr, FnType),
   !func_type_param(FnType, Index, _),
   !func_type_has_varargs(FnType).

schema_invalid_instr(Instr,  "call-instr.dl" ,  152 ) :-
   schema_sanity(),
   call_instr(Instr),
   !call_instr_arg(Instr, Index, _),
   call_instr_fn_type(Instr, FnType),
   func_type_param(FnType, Index, _).

schema_invalid_instr(Instr,  "call-instr.dl" ,  159 ) :-
   schema_sanity(),
   call_instr_arg(Instr, Index, Arg),
   call_instr_fn_type(Instr, FnType),
   func_type_param(FnType, Index, ParamType),
   !operand_has_type(Arg, ParamType).


schema_invalid_instr(Instr,  "call-instr.dl" ,  167 ) :-
   schema_sanity(),
   call_instr_return_type(Instr, Type),
   !void_type(Type),
   !instr_returns_type(Instr, Type).

schema_invalid_instr(Instr,  "call-instr.dl" ,  173 ) :-
   schema_sanity(),
   call_instr_return_type(Instr, Type),
   void_type(Type),
   instr_returns_type(Instr, _).


schema_invalid_instr(Instr,  "call-instr.dl" ,  180 ) :-
   schema_sanity(),
   call_instr_arg(Instr, _, Arg),
   !operand_is_firstclass(Arg).
#line 58 "schema/schema.project"
#line 1 "invoke-instr.dl"



.type InvokeInstruction <: symbol
.decl invoke_instr(instr:InvokeInstruction)

instr(v) :- invoke_instr(v).
terminator_instr(v) :- invoke_instr(v).


.decl invoke_instr_func_operand(instr:InvokeInstruction, op:Operand)


.decl invoke_instr_fn_target(instr:InvokeInstruction, func:FunctionDecl)



.decl invoke_instr_calling_conv(instr:InvokeInstruction, cc:CallingConvention)
calling_convention(cc) :- invoke_instr_calling_conv(_, cc).










.decl direct_invoke_instr(instr:InvokeInstruction)
.decl indirect_invoke_instr(instr:InvokeInstruction)

direct_invoke_instr(Instr) :-
   invoke_instr_func_operand(Instr, Constant),
   constant(Constant).

indirect_invoke_instr(Instr) :-
   invoke_instr_func_operand(Instr, Variable),
   variable(Variable).






.decl invoke_instr_arg(instr:InvokeInstruction, i:ArgumentIndex, arg:Operand)
.decl invoke_instr_return_attr(instr:InvokeInstruction, attr:Attribute)
.decl invoke_instr_param_attr(instr:InvokeInstruction, i:ArgumentIndex, attr:Attribute)
.decl invoke_instr_func_attr(instr:InvokeInstruction, attr:Attribute)

attr(Attr) :- invoke_instr_func_attr(_, Attr).
attr(Attr) :- invoke_instr_return_attr(_, Attr).
attr(Attr) :- invoke_instr_param_attr(_, _, Attr).






.decl invoke_instr_fn_type(instr:InvokeInstruction, type:Type)
.decl invoke_instr_return_type(instr:InvokeInstruction, type:Type)

invoke_instr_fn_type(Instr, FnType) :-
   invoke_instr_func_operand(Instr, FnOp),
   operand_has_type(FnOp, PtrType),
   pointer_type_has_component(PtrType, FnType),
   func_type(FnType).

invoke_instr_return_type(Instr, Type) :-
   invoke_instr_fn_type(Instr, FnType),
   func_type_return(FnType, Type).
#line 86 "invoke-instr.dl"
.decl invoke_instr_normal_label(instr:InvokeInstruction, label:Variable)
.decl invoke_instr_exception_label(instr:InvokeInstruction, label:Variable)
#line 108 "invoke-instr.dl"
schema_invalid_instr(Instr,  "invoke-instr.dl" ,  108 ) :-
   schema_sanity(),
   invoke_instr(Instr),
   !invoke_instr_func_operand(Instr, _).

schema_invalid_instr(Instr,  "invoke-instr.dl" ,  113 ) :-
   schema_sanity(),
   invoke_instr(Instr),
   !invoke_instr_normal_label(Instr, _).

schema_invalid_instr(Instr,  "invoke-instr.dl" ,  118 ) :-
   schema_sanity(),
   invoke_instr(Instr),
   !invoke_instr_exception_label(Instr, _).


schema_invalid_instr(Instr,  "invoke-instr.dl" ,  124 ) :-
   schema_sanity(),
   invoke_instr_return_attr(Instr, Attr),
   !parameter_attr__zeroext(Attr),
   !parameter_attr__signext(Attr),
   !parameter_attr__inreg(Attr),
   !parameter_attr__noalias(Attr),
   !parameter_attr__dereferenceable(Attr).

schema_invalid_instr(Instr,  "invoke-instr.dl" ,  133 ) :-
   schema_sanity(),
   invoke_instr_func_attr(Instr, Attr),
   !func_func_attr__noreturn(Attr),
   !func_func_attr__nounwind(Attr),
   !func_func_attr__readonly(Attr),
   !func_func_attr__readnone(Attr),
   !func_func_attr__cold(Attr),
   !func_func_attr__returns_twice(Attr),
   !func_func_attr__builtin(Attr),
   !target_dependent_attr(Attr).



schema_invalid_instr(Instr,  "invoke-instr.dl" ,  147 ) :-
   schema_sanity(),
   invoke_instr_arg(Instr, Index, _),
   invoke_instr_fn_type(Instr, FnType),
   !func_type_param(FnType, Index, _),
   !func_type_has_varargs(FnType).

schema_invalid_instr(Instr,  "invoke-instr.dl" ,  154 ) :-
   schema_sanity(),
   invoke_instr(Instr),
   !invoke_instr_arg(Instr, Index, _),
   invoke_instr_fn_type(Instr, FnType),
   func_type_param(FnType, Index, _).

schema_invalid_instr(Instr,  "invoke-instr.dl" ,  161 ) :-
   schema_sanity(),
   invoke_instr_arg(Instr, Index, Arg),
   invoke_instr_fn_type(Instr, FnType),
   func_type_param(FnType, Index, ParamType),
   !operand_has_type(Arg, ParamType).

schema_invalid_instr(Instr,  "invoke-instr.dl" ,  168 ) :-
   schema_sanity(),
   invoke_instr_return_type(Instr, Type),
   !void_type(Type),
   !instr_returns_type(Instr, Type).

schema_invalid_instr(Instr,  "invoke-instr.dl" ,  174 ) :-
   schema_sanity(),
   invoke_instr_return_type(Instr, Type),
   void_type(Type),
   instr_returns_type(Instr, _).


schema_invalid_instr(Instr,  "invoke-instr.dl" ,  181 ) :-
   schema_sanity(),
   invoke_instr_arg(Instr, _, Arg),
   !operand_is_firstclass(Arg).

schema_invalid_instr(Instr,  "invoke-instr.dl" ,  186 ) :-
   schema_sanity(),
   invoke_instr_normal_label(Instr, Label),
   !variable_is_label(Label).

schema_invalid_instr(Instr,  "invoke-instr.dl" ,  191 ) :-
   schema_sanity(),
   invoke_instr_exception_label(Instr, Label),
   !variable_is_label(Label).
#line 59 "schema/schema.project"
#line 1 "fence-instr.dl"



.type FenceInstruction <: symbol
.decl fence_instr(instr:FenceInstruction)

instr(v) :- fence_instr(v).

.decl fence_instr_ordering(instr:FenceInstruction, ordering:Ordering)









schema_invalid_instr(Instr,  "fence-instr.dl" ,  19 ) :-
   schema_sanity(),
   fence_instr(Instr),
   !fence_instr_ordering(Instr, _).

schema_invalid_instr(Instr,  "fence-instr.dl" ,  24 ) :-
   schema_sanity(),
   fence_instr(Instr),
   fence_instr_ordering(Instr, Ord),
   !acquire_ordering(Ord),
   !release_ordering(Ord),
   !acq_rel_ordering(Ord),
   !seq_cst_ordering(Ord).
#line 60 "schema/schema.project"
#line 1 "landingpad-instr.dl"



.type LandingPadInstruction <: symbol
.decl landingpad_instr(instr:LandingPadInstruction)
.decl landingpad_instr_is_cleanup(instr:LandingPadInstruction)

instr(v) :- landingpad_instr(v).


.decl landingpad_instr_type(instr:LandingPadInstruction, type:Type)


.decl landingpad_instr_pers_fn(instr:LandingPadInstruction, func:FunctionDecl)

landingpad_instr_pers_fn(Instr, PersFunction) :-
   landingpad_instr(Instr),
   instr_func(Instr, EnclosingFunction),
   func_pers_fn(EnclosingFunction, FnConstant),
   func_constant(FnConstant),
   func_constant_fn_name(FnConstant, PersFnName),
   func_name(PersFunction, PersFnName).

landingpad_instr_pers_fn(Instr, PersFunction) :-
   landingpad_instr(Instr),
   instr_func(Instr, EnclosingFunction),
   func_pers_fn(EnclosingFunction, BitcastConstant),
   bitcast_constant_expression_from(BitcastConstant, FnConstant),
   func_constant(FnConstant),
   func_constant_fn_name(FnConstant, PersFnName),
   func_name(PersFunction, PersFnName).
#line 57 "landingpad-instr.dl"
.decl landingpad(bb:BasicBlock)

landingpad(BB) :-
   invoke_instr_exception_label(_, Label),
   block_of_label(BB, Label).





.decl _landingpad_starting_phi(bb:BasicBlock, instr:PhiInstruction)

_landingpad_starting_phi(BB, Instr) :-
   landingpad(BB),
   block_first_instr(BB, Instr),
   phi_instr(Instr).

_landingpad_starting_phi(BB, NextInstr) :-
   _landingpad_starting_phi(BB, Instr),
   instr_successor(Instr, NextInstr),
   phi_instr(NextInstr),
   instr_block(NextInstr, BB).




.decl _landingpad_first_nonphi(bb:BasicBlock, instr:Instruction)

_landingpad_first_nonphi(BB, Instr) :-
   landingpad(BB),
   block_first_instr(BB, Instr),
   !phi_instr(Instr).

_landingpad_first_nonphi(BB, NextInstr) :-
   _landingpad_starting_phi(BB, Instr),
   instr_successor(Instr, NextInstr),
   !phi_instr(NextInstr),
   instr_block(NextInstr, BB).



.decl _landingpad_contains_landingpad_instr(bb:BasicBlock, instr:Instruction)

_landingpad_contains_landingpad_instr(BB, Instr) :-
   landingpad_instr(Instr),
   instr_block(Instr, BB),
   landingpad(BB).



.decl _valid_landingpad(bb:BasicBlock)

_valid_landingpad(BB) :-
   landingpad(BB),
   _landingpad_first_nonphi(BB, Instr),
   _landingpad_contains_landingpad_instr(BB, Instr).
#line 126 "landingpad-instr.dl"
.type Clause = Constant

.decl clause(c:Clause)
.decl catch_clause(c:Clause)
.decl filter_clause(c:Clause)

clause(c) :- catch_clause(c) ; filter_clause(c).


.decl landingpad_instr_clause(instr:LandingPadInstruction, i:number, clause:Clause)
.decl landingpad_instr_nclauses(instr:LandingPadInstruction, total:number)

.decl landingpad_instr_catch_clause(v0:LandingPadInstruction, v1:number, v2:Constant)
.decl landingpad_instr_filter_clause(v0:LandingPadInstruction, v1:number, v2:Constant)

catch_clause(v2), landingpad_instr_clause(v0, v1, v2) :-
   landingpad_instr_catch_clause(v0, v1, v2).

filter_clause(v2), landingpad_instr_clause(v0, v1, v2) :-
   landingpad_instr_filter_clause(v0, v1, v2).

.decl constant_in_func_name(v0:Constant, v1:FunctionName)
.decl variable_in_func_name(v0:Variable, v1:FunctionName)


schema_invalid_instr(Instr,  "landingpad-instr.dl" ,  151 ) :-
   schema_sanity(),
   landingpad_instr_clause(Instr, _, Clause),
   !catch_clause(Clause),
   !filter_clause(Clause).
#line 178 "landingpad-instr.dl"
schema_invalid_instr(Instr,  "landingpad-instr.dl" ,  178 ) :-
   schema_sanity(),
   landingpad_instr_clause(Instr, _, Clause),
   filter_clause(Clause),
   constant_has_type(Clause, Type),
   !array_type(Type).

schema_invalid_instr(Instr,  "landingpad-instr.dl" ,  185 ) :-
   schema_sanity(),
   landingpad_instr_type(Instr, Type),
   !instr_returns_type(Instr, Type).









schema_invalid_instr(Instr,  "landingpad-instr.dl" ,  198 ) :-
   schema_sanity(),
   landingpad(BB), !_valid_landingpad(BB),
   block_first_instr(BB, Instr).










schema_invalid_instr(Instr,  "landingpad-instr.dl" ,  212 ) :-
   schema_sanity(),
   landingpad_instr(Instr),
   instr_block(Instr, BB),
   !landingpad(BB).




schema_invalid_instr(Instr1,  "landingpad-instr.dl" ,  221 ) :-
   schema_sanity(),
   landingpad_instr(Instr1),
   landingpad_instr_pers_fn(Instr1, PersFunc),
   instr_func(Instr1, Func),
   instr_func(Instr2, Func),
   landingpad_instr(Instr2),
   !landingpad_instr_pers_fn(Instr2, PersFunc).




schema_invalid_instr(Instr,  "landingpad-instr.dl" ,  233 ) :-
   schema_sanity(),
   landingpad_instr(Instr),
   !landingpad_instr_is_cleanup(Instr),
   !landingpad_instr_clause(Instr, 0, _).
#line 61 "schema/schema.project"
#line 1 "resume-instr.dl"



.type ResumeInstruction <: symbol
.decl resume_instr(instr:ResumeInstruction)

instr(v) :- resume_instr(v).
terminator_instr(v) :- resume_instr(v).

.decl resume_instr_operand(instr:ResumeInstruction, op:Operand)










schema_invalid_instr(Instr,  "resume-instr.dl" ,  21 ) :-
   schema_sanity(),
   resume_instr(Instr),
   !resume_instr_operand(Instr, _).

schema_invalid_instr(ResumeInstr,  "resume-instr.dl" ,  26 ) :-
   schema_sanity(),
   resume_instr(ResumeInstr),
   resume_instr_operand(ResumeInstr, Operand),
   instr_func(ResumeInstr, Func),
   instr_func(LPadInstr, Func),
   landingpad_instr(LPadInstr),
   instr_returns_type(LPadInstr, Type),
   !operand_has_type(Operand, Type).
#line 62 "schema/schema.project"
#line 1 "extractelement-instr.dl"



.type ExtractElementInstruction <: symbol
.decl extractelement_instr(instr:ExtractElementInstruction)

instr(v) :- extractelement_instr(v).

.decl extractelement_instr_base(instr:ExtractElementInstruction, vector:Operand)
.decl extractelement_instr_index(instr:ExtractElementInstruction, index:Operand)
.decl extractelement_instr_type(instr:ExtractElementInstruction, type:Type)


extractelement_instr_type(Instr, Type) :-
   extractelement_instr_base(Instr, Vector),
   operand_has_type(Vector, VectorType),
   vector_type_has_component(VectorType, Type).
#line 31 "extractelement-instr.dl"
schema_invalid_instr(Instr,  "extractelement-instr.dl" ,  31 ) :-
   schema_sanity(),
   extractelement_instr(Instr),
   !extractelement_instr_base(Instr, _).

schema_invalid_instr(Instr,  "extractelement-instr.dl" ,  36 ) :-
   schema_sanity(),
   extractelement_instr(Instr),
   !extractelement_instr_index(Instr, _).

schema_invalid_instr(Instr,  "extractelement-instr.dl" ,  41 ) :-
   schema_sanity(),
   extractelement_instr(Instr),
   extractelement_instr_base(Instr, Vector),
   operand_has_type(Vector, Type),
   !vector_type(Type).

schema_invalid_instr(Instr,  "extractelement-instr.dl" ,  48 ) :-
   schema_sanity(),
   extractelement_instr(Instr),
   extractelement_instr_index(Instr, Index),
   operand_has_type(Index, Type),
   !int32_type(Type).

schema_invalid_instr(Instr,  "extractelement-instr.dl" ,  55 ) :-
   schema_sanity(),
   extractelement_instr_type(Instr, Type),
   !instr_returns_type(Instr, Type).
#line 63 "schema/schema.project"
#line 1 "insertelement-instr.dl"



.type InsertElementInstruction <: symbol
.decl insertelement_instr(instr:InsertElementInstruction)

instr(v) :- insertelement_instr(v).

.decl insertelement_instr_base(instr:InsertElementInstruction, vector:Operand)
.decl insertelement_instr_index(instr:InsertElementInstruction, index:Operand)
.decl insertelement_instr_value(instr:InsertElementInstruction, value:Operand)
.decl insertelement_instr_type(instr:InsertElementInstruction, type:Type)


insertelement_instr_type(Instr, Type) :-
   insertelement_instr_base(Instr, Vector),
   operand_has_type(Vector, VectorType),
   vector_type_has_component(VectorType, Type).
#line 33 "insertelement-instr.dl"
schema_invalid_instr(Instr,  "insertelement-instr.dl" ,  33 ) :-
   schema_sanity(),
   insertelement_instr(Instr),
   !insertelement_instr_base(Instr, _).

schema_invalid_instr(Instr,  "insertelement-instr.dl" ,  38 ) :-
   schema_sanity(),
   insertelement_instr(Instr),
   !insertelement_instr_index(Instr, _).

schema_invalid_instr(Instr,  "insertelement-instr.dl" ,  43 ) :-
   schema_sanity(),
   insertelement_instr(Instr),
   !insertelement_instr_value(Instr, _).

schema_invalid_instr(Instr,  "insertelement-instr.dl" ,  48 ) :-
   schema_sanity(),
   insertelement_instr(Instr),
   insertelement_instr_base(Instr, Vector),
   operand_has_type(Vector, Type),
   !vector_type(Type).

schema_invalid_instr(Instr,  "insertelement-instr.dl" ,  55 ) :-
   schema_sanity(),
   insertelement_instr(Instr),
   insertelement_instr_index(Instr, Index),
   operand_has_type(Index, Type),
   !int32_type(Type).

schema_invalid_instr(Instr,  "insertelement-instr.dl" ,  62 ) :-
   schema_sanity(),
   insertelement_instr(Instr),
   insertelement_instr_value(Instr, Value),
   insertelement_instr_type(Instr, Type),
   !operand_has_type(Value, Type).

schema_invalid_instr(Instr,  "insertelement-instr.dl" ,  69 ) :-
   schema_sanity(),
   insertelement_instr_base(Instr, Vector),
   operand_has_type(Vector, Type),
   !instr_returns_type(Instr, Type).
#line 64 "schema/schema.project"
#line 1 "shufflevector-instr.dl"



.type ShuffleVectorInstruction <: symbol
.decl shufflevector_instr(instr:ShuffleVectorInstruction)

instr(v) :- shufflevector_instr(v).

.decl shufflevector_instr_first_vector(instr:ShuffleVectorInstruction, vector:Operand)
.decl shufflevector_instr_second_vector(instr:ShuffleVectorInstruction, vector:Operand)
.decl shufflevector_instr_mask(instr:ShuffleVectorInstruction, mask:Constant)




.decl shufflevector_instrput_type(instr:ShuffleVectorInstruction, type:Type)
.decl shufflevector_instr_element_type(instr:ShuffleVectorInstruction, type:Type)
.decl shufflevector_instr_mask_type(instr:ShuffleVectorInstruction, type:Type)


shufflevector_instrput_type(Instr, Type) :-
   shufflevector_instr_first_vector(Instr, Vector),
   operand_has_type(Vector, Type).


shufflevector_instr_element_type(Instr, ElementType) :-
   shufflevector_instrput_type(Instr, VectorType),
   vector_type_has_component(VectorType, ElementType).


shufflevector_instr_mask_type(Instr, MaskType) :-
   shufflevector_instr_mask(Instr, Mask),
   constant_has_type(Mask, MaskType).
#line 56 "shufflevector-instr.dl"
schema_invalid_instr(Instr,  "shufflevector-instr.dl" ,  56 ) :-
   schema_sanity(),
   shufflevector_instr(Instr),
   !shufflevector_instr_first_vector(Instr, _).

schema_invalid_instr(Instr,  "shufflevector-instr.dl" ,  61 ) :-
   schema_sanity(),
   shufflevector_instr(Instr),
   !shufflevector_instr_second_vector(Instr, _).

schema_invalid_instr(Instr,  "shufflevector-instr.dl" ,  66 ) :-
   schema_sanity(),
   shufflevector_instr(Instr),
   !shufflevector_instr_mask(Instr, _).




schema_invalid_instr(Instr,  "shufflevector-instr.dl" ,  74 ) :-
   schema_sanity(),
   shufflevector_instr(Instr),
   shufflevector_instrput_type(Instr, InputType),
   shufflevector_instr_first_vector(Instr, FirstVector),
   operand_has_type(FirstVector, FirstVectorType),
   FirstVectorType != InputType.

schema_invalid_instr(Instr,  "shufflevector-instr.dl" ,  82 ) :-
   schema_sanity(),
   shufflevector_instr(Instr),
   shufflevector_instrput_type(Instr, InputType),
   shufflevector_instr_second_vector(Instr, SecondVector),
   operand_has_type(SecondVector, SecondVectorType),
   SecondVectorType != InputType.

schema_invalid_instr(Instr,  "shufflevector-instr.dl" ,  90 ) :-
   schema_sanity(),
   shufflevector_instrput_type(Instr, InputType),
   !vector_type(InputType).




schema_invalid_instr(Instr,  "shufflevector-instr.dl" ,  98 ) :-
   schema_sanity(),
   shufflevector_instr_mask_type(Instr, MaskType),
   !int32_vector_type(MaskType).




schema_invalid_instr(Instr,  "shufflevector-instr.dl" ,  106 ) :-
   schema_sanity(),
   shufflevector_instr_mask_type(Instr, MaskType),
   instr_returns_type(Instr, OutputType),
   !vector_compatible_types(OutputType, MaskType).

schema_invalid_instr(Instr,  "shufflevector-instr.dl" ,  112 ) :-
   schema_sanity(),
   shufflevector_instr_element_type(Instr, ElementType),
   instr_returns_type(Instr, OutputType),
   !vector_type_has_component(OutputType, ElementType).
#line 65 "schema/schema.project"
#line 1 "getelementptr-instr.dl"



.type GetElementPtrInstruction <: symbol
.decl getelementptr_instr(instr:GetElementPtrInstruction)

instr(v) :- getelementptr_instr(v).


.decl getelementptr_instr_base(instr:GetElementPtrInstruction, ptr:Operand)
.decl getelementptr_instr_inbounds(instr:GetElementPtrInstruction)
#line 32 "getelementptr-instr.dl"
.decl getelementptr_instr_nindices(instr:GetElementPtrInstruction, total:number)
.decl getelementptr_instr_index(instr:GetElementPtrInstruction, i:GepIndex, idx:Operand)




.decl getelementptr_instr_base_type(instr:GetElementPtrInstruction, type:Type)
.decl getelementptr_instr_index_type(instr:GetElementPtrInstruction, type:Type)

getelementptr_instr_base_type(Instr, PtrType) :-
   getelementptr_instr_base(Instr, BasePtr),
   operand_has_type(BasePtr, PtrType).

getelementptr_instr_index_type(Instr, IdxType) :-
   getelementptr_instr_index(Instr, _, Idx),
   operand_has_type(Idx, IdxType).


.decl gep_is_vector_based(instr:GetElementPtrInstruction)

gep_is_vector_based(Instr) :-
   getelementptr_instr_base_type(Instr, PtrType),
   vector_type(PtrType).
#line 71 "getelementptr-instr.dl"
.decl getelementptr_instrterm_type(instr:GetElementPtrInstruction, i:number, type:Type)
.decl getelementptr_instr_value_type(instr:GetElementPtrInstruction, type:Type)


instr_successor_index(Instr, Index, Index + 1) :-
   getelementptr_instr_index(Instr, Index, _).

getelementptr_instrterm_type(Instr, 1, Type) :-
   getelementptr_instr_base_type(Instr, PtrType),
   pointer_type_has_component(PtrType, Type).

getelementptr_instrterm_type(Instr, 1, Type) :-
   getelementptr_instr_base_type(Instr, VectorPtrType),
   vector_type_has_component(VectorPtrType, PtrType),
   pointer_type_has_component(PtrType, Type).

getelementptr_instrterm_type(Instr, NextIndex, Type) :-
   getelementptr_instrterm_type(Instr, Index, ArrayType),
   array_type_has_component(ArrayType, Type),
   instr_successor_index(Instr, Index, NextIndex).

getelementptr_instrterm_type(Instr, NextIndex, Type) :-
   getelementptr_instrterm_type(Instr, Index, VectorType),
   vector_type_has_component(VectorType, Type),
   instr_successor_index(Instr, Index, NextIndex).

getelementptr_instrterm_type(Instr, NextIndex, Type) :-
   getelementptr_instrterm_type(Instr, Index, StructType),
   getelementptr_instr_index(Instr, Index, FieldIdx),
   constant_has_type(FieldIdx, FieldIdxType),
   constant_to_int(FieldIdx, FieldIdxValue),
   int32_type(FieldIdxType),
   struct_type_field(StructType, FieldIdxValue, Type),
   instr_successor_index(Instr, Index, NextIndex).

getelementptr_instr_value_type(Instr, Type) :-
   getelementptr_instr_nindices(Instr, Total),
   getelementptr_instrterm_type(Instr, Total, Type).
#line 138 "getelementptr-instr.dl"
schema_invalid_instr(Instr,  "getelementptr-instr.dl" ,  138 ) :-
   schema_sanity(),
   getelementptr_instr(Instr),
   !getelementptr_instr_base(Instr, _).

schema_invalid_instr(Instr,  "getelementptr-instr.dl" ,  143 ) :-
   schema_sanity(),
   getelementptr_instr(Instr),
   !getelementptr_instr_nindices(Instr, _).

schema_invalid_instr(Instr,  "getelementptr-instr.dl" ,  148 ) :-
   schema_sanity(),
   getelementptr_instr_base_type(Instr, PtrType),
   !pointer_type(PtrType),
   !pointer_vector_type(PtrType).

schema_invalid_instr(Instr,  "getelementptr-instr.dl" ,  154 ) :-
   schema_sanity(),
   getelementptr_instr(Instr),
   !getelementptr_instr_value_type(Instr, _).

schema_invalid_instr(Instr,  "getelementptr-instr.dl" ,  159 ) :-
   schema_sanity(),
   getelementptr_instr_index_type(Instr, IdxType),
   !integer_type(IdxType),
   !integer_vector_type(IdxType).

schema_invalid_instr(Instr,  "getelementptr-instr.dl" ,  165 ) :-
   schema_sanity(),
   getelementptr_instr_base_type(Instr, PtrType),
   getelementptr_instr_index_type(Instr, IdxType),
   !vector_compatible_types(PtrType, IdxType).

schema_invalid_instr(Instr,  "getelementptr-instr.dl" ,  171 ) :-
   schema_sanity(),
   getelementptr_instr(Instr),
   !gep_is_vector_based(Instr),
   getelementptr_instr_value_type(Instr, ValueType),
   instr_returns_type(Instr, PtrType),
   !pointer_type_has_component(PtrType, ValueType).

schema_invalid_instr(Instr,  "getelementptr-instr.dl" ,  179 ) :-
   schema_sanity(),
   getelementptr_instr(Instr),
   gep_is_vector_based(Instr),
   getelementptr_instr_value_type(Instr, ValueType),
   instr_returns_type(Instr, VectorType),
   vector_type_has_component(VectorType, PtrType),
   !pointer_type_has_component(PtrType, ValueType).
#line 66 "schema/schema.project"
#line 1 "extractvalue-instr.dl"



.type ExtractValueInstruction <: symbol
.decl extractvalue_instr(instr:ExtractValueInstruction)

instr(v) :- extractvalue_instr(v).

.decl extractvalue_instr_base(instr:ExtractValueInstruction, aggregate:Operand)





.decl extractvalue_instr_nindices(instr:ExtractValueInstruction, total:number)
.decl extractvalue_instr_index(instr:ExtractValueInstruction, i:number, idx:number)

instr_successor_index(Instr, Index, Index + 1) :-
   extractvalue_instr_index(Instr, Index, _).






.decl extractvalue_instr_base_type(instr:ExtractValueInstruction, type:Type)
.decl extractvalue_instr_value_type(instr:ExtractValueInstruction, type:Type)
.decl extractvalue_instrterm_type(instr:ExtractValueInstruction, i:number, type:Type)

extractvalue_instrterm_type(Instr, 0, Type) :-
   extractvalue_instr_base(Instr, Aggregate),
   operand_has_type(Aggregate, Type).

extractvalue_instrterm_type(Instr, NextIndex, Type) :-
   extractvalue_instrterm_type(Instr, Index, StructType),
   extractvalue_instr_index(Instr, Index, IdxValue),
   struct_type_field(StructType, IdxValue, Type),
   instr_successor_index(Instr, Index, NextIndex).

extractvalue_instrterm_type(Instr, NextIndex, Type) :-
   extractvalue_instrterm_type(Instr, Index, ArrayType),
   array_type_has_component(ArrayType, Type),
   instr_successor_index(Instr, Index, NextIndex).

extractvalue_instr_value_type(Instr, Type) :-
   extractvalue_instr_nindices(Instr, Total),
   extractvalue_instrterm_type(Instr, Total, Type).

extractvalue_instr_base_type(Instr, Type) :-
   extractvalue_instrterm_type(Instr, 0, Type).
#line 64 "extractvalue-instr.dl"
schema_invalid_instr(Instr,  "extractvalue-instr.dl" ,  64 ) :-
   schema_sanity(),
   extractvalue_instr(Instr),
   !extractvalue_instr_base(Instr, _).

schema_invalid_instr(Instr,  "extractvalue-instr.dl" ,  69 ) :-
   schema_sanity(),
   extractvalue_instr(Instr),
   !extractvalue_instr_nindices(Instr, _).

schema_invalid_instr(Instr,  "extractvalue-instr.dl" ,  74 ) :-
   schema_sanity(),
   extractvalue_instr(Instr),
   !extractvalue_instr_index(Instr, 0, _).

schema_invalid_instr(Instr,  "extractvalue-instr.dl" ,  79 ) :-
   schema_sanity(),
   extractvalue_instr_base_type(Instr, BaseType),
   !aggregate_type(BaseType).

schema_invalid_instr(Instr,  "extractvalue-instr.dl" ,  84 ) :-
   schema_sanity(),
   extractvalue_instr_nindices(Instr, Total),
   Total <= 0.

schema_invalid_instr(Instr,  "extractvalue-instr.dl" ,  89 ) :-
   schema_sanity(),
   extractvalue_instr_value_type(Instr, Type),
   !instr_returns_type(Instr, Type).
#line 67 "schema/schema.project"
#line 1 "insertvalue-instr.dl"



.type InsertValueInstruction <: symbol
.decl insertvalue_instr(instr:InsertValueInstruction)

instr(v) :- insertvalue_instr(v).

.decl insertvalue_instr_base(instr:InsertValueInstruction, aggregate:Operand)
.decl insertvalue_instr_value(instr:InsertValueInstruction, value:Operand)





.decl insertvalue_instr_nindices(instr:InsertValueInstruction, total:number)
.decl insertvalue_instr_index(instr:InsertValueInstruction, i:number, idx:number)

instr_successor_index(Instr, Index, Index + 1) :-
   insertvalue_instr_index(Instr, Index, _).






.decl insertvalue_instr_base_type(instr:InsertValueInstruction, type:Type)
.decl insertvalue_instr_value_type(instr:InsertValueInstruction, type:Type)
.decl insertvalue_instrterm_type(instr:InsertValueInstruction, i:number, type:Type)

insertvalue_instrterm_type(Instr, 0, Type) :-
   insertvalue_instr_base(Instr, Aggregate),
   operand_has_type(Aggregate, Type).

insertvalue_instrterm_type(Instr, NextIndex, Type) :-
   insertvalue_instrterm_type(Instr, Index, StructType),
   insertvalue_instr_index(Instr, Index, IdxValue),
   struct_type_field(StructType, IdxValue, Type),
   instr_successor_index(Instr, Index, NextIndex).

insertvalue_instrterm_type(Instr, NextIndex, Type) :-
   insertvalue_instrterm_type(Instr, Index, ArrayType),
   array_type_has_component(ArrayType, Type),
   instr_successor_index(Instr, Index, NextIndex).

insertvalue_instr_value_type(Instr, Type) :-
   insertvalue_instr_nindices(Instr, Total),
   insertvalue_instrterm_type(Instr, Total, Type).

insertvalue_instr_base_type(Instr, Type) :-
   insertvalue_instrterm_type(Instr, 0, Type).
#line 68 "insertvalue-instr.dl"
schema_invalid_instr(Instr,  "insertvalue-instr.dl" ,  68 ) :-
   schema_sanity(),
   insertvalue_instr(Instr),
   !insertvalue_instr_base(Instr, _).

schema_invalid_instr(Instr,  "insertvalue-instr.dl" ,  73 ) :-
   schema_sanity(),
   insertvalue_instr(Instr),
   !insertvalue_instr_value(Instr, _).

schema_invalid_instr(Instr,  "insertvalue-instr.dl" ,  78 ) :-
   schema_sanity(),
   insertvalue_instr(Instr),
   !insertvalue_instr_nindices(Instr, _).

schema_invalid_instr(Instr,  "insertvalue-instr.dl" ,  83 ) :-
   schema_sanity(),
   insertvalue_instr(Instr),
   !insertvalue_instr_index(Instr, 0, _).

schema_invalid_instr(Instr,  "insertvalue-instr.dl" ,  88 ) :-
   schema_sanity(),
   insertvalue_instr_base_type(Instr, BaseType),
   !aggregate_type(BaseType).

schema_invalid_instr(Instr,  "insertvalue-instr.dl" ,  93 ) :-
   schema_sanity(),
   insertvalue_instr_value_type(Instr, Type),
   !type_is_firstclass(Type).

schema_invalid_instr(Instr,  "insertvalue-instr.dl" ,  98 ) :-
   schema_sanity(),
   insertvalue_instr_value(Instr, Value),
   insertvalue_instr_value_type(Instr, Type),
   !operand_has_type(Value, Type).

schema_invalid_instr(Instr,  "insertvalue-instr.dl" ,  104 ) :-
   schema_sanity(),
   insertvalue_instr_nindices(Instr, Total),
   Total <= 0.

schema_invalid_instr(Instr,  "insertvalue-instr.dl" ,  109 ) :-
   schema_sanity(),
   insertvalue_instr_base_type(Instr, BaseType),
   !instr_returns_type(Instr, BaseType).
#line 68 "schema/schema.project"
#line 1 "unreachable-instr.dl"



.type UnreachableInstruction <: symbol
.decl unreachable_instr(instr:UnreachableInstruction)

instr(v) :- unreachable_instr(v).
terminator_instr(Insn) :- unreachable_instr(Insn).
#line 69 "schema/schema.project"
#line 1 "va-arg-instr.dl"



.type VaArgInstruction <: symbol
.decl va_arg_instr(instr:VaArgInstruction)

instr(v) :- va_arg_instr(v).

.decl va_arg_instr_va_list(instr:VaArgInstruction, list:Operand)
.decl va_arg_instr_type(instr:VaArgInstruction, type:Type)
#line 24 "va-arg-instr.dl"
schema_invalid_instr(Instr,  "va-arg-instr.dl" ,  24 ) :-
   schema_sanity(),
   va_arg_instr(Instr),
   !va_arg_instr_va_list(Instr, _).

schema_invalid_instr(Instr,  "va-arg-instr.dl" ,  29 ) :-
   schema_sanity(),
   va_arg_instr(Instr),
   !va_arg_instr_type(Instr, _).

schema_invalid_instr(Instr,  "va-arg-instr.dl" ,  34 ) :-
   schema_sanity(),
   va_arg_instr(Instr),
   va_arg_instr_va_list(Instr, List),
   operand_has_type(List, ListType),
   !pointer_type(ListType).

schema_invalid_instr(Instr,  "va-arg-instr.dl" ,  41 ) :-
   schema_sanity(),
   va_arg_instr(Instr),
   va_arg_instr_type(Instr, Type),
   !instr_returns_type(Instr, Type).
#line 70 "schema/schema.project"
#line 71 "schema/schema.project"
#line 1 "activate-sanity.dl"

schema_sanity().
#line 72 "schema/schema.project"
#line 2 "common.project"
#line 1 "import/import.project"
#line 1 "import.dl"
#line 11 "import.dl"
#line 1 "../../FactGenerator/include/predicates.inc"
#line 19 "../../FactGenerator/include/predicates.inc"

.input block_predecessor (IO="file", delimiter="\t", filename= "block_predecessor.csv.gz" )



.input global_var(IO="file", delimiter="\t", filename= "global_var.csv.gz" )
.input global_var_name (IO="file", delimiter="\t", filename= "global_var_name.csv.gz" )
.input global_var_demangled_name (IO="file", delimiter="\t", filename= "global_var_demangled_name.csv.gz" )
.input global_var_type (IO="file", delimiter="\t", filename= "global_var_type.csv.gz" )
.input global_var_initializer (IO="file", delimiter="\t", filename= "global_var_initializer.csv.gz" )
.input global_var_section (IO="file", delimiter="\t", filename= "global_var_section.csv.gz" )
.input global_var_aligned_to (IO="file", delimiter="\t", filename= "global_var_aligned_to.csv.gz" )
.input global_var_flag (IO="file", delimiter="\t", filename= "global_var_flag.csv.gz" )
.input global_var_linkage (IO="file", delimiter="\t", filename= "global_var_linkage.csv.gz" )
.input global_var_visibility (IO="file", delimiter="\t", filename= "global_var_visibility.csv.gz" )
.input global_var_threadlocal_mode (IO="file", delimiter="\t", filename= "global_var_threadlocal_mode.csv.gz" )



.input alias(IO="file", delimiter="\t", filename= "alias.csv.gz" )
.input alias_name (IO="file", delimiter="\t", filename= "alias_name.csv.gz" )
.input alias_type (IO="file", delimiter="\t", filename= "alias_type.csv.gz" )
.input alias_linkage (IO="file", delimiter="\t", filename= "alias_linkage.csv.gz" )
.input alias_visibility (IO="file", delimiter="\t", filename= "alias_visibility.csv.gz" )
.input alias_aliasee (IO="file", delimiter="\t", filename= "alias_aliasee.csv.gz" )



.input func(IO="file", delimiter="\t", filename= "func.csv.gz" )
.input func_decl(IO="file", delimiter="\t", filename= "func_decl.csv.gz" )
.input func_unnamed_addr (IO="file", delimiter="\t", filename= "func_unnamed_addr.csv.gz" )
.input func_linkage (IO="file", delimiter="\t", filename= "func_linkage.csv.gz" )
.input func_visibility (IO="file", delimiter="\t", filename= "func_visibility.csv.gz" )
.input func_calling_conv (IO="file", delimiter="\t", filename= "func_calling_conv.csv.gz" )
.input func_section (IO="file", delimiter="\t", filename= "func_section.csv.gz" )
.input func_alignment (IO="file", delimiter="\t", filename= "func_alignment.csv.gz" )
.input func_func_attr (IO="file", delimiter="\t", filename= "func_func_attr.csv.gz" )
.input func_gc (IO="file", delimiter="\t", filename= "func_gc.csv.gz" )
.input func_pers_fn (IO="file", delimiter="\t", filename= "func_pers_fn.csv.gz" )
.input func_name (IO="file", delimiter="\t", filename= "func_name.csv.gz" )
.input func_ty (IO="file", delimiter="\t", filename= "func_ty.csv.gz" )
.input func_signature (IO="file", delimiter="\t", filename= "func_signature.csv.gz" )
.input func_param (IO="file", delimiter="\t", filename= "func_param.csv.gz" )
.input func_return_attr (IO="file", delimiter="\t", filename= "func_return_attr.csv.gz" )
.input func_param_attr (IO="file", delimiter="\t", filename= "func_param_attr.csv.gz" )



.input instr_assigns_to (IO="file", delimiter="\t", filename= "instr_assigns_to.csv.gz" )
.input instr_flag (IO="file", delimiter="\t", filename= "instr_flag.csv.gz" )
.input instr_successor (IO="file", delimiter="\t", filename= "instr_successor.csv.gz" )
.input instr_bb_entry (IO="file", delimiter="\t", filename= "instr_bb_entry.csv.gz" )
.input instr_func (IO="file", delimiter="\t", filename= "instr_func.csv.gz" )
.input instr_pos (IO="file", delimiter="\t", filename= "instr_pos.csv.gz" )



.input unreachable_instr (IO="file", delimiter="\t", filename= "unreachable_instr.csv.gz" )



.input add_instr (IO="file", delimiter="\t", filename= "add_instr.csv.gz" )
.input add_instr_first_operand (IO="file", delimiter="\t", filename= "add_instr_first_operand.csv.gz" )
.input add_instr_second_operand (IO="file", delimiter="\t", filename= "add_instr_second_operand.csv.gz" )



.input fadd_instr (IO="file", delimiter="\t", filename= "fadd_instr.csv.gz" )
.input fadd_instr_first_operand (IO="file", delimiter="\t", filename= "fadd_instr_first_operand.csv.gz" )
.input fadd_instr_second_operand (IO="file", delimiter="\t", filename= "fadd_instr_second_operand.csv.gz" )



.input sub_instr (IO="file", delimiter="\t", filename= "sub_instr.csv.gz" )
.input sub_instr_first_operand (IO="file", delimiter="\t", filename= "sub_instr_first_operand.csv.gz" )
.input sub_instr_second_operand (IO="file", delimiter="\t", filename= "sub_instr_second_operand.csv.gz" )



.input fsub_instr (IO="file", delimiter="\t", filename= "fsub_instr.csv.gz" )
.input fsub_instr_first_operand (IO="file", delimiter="\t", filename= "fsub_instr_first_operand.csv.gz" )
.input fsub_instr_second_operand (IO="file", delimiter="\t", filename= "fsub_instr_second_operand.csv.gz" )



.input mul_instr (IO="file", delimiter="\t", filename= "mul_instr.csv.gz" )
.input mul_instr_first_operand (IO="file", delimiter="\t", filename= "mul_instr_first_operand.csv.gz" )
.input mul_instr_second_operand (IO="file", delimiter="\t", filename= "mul_instr_second_operand.csv.gz" )



.input fmul_instr (IO="file", delimiter="\t", filename= "fmul_instr.csv.gz" )
.input fmul_instr_first_operand (IO="file", delimiter="\t", filename= "fmul_instr_first_operand.csv.gz" )
.input fmul_instr_second_operand (IO="file", delimiter="\t", filename= "fmul_instr_second_operand.csv.gz" )



.input udiv_instr (IO="file", delimiter="\t", filename= "udiv_instr.csv.gz" )
.input udiv_instr_first_operand (IO="file", delimiter="\t", filename= "udiv_instr_first_operand.csv.gz" )
.input udiv_instr_second_operand (IO="file", delimiter="\t", filename= "udiv_instr_second_operand.csv.gz" )



.input fdiv_instr (IO="file", delimiter="\t", filename= "fdiv_instr.csv.gz" )
.input fdiv_instr_first_operand (IO="file", delimiter="\t", filename= "fdiv_instr_first_operand.csv.gz" )
.input fdiv_instr_second_operand (IO="file", delimiter="\t", filename= "fdiv_instr_second_operand.csv.gz" )



.input sdiv_instr (IO="file", delimiter="\t", filename= "sdiv_instr.csv.gz" )
.input sdiv_instr_first_operand (IO="file", delimiter="\t", filename= "sdiv_instr_first_operand.csv.gz" )
.input sdiv_instr_second_operand (IO="file", delimiter="\t", filename= "sdiv_instr_second_operand.csv.gz" )



.input urem_instr (IO="file", delimiter="\t", filename= "urem_instr.csv.gz" )
.input urem_instr_first_operand (IO="file", delimiter="\t", filename= "urem_instr_first_operand.csv.gz" )
.input urem_instr_second_operand (IO="file", delimiter="\t", filename= "urem_instr_second_operand.csv.gz" )



.input srem_instr (IO="file", delimiter="\t", filename= "srem_instr.csv.gz" )
.input srem_instr_first_operand (IO="file", delimiter="\t", filename= "srem_instr_first_operand.csv.gz" )
.input srem_instr_second_operand (IO="file", delimiter="\t", filename= "srem_instr_second_operand.csv.gz" )



.input frem_instr (IO="file", delimiter="\t", filename= "frem_instr.csv.gz" )
.input frem_instr_first_operand (IO="file", delimiter="\t", filename= "frem_instr_first_operand.csv.gz" )
.input frem_instr_second_operand (IO="file", delimiter="\t", filename= "frem_instr_second_operand.csv.gz" )





.input shl_instr (IO="file", delimiter="\t", filename= "shl_instr.csv.gz" )
.input shl_instr_first_operand (IO="file", delimiter="\t", filename= "shl_instr_first_operand.csv.gz" )
.input shl_instr_second_operand (IO="file", delimiter="\t", filename= "shl_instr_second_operand.csv.gz" )



.input lshr_instr (IO="file", delimiter="\t", filename= "lshr_instr.csv.gz" )
.input lshr_instr_first_operand (IO="file", delimiter="\t", filename= "lshr_instr_first_operand.csv.gz" )
.input lshr_instr_second_operand (IO="file", delimiter="\t", filename= "lshr_instr_second_operand.csv.gz" )



.input ashr_instr (IO="file", delimiter="\t", filename= "ashr_instr.csv.gz" )
.input ashr_instr_first_operand (IO="file", delimiter="\t", filename= "ashr_instr_first_operand.csv.gz" )
.input ashr_instr_second_operand (IO="file", delimiter="\t", filename= "ashr_instr_second_operand.csv.gz" )



.input and_instr (IO="file", delimiter="\t", filename= "and_instr.csv.gz" )
.input and_instr_first_operand (IO="file", delimiter="\t", filename= "and_instr_first_operand.csv.gz" )
.input and_instr_second_operand (IO="file", delimiter="\t", filename= "and_instr_second_operand.csv.gz" )



.input or_instr (IO="file", delimiter="\t", filename= "or_instr.csv.gz" )
.input or_instr_first_operand (IO="file", delimiter="\t", filename= "or_instr_first_operand.csv.gz" )
.input or_instr_second_operand (IO="file", delimiter="\t", filename= "or_instr_second_operand.csv.gz" )



.input xor_instr (IO="file", delimiter="\t", filename= "xor_instr.csv.gz" )
.input xor_instr_first_operand (IO="file", delimiter="\t", filename= "xor_instr_first_operand.csv.gz" )
.input xor_instr_second_operand (IO="file", delimiter="\t", filename= "xor_instr_second_operand.csv.gz" )





.input ret_instr (IO="file", delimiter="\t", filename= "ret_instr.csv.gz" )

.input ret_instr_void_ (IO="file", delimiter="\t", filename= "ret_instr_void_.csv.gz" )
.input ret_instr_operand (IO="file", delimiter="\t", filename= "ret_instr_operand.csv.gz" )



.input br_instr (IO="file", delimiter="\t", filename= "br_instr.csv.gz" )
.input br_instr_cond (IO="file", delimiter="\t", filename= "br_instr_cond.csv.gz" )
.input br_instr_condition (IO="file", delimiter="\t", filename= "br_instr_condition.csv.gz" )
.input br_instr_true_label (IO="file", delimiter="\t", filename= "br_instr_true_label.csv.gz" )
.input br_instr_false_label (IO="file", delimiter="\t", filename= "br_instr_false_label.csv.gz" )
.input br_instr_uncond (IO="file", delimiter="\t", filename= "br_instr_uncond.csv.gz" )
.input br_instr_uncond_label (IO="file", delimiter="\t", filename= "br_instr_uncond_label.csv.gz" )



.input switch_instr (IO="file", delimiter="\t", filename= "switch_instr.csv.gz" )
.input switch_instr_operand (IO="file", delimiter="\t", filename= "switch_instr_operand.csv.gz" )
.input switch_instr_default_label (IO="file", delimiter="\t", filename= "switch_instr_default_label.csv.gz" )
.input switch_instr_case_value (IO="file", delimiter="\t", filename= "switch_instr_case_value.csv.gz" )
.input switch_instr_case_label (IO="file", delimiter="\t", filename= "switch_instr_case_label.csv.gz" )
.input switch_instr_ncases (IO="file", delimiter="\t", filename= "switch_instr_ncases.csv.gz" )



.input indirectbr_instr (IO="file", delimiter="\t", filename= "indirectbr_instr.csv.gz" )
.input indirectbr_instr_address (IO="file", delimiter="\t", filename= "indirectbr_instr_address.csv.gz" )
.input indirectbr_instr_label (IO="file", delimiter="\t", filename= "indirectbr_instr_label.csv.gz" )
.input indirectbr_instr_nlabels (IO="file", delimiter="\t", filename= "indirectbr_instr_nlabels.csv.gz" )



.input resume_instr (IO="file", delimiter="\t", filename= "resume_instr.csv.gz" )
.input resume_instr_operand (IO="file", delimiter="\t", filename= "resume_instr_operand.csv.gz" )



.input invoke_instr (IO="file", delimiter="\t", filename= "invoke_instr.csv.gz" )
.input invoke_instr_arg (IO="file", delimiter="\t", filename= "invoke_instr_arg.csv.gz" )
.input invoke_instr_func_operand (IO="file", delimiter="\t", filename= "invoke_instr_func_operand.csv.gz" )
.input invoke_instr_calling_conv (IO="file", delimiter="\t", filename= "invoke_instr_calling_conv.csv.gz" )
.input invoke_instr_return_attr (IO="file", delimiter="\t", filename= "invoke_instr_return_attr.csv.gz" )
.input invoke_instr_param_attr (IO="file", delimiter="\t", filename= "invoke_instr_param_attr.csv.gz" )
.input invoke_instr_func_attr (IO="file", delimiter="\t", filename= "invoke_instr_func_attr.csv.gz" )
.input invoke_instr_normal_label (IO="file", delimiter="\t", filename= "invoke_instr_normal_label.csv.gz" )
.input invoke_instr_exception_label (IO="file", delimiter="\t", filename= "invoke_instr_exception_label.csv.gz" )





.input extractelement_instr (IO="file", delimiter="\t", filename= "extractelement_instr.csv.gz" )
.input extractelement_instr_base (IO="file", delimiter="\t", filename= "extractelement_instr_base.csv.gz" )
.input extractelement_instr_index (IO="file", delimiter="\t", filename= "extractelement_instr_index.csv.gz" )



.input insertelement_instr (IO="file", delimiter="\t", filename= "insertelement_instr.csv.gz" )
.input insertelement_instr_base (IO="file", delimiter="\t", filename= "insertelement_instr_base.csv.gz" )
.input insertelement_instr_index (IO="file", delimiter="\t", filename= "insertelement_instr_index.csv.gz" )
.input insertelement_instr_value (IO="file", delimiter="\t", filename= "insertelement_instr_value.csv.gz" )



.input shufflevector_instr (IO="file", delimiter="\t", filename= "shufflevector_instr.csv.gz" )
.input shufflevector_instr_first_vector (IO="file", delimiter="\t", filename= "shufflevector_instr_first_vector.csv.gz" )
.input shufflevector_instr_second_vector (IO="file", delimiter="\t", filename= "shufflevector_instr_second_vector.csv.gz" )
.input shufflevector_instr_mask (IO="file", delimiter="\t", filename= "shufflevector_instr_mask.csv.gz" )





.input extractvalue_instr (IO="file", delimiter="\t", filename= "extractvalue_instr.csv.gz" )
.input extractvalue_instr_base (IO="file", delimiter="\t", filename= "extractvalue_instr_base.csv.gz" )
.input extractvalue_instr_index (IO="file", delimiter="\t", filename= "extractvalue_instr_index.csv.gz" )
.input extractvalue_instr_nindices (IO="file", delimiter="\t", filename= "extractvalue_instr_nindices.csv.gz" )



.input insertvalue_instr (IO="file", delimiter="\t", filename= "insertvalue_instr.csv.gz" )
.input insertvalue_instr_base (IO="file", delimiter="\t", filename= "insertvalue_instr_base.csv.gz" )
.input insertvalue_instr_value (IO="file", delimiter="\t", filename= "insertvalue_instr_value.csv.gz" )
.input insertvalue_instr_index (IO="file", delimiter="\t", filename= "insertvalue_instr_index.csv.gz" )
.input insertvalue_instr_nindices (IO="file", delimiter="\t", filename= "insertvalue_instr_nindices.csv.gz" )





.input alloca_instr (IO="file", delimiter="\t", filename= "alloca_instr.csv.gz" )
.input alloca_instr_size (IO="file", delimiter="\t", filename= "alloca_instr_size.csv.gz" )
.input alloca_instr_alignment (IO="file", delimiter="\t", filename= "alloca_instr_alignment.csv.gz" )
.input alloca_instr_type (IO="file", delimiter="\t", filename= "alloca_instr_type.csv.gz" )



.input load_instr (IO="file", delimiter="\t", filename= "load_instr.csv.gz" )
.input load_instr_alignment (IO="file", delimiter="\t", filename= "load_instr_alignment.csv.gz" )
.input load_instr_ordering (IO="file", delimiter="\t", filename= "load_instr_ordering.csv.gz" )
.input load_instr_address (IO="file", delimiter="\t", filename= "load_instr_address.csv.gz" )
.input load_instr_is_volatile (IO="file", delimiter="\t", filename= "load_instr_is_volatile.csv.gz" )



.input store_instr (IO="file", delimiter="\t", filename= "store_instr.csv.gz" )
.input store_instr_alignment (IO="file", delimiter="\t", filename= "store_instr_alignment.csv.gz" )
.input store_instr_ordering (IO="file", delimiter="\t", filename= "store_instr_ordering.csv.gz" )
.input store_instr_value (IO="file", delimiter="\t", filename= "store_instr_value.csv.gz" )
.input store_instr_address (IO="file", delimiter="\t", filename= "store_instr_address.csv.gz" )
.input store_instr_is_volatile (IO="file", delimiter="\t", filename= "store_instr_is_volatile.csv.gz" )



.input fence_instr (IO="file", delimiter="\t", filename= "fence_instr.csv.gz" )
.input fence_instr_ordering (IO="file", delimiter="\t", filename= "fence_instr_ordering.csv.gz" )



.input atomicrmw_instr (IO="file", delimiter="\t", filename= "atomicrmw_instr.csv.gz" )
.input atomicrmw_instr_ordering (IO="file", delimiter="\t", filename= "atomicrmw_instr_ordering.csv.gz" )
.input atomicrmw_instr_operation (IO="file", delimiter="\t", filename= "atomicrmw_instr_operation.csv.gz" )
.input atomicrmw_instr_address (IO="file", delimiter="\t", filename= "atomicrmw_instr_address.csv.gz" )
.input atomicrmw_instr_value (IO="file", delimiter="\t", filename= "atomicrmw_instr_value.csv.gz" )
.input atomicrmw_instr_is_volatile (IO="file", delimiter="\t", filename= "atomicrmw_instr_is_volatile.csv.gz" )



.input cmpxchg_instr (IO="file", delimiter="\t", filename= "cmpxchg_instr.csv.gz" )
.input cmpxchg_instr_ordering (IO="file", delimiter="\t", filename= "cmpxchg_instr_ordering.csv.gz" )
.input cmpxchg_instr_address (IO="file", delimiter="\t", filename= "cmpxchg_instr_address.csv.gz" )
.input cmpxchg_instr_cmp_value (IO="file", delimiter="\t", filename= "cmpxchg_instr_cmp_value.csv.gz" )
.input cmpxchg_instr_new_value (IO="file", delimiter="\t", filename= "cmpxchg_instr_new_value.csv.gz" )
.input cmpxchg_instr_type (IO="file", delimiter="\t", filename= "cmpxchg_instr_type.csv.gz" )
.input cmpxchg_instr_is_volatile (IO="file", delimiter="\t", filename= "cmpxchg_instr_is_volatile.csv.gz" )



.input getelementptr_instr (IO="file", delimiter="\t", filename= "getelementptr_instr.csv.gz" )
.input getelementptr_instr_base (IO="file", delimiter="\t", filename= "getelementptr_instr_base.csv.gz" )
.input getelementptr_instr_index (IO="file", delimiter="\t", filename= "getelementptr_instr_index.csv.gz" )
.input getelementptr_instr_nindices (IO="file", delimiter="\t", filename= "getelementptr_instr_nindices.csv.gz" )
.input getelementptr_instr_inbounds (IO="file", delimiter="\t", filename= "getelementptr_instr_inbounds.csv.gz" )





.input trunc_instr (IO="file", delimiter="\t", filename= "trunc_instr.csv.gz" )
.input trunc_instr_from_operand (IO="file", delimiter="\t", filename= "trunc_instr_from_operand.csv.gz" )
.input trunc_instr_to_type (IO="file", delimiter="\t", filename= "trunc_instr_to_type.csv.gz" )



.input zext_instr (IO="file", delimiter="\t", filename= "zext_instr.csv.gz" )
.input zext_instr_from_operand (IO="file", delimiter="\t", filename= "zext_instr_from_operand.csv.gz" )
.input zext_instr_to_type (IO="file", delimiter="\t", filename= "zext_instr_to_type.csv.gz" )



.input sext_instr (IO="file", delimiter="\t", filename= "sext_instr.csv.gz" )
.input sext_instr_from_operand (IO="file", delimiter="\t", filename= "sext_instr_from_operand.csv.gz" )
.input sext_instr_to_type (IO="file", delimiter="\t", filename= "sext_instr_to_type.csv.gz" )



.input fptrunc_instr (IO="file", delimiter="\t", filename= "fptrunc_instr.csv.gz" )
.input fptrunc_instr_from_operand (IO="file", delimiter="\t", filename= "fptrunc_instr_from_operand.csv.gz" )
.input fptrunc_instr_to_type (IO="file", delimiter="\t", filename= "fptrunc_instr_to_type.csv.gz" )



.input fpext_instr (IO="file", delimiter="\t", filename= "fpext_instr.csv.gz" )
.input fpext_instr_from_operand (IO="file", delimiter="\t", filename= "fpext_instr_from_operand.csv.gz" )
.input fpext_instr_to_type (IO="file", delimiter="\t", filename= "fpext_instr_to_type.csv.gz" )



.input fptoui_instr (IO="file", delimiter="\t", filename= "fptoui_instr.csv.gz" )
.input fptoui_instr_from_operand (IO="file", delimiter="\t", filename= "fptoui_instr_from_operand.csv.gz" )
.input fptoui_instr_to_type (IO="file", delimiter="\t", filename= "fptoui_instr_to_type.csv.gz" )



.input fptosi_instr (IO="file", delimiter="\t", filename= "fptosi_instr.csv.gz" )
.input fptosi_instr_from_operand (IO="file", delimiter="\t", filename= "fptosi_instr_from_operand.csv.gz" )
.input fptosi_instr_to_type (IO="file", delimiter="\t", filename= "fptosi_instr_to_type.csv.gz" )



.input uitofp_instr (IO="file", delimiter="\t", filename= "uitofp_instr.csv.gz" )
.input uitofp_instr_from_operand (IO="file", delimiter="\t", filename= "uitofp_instr_from_operand.csv.gz" )
.input uitofp_instr_to_type (IO="file", delimiter="\t", filename= "uitofp_instr_to_type.csv.gz" )



.input sitofp_instr (IO="file", delimiter="\t", filename= "sitofp_instr.csv.gz" )
.input sitofp_instr_from_operand (IO="file", delimiter="\t", filename= "sitofp_instr_from_operand.csv.gz" )
.input sitofp_instr_to_type (IO="file", delimiter="\t", filename= "sitofp_instr_to_type.csv.gz" )



.input ptrtoint_instr (IO="file", delimiter="\t", filename= "ptrtoint_instr.csv.gz" )
.input ptrtoint_instr_from_operand (IO="file", delimiter="\t", filename= "ptrtoint_instr_from_operand.csv.gz" )
.input ptrtoint_instr_to_type (IO="file", delimiter="\t", filename= "ptrtoint_instr_to_type.csv.gz" )



.input inttoptr_instr (IO="file", delimiter="\t", filename= "inttoptr_instr.csv.gz" )
.input inttoptr_instr_from_operand (IO="file", delimiter="\t", filename= "inttoptr_instr_from_operand.csv.gz" )
.input inttoptr_instr_to_type (IO="file", delimiter="\t", filename= "inttoptr_instr_to_type.csv.gz" )



.input bitcast_instr (IO="file", delimiter="\t", filename= "bitcast_instr.csv.gz" )
.input bitcast_instr_from_operand (IO="file", delimiter="\t", filename= "bitcast_instr_from_operand.csv.gz" )
.input bitcast_instr_to_type (IO="file", delimiter="\t", filename= "bitcast_instr_to_type.csv.gz" )





.input icmp_instr (IO="file", delimiter="\t", filename= "icmp_instr.csv.gz" )
.input icmp_instr_condition (IO="file", delimiter="\t", filename= "icmp_instr_condition.csv.gz" )
.input icmp_instr_first_operand (IO="file", delimiter="\t", filename= "icmp_instr_first_operand.csv.gz" )
.input icmp_instr_second_operand (IO="file", delimiter="\t", filename= "icmp_instr_second_operand.csv.gz" )



.input fcmp_instr (IO="file", delimiter="\t", filename= "fcmp_instr.csv.gz" )
.input fcmp_instr_condition (IO="file", delimiter="\t", filename= "fcmp_instr_condition.csv.gz" )
.input fcmp_instr_first_operand (IO="file", delimiter="\t", filename= "fcmp_instr_first_operand.csv.gz" )
.input fcmp_instr_second_operand (IO="file", delimiter="\t", filename= "fcmp_instr_second_operand.csv.gz" )



.input phi_instr (IO="file", delimiter="\t", filename= "phi_instr.csv.gz" )
.input phi_instr_type (IO="file", delimiter="\t", filename= "phi_instr_type.csv.gz" )
.input phi_instr_pair_value (IO="file", delimiter="\t", filename= "phi_instr_pair_value.csv.gz" )
.input phi_instr_pair_label (IO="file", delimiter="\t", filename= "phi_instr_pair_label.csv.gz" )
.input phi_instr_npairs (IO="file", delimiter="\t", filename= "phi_instr_npairs.csv.gz" )



.input select_instr (IO="file", delimiter="\t", filename= "select_instr.csv.gz" )
.input select_instr_condition (IO="file", delimiter="\t", filename= "select_instr_condition.csv.gz" )
.input select_instr_first_operand (IO="file", delimiter="\t", filename= "select_instr_first_operand.csv.gz" )
.input select_instr_second_operand (IO="file", delimiter="\t", filename= "select_instr_second_operand.csv.gz" )



.input va_arg_instr (IO="file", delimiter="\t", filename= "va_arg_instr.csv.gz" )
.input va_arg_instr_va_list (IO="file", delimiter="\t", filename= "va_arg_instr_va_list.csv.gz" )
.input va_arg_instr_type (IO="file", delimiter="\t", filename= "va_arg_instr_type.csv.gz" )



.input call_instr (IO="file", delimiter="\t", filename= "call_instr.csv.gz" )
.input call_instr_func_operand (IO="file", delimiter="\t", filename= "call_instr_func_operand.csv.gz" )
.input call_instr_arg (IO="file", delimiter="\t", filename= "call_instr_arg.csv.gz" )
.input call_instr_calling_conv (IO="file", delimiter="\t", filename= "call_instr_calling_conv.csv.gz" )
.input call_instr_return_attr (IO="file", delimiter="\t", filename= "call_instr_return_attr.csv.gz" )
.input call_instr_param_attr (IO="file", delimiter="\t", filename= "call_instr_param_attr.csv.gz" )
.input call_instr_func_attr (IO="file", delimiter="\t", filename= "call_instr_func_attr.csv.gz" )
.input call_instr_tail_opt (IO="file", delimiter="\t", filename= "call_instr_tail_opt.csv.gz" )



.input landingpad_instr (IO="file", delimiter="\t", filename= "landingpad_instr.csv.gz" )
.input landingpad_instr_type (IO="file", delimiter="\t", filename= "landingpad_instr_type.csv.gz" )
.input landingpad_instr_catch_clause (IO="file", delimiter="\t", filename= "landingpad_instr_catch_clause.csv.gz" )
.input landingpad_instr_filter_clause (IO="file", delimiter="\t", filename= "landingpad_instr_filter_clause.csv.gz" )
.input landingpad_instr_nclauses (IO="file", delimiter="\t", filename= "landingpad_instr_nclauses.csv.gz" )

.input landingpad_instr_is_cleanup(IO="file", delimiter="\t", filename= "landingpad_instr_is_cleanup.csv.gz" )





.input primitive_type(IO="file", delimiter="\t", filename= "primitive_type.csv.gz" )



.input integer_type(IO="file", delimiter="\t", filename= "integer_type.csv.gz" )



.input fp_type(IO="file", delimiter="\t", filename= "fp_type.csv.gz" )



.input type_has_size(IO="file", delimiter="\t", filename= "type_has_size.csv.gz" )
.input type_has_unpadded_size(IO="file", delimiter="\t", filename= "type_has_unpadded_size.csv.gz" )



.input func_type(IO="file", delimiter="\t", filename= "func_type.csv.gz" )
.input func_type_has_varargs(IO="file", delimiter="\t", filename= "func_type_has_varargs.csv.gz" )
.input func_type_return(IO="file", delimiter="\t", filename= "func_type_return.csv.gz" )
.input func_type_param(IO="file", delimiter="\t", filename= "func_type_param.csv.gz" )
.input func_type_nparams(IO="file", delimiter="\t", filename= "func_type_nparams.csv.gz" )



.input pointer_type(IO="file", delimiter="\t", filename= "pointer_type.csv.gz" )
.input pointer_type_has_component(IO="file", delimiter="\t", filename= "pointer_type_has_component.csv.gz" )
.input pointer_type_has_addr_space(IO="file", delimiter="\t", filename= "pointer_type_has_addr_space.csv.gz" )



.input vector_type(IO="file", delimiter="\t", filename= "vector_type.csv.gz" )
.input vector_type_has_component(IO="file", delimiter="\t", filename= "vector_type_has_component.csv.gz" )
.input vector_type_has_size(IO="file", delimiter="\t", filename= "vector_type_has_size.csv.gz" )



.input array_type(IO="file", delimiter="\t", filename= "array_type.csv.gz" )
.input array_type_has_component(IO="file", delimiter="\t", filename= "array_type_has_component.csv.gz" )
.input array_type_has_size(IO="file", delimiter="\t", filename= "array_type_has_size.csv.gz" )



.input struct_type(IO="file", delimiter="\t", filename= "struct_type.csv.gz" )
.input struct_type_field(IO="file", delimiter="\t", filename= "struct_type_field.csv.gz" )
.input struct_type_field_offset(IO="file", delimiter="\t", filename= "struct_type_field_offset.csv.gz" )
.input struct_type_field_bit_offset(IO="file", delimiter="\t", filename= "struct_type_field_bit_offset.csv.gz" )
.input struct_type_nfields(IO="file", delimiter="\t", filename= "struct_type_nfields.csv.gz" )
.input opaque_struct_type(IO="file", delimiter="\t", filename= "opaque_struct_type.csv.gz" )
.input struct_type_has_name(IO="file", delimiter="\t", filename= "struct_type_has_name.csv.gz" )





.input variable(IO="file", delimiter="\t", filename= "variable.csv.gz" )
.input variable_has_type(IO="file", delimiter="\t", filename= "variable_has_type.csv.gz" )
.input variable_has_debug_source_name(IO="file", delimiter="\t", filename= "variable_has_debug_source_name.csv.gz" )
.input variable_has_debug_decl_pos(IO="file", delimiter="\t", filename= "variable_has_debug_decl_pos.csv.gz" )
.input variable_in_func_name(IO="file", delimiter="\t", filename= "variable_in_func_name.csv.gz" )
.input variable_has_name(IO="file", delimiter="\t", filename= "variable_has_name.csv.gz" )



.input constant(IO="file", delimiter="\t", filename= "constant.csv.gz" )
.input constant_has_type(IO="file", delimiter="\t", filename= "constant_has_type.csv.gz" )
.input constant_has_value(IO="file", delimiter="\t", filename= "constant_has_value.csv.gz" )
.input constant_in_func_name(IO="file", delimiter="\t", filename= "constant_in_func_name.csv.gz" )
.input constant_expression(IO="file", delimiter="\t", filename= "constant_expression.csv.gz" )
.input constant_hashes_to(IO="file", delimiter="\t", filename= "constant_hashes_to.csv.gz" )
.input constant_to_int(IO="file", delimiter="\t", filename= "constant_to_int.csv.gz" )





.input integer_constant(IO="file", delimiter="\t", filename= "integer_constant.csv.gz" )



.input fp_constant(IO="file", delimiter="\t", filename= "fp_constant.csv.gz" )



.input nullptr_constant(IO="file", delimiter="\t", filename= "nullptr_constant.csv.gz" )



.input func_constant(IO="file", delimiter="\t", filename= "func_constant.csv.gz" )
.input func_constant_fn_name(IO="file", delimiter="\t", filename= "func_constant_fn_name.csv.gz" )



.input global_var_constant(IO="file", delimiter="\t", filename= "global_var_constant.csv.gz" )
.input global_var_constant_name(IO="file", delimiter="\t", filename= "global_var_constant_name.csv.gz" )



.input constant_array(IO="file", delimiter="\t", filename= "constant_array.csv.gz" )
.input constant_array_index(IO="file", delimiter="\t", filename= "constant_array_index.csv.gz" )
.input constant_array_has_size(IO="file", delimiter="\t", filename= "constant_array_has_size.csv.gz" )



.input constant_struct(IO="file", delimiter="\t", filename= "constant_struct.csv.gz" )
.input constant_struct_index(IO="file", delimiter="\t", filename= "constant_struct_index.csv.gz" )
.input constant_struct_has_size(IO="file", delimiter="\t", filename= "constant_struct_has_size.csv.gz" )



.input constant_vector(IO="file", delimiter="\t", filename= "constant_vector.csv.gz" )
.input constant_vector_index(IO="file", delimiter="\t", filename= "constant_vector_index.csv.gz" )
.input constant_vector_has_size(IO="file", delimiter="\t", filename= "constant_vector_has_size.csv.gz" )



.input constant_expression(IO="file", delimiter="\t", filename= "constant_expression.csv.gz" )



.input bitcast_constant_expression(IO="file", delimiter="\t", filename= "bitcast_constant_expression.csv.gz" )
.input bitcast_constant_expression_from(IO="file", delimiter="\t", filename= "bitcast_constant_expression_from.csv.gz" )



.input inttoptr_constant_expression(IO="file", delimiter="\t", filename= "inttoptr_constant_expression.csv.gz" )
.input inttoptr_constant_expression_from(IO="file", delimiter="\t", filename= "inttoptr_constant_expression_from.csv.gz" )



.input ptrtoint_constant_expression(IO="file", delimiter="\t", filename= "ptrtoint_constant_expression.csv.gz" )
.input ptrtoint_constant_expression_from(IO="file", delimiter="\t", filename= "ptrtoint_constant_expression_from.csv.gz" )



.input getelementptr_constant_expression(IO="file", delimiter="\t", filename= "getelementptr_constant_expression.csv.gz" )
.input getelementptr_constant_expression_base(IO="file", delimiter="\t", filename= "getelementptr_constant_expression_base.csv.gz" )
.input getelementptr_constant_expression_index(IO="file", delimiter="\t", filename= "getelementptr_constant_expression_index.csv.gz" )
.input getelementptr_constant_expression_nindices(IO="file", delimiter="\t", filename= "getelementptr_constant_expression_nindices.csv.gz" )



.input undef_constant(IO="file", delimiter="\t", filename= "undef_constant.csv.gz" )



.input poison_constant(IO="file", delimiter="\t", filename= "poison_constant.csv.gz" )





.input inline_asm(IO="file", delimiter="\t", filename= "inline_asm.csv.gz" )
.input inline_asm_text(IO="file", delimiter="\t", filename= "inline_asm_text.csv.gz" )
.input inline_asm_constraints(IO="file", delimiter="\t", filename= "inline_asm_constraints.csv.gz" )





.input target_dependent_attr(IO="file", delimiter="\t", filename= "target_dependent_attr.csv.gz" )





.input signature_none (IO="file", delimiter="\t", filename= "signature_none.csv.gz" )
.input signature_return_alloc (IO="file", delimiter="\t", filename= "signature_return_alloc.csv.gz" )
.input signature_return_alloc_once (IO="file", delimiter="\t", filename= "signature_return_alloc_once.csv.gz" )
.input signature_return_aliases_arg (IO="file", delimiter="\t", filename= "signature_return_aliases_arg.csv.gz" )
.input signature_return_aliases_arg_reachable (IO="file", delimiter="\t", filename= "signature_return_aliases_arg_reachable.csv.gz" )
.input signature_return_points_to_global (IO="file", delimiter="\t", filename= "signature_return_points_to_global.csv.gz" )
.input signature_return_aliases_global (IO="file", delimiter="\t", filename= "signature_return_aliases_global.csv.gz" )
.input signature_return_aliases_global_reachable (IO="file", delimiter="\t", filename= "signature_return_aliases_global_reachable.csv.gz" )
.input signature_arg_alloc (IO="file", delimiter="\t", filename= "signature_arg_alloc.csv.gz" )
.input signature_arg_alloc_once (IO="file", delimiter="\t", filename= "signature_arg_alloc_once.csv.gz" )
.input signature_arg_memcpy_arg (IO="file", delimiter="\t", filename= "signature_arg_memcpy_arg.csv.gz" )
.input signature_arg_memcpy_arg_reachable (IO="file", delimiter="\t", filename= "signature_arg_memcpy_arg_reachable.csv.gz" )
.input signature_arg_points_to_global (IO="file", delimiter="\t", filename= "signature_arg_points_to_global.csv.gz" )
.input signature_arg_memcpy_global (IO="file", delimiter="\t", filename= "signature_arg_memcpy_global.csv.gz" )
.input signature_arg_memcpy_global_reachable (IO="file", delimiter="\t", filename= "signature_arg_memcpy_global_reachable.csv.gz" )
.input signature_global_memcpy_arg (IO="file", delimiter="\t", filename= "signature_global_memcpy_arg.csv.gz" )
.input signature_global_memcpy_arg_reachable (IO="file", delimiter="\t", filename= "signature_global_memcpy_arg_reachable.csv.gz" )




.input user_options(IO="file", delimiter="\t", filename= "user_options.csv.gz" )

#line 12 "import.dl"
#line 2 "import.dl"
#line 3 "common.project"
#line 1 "symbol-lookup/symbol-lookup.project"
#line 1 "resolve-func-calls.dl"
#line 26 "resolve-func-calls.dl"
.decl constant_references_func(c:Constant, f:FunctionDecl)
.decl constant_references_variable(c:Constant, v:GlobalVariable)


constant_references_func(FC, Func) :-
  func_constant(FC),
  func_constant_fn_name(FC, FuncName),
  func_name(Func, FuncName).


constant_references_variable(GC, GVar) :-
  global_var_constant(GC),
  global_var_constant_name(GC, Name),
  global_var_name(GVar, Name).




constant_references_func(Outer, Func) :-
   bitcast_constant_expression_from(Outer, Inner),
   constant_references_func(Inner, Func).

constant_references_variable(Outer, GVar) :-
   bitcast_constant_expression_from(Outer, Inner),
   constant_references_variable(Inner, GVar).







.decl aliased_constants(c1:Constant, c2:Constant)
.decl _alias(c:Constant, a:Alias)
.decl _aliasee(c:Constant, a:Alias)


_aliasee(Constant, Alias) :-
   alias_aliasee(Alias, Aliasee),
   constant_has_value(Aliasee, Value),
   constant_has_value(Constant, Value).


_alias(Constant, Alias) :-
   constant_has_value(Constant, AliasName),
   alias_name(Alias, AliasName).


aliased_constants(OtherConstant, Constant) :-
   _alias(OtherConstant, Alias),
   _aliasee(Constant, Alias).

constant_references_func(OtherConstant, Func) :-
   aliased_constants(OtherConstant, Constant),
   constant_references_func(Constant, Func).

constant_references_variable(OtherConstant, GVar) :-
   aliased_constants(OtherConstant, Constant),
   constant_references_variable(Constant, GVar).






.decl _instr_calls_func(instr:Instruction, target:FunctionDecl)

_instr_calls_func(Instr, Func) :-
   direct_call_instr(Instr),
   call_instr_func_operand(Instr, FunctionConstant),
   constant(FunctionConstant),
   constant_references_func(FunctionConstant, Func).

_instr_calls_func(Instr, Func) :-
   direct_invoke_instr(Instr),
   invoke_instr_func_operand(Instr, FunctionConstant),
   constant(FunctionConstant),
   constant_references_func(FunctionConstant, Func).



schema_invalid_instr(Instr,  "resolve-func-calls.dl" ,  107 ) :-
   schema_sanity(),
   direct_call_instr(Instr),
   !call_instr_fn_target(Instr, _).

schema_invalid_instr(Instr,  "resolve-func-calls.dl" ,  112 ) :-
   schema_sanity(),
   direct_invoke_instr(Instr),
   !invoke_instr_fn_target(Instr, _).
#line 129 "resolve-func-calls.dl"
.decl func_decl_to_defn(fdecl:FunctionDecl, func:Function)

func_decl_to_defn(Func, Func) :-
   func(Func).




call_instr_fn_target(Instr, Func) :-
   call_instr(Instr),
   _instr_calls_func(Instr, SomeFunc),
   func_decl_to_defn(SomeFunc, Func).

call_instr_fn_target(Instr, SomeFunc) :-
   call_instr(Instr),
   _instr_calls_func(Instr, SomeFunc),
   !func_decl_to_defn(SomeFunc, _).

invoke_instr_fn_target(Instr, Func) :-
   invoke_instr(Instr),
   _instr_calls_func(Instr, SomeFunc),
   func_decl_to_defn(SomeFunc, Func).

invoke_instr_fn_target(Instr, SomeFunc) :-
   invoke_instr(Instr),
   _instr_calls_func(Instr, SomeFunc),
   !func_decl_to_defn(SomeFunc, _).
#line 2 "symbol-lookup/symbol-lookup.project"
#line 4 "common.project"
#line 1 "callgraph/callgraph.project"
#line 1 "entry-points.dl"

.decl entry_point(func:FunctionDecl)




entry_point(Func) :-
   main_func(Func)
 ; called_at_startup(Func).





.decl main_func(func:Function)

main_func(MainFn) :-
   func_name(MainFn, "@main"),
   func(MainFn).


.decl argv_alloc(alloc: BasicAllocation)
argv_alloc("*argv-alloc").
basic_allocation(argvAlloc) :- argv_alloc(argvAlloc).
dynamically_sized_alloc(argvAlloc) :- argv_alloc(argvAlloc).



static_allocation_type(argvAlloc, i8PtrPtrType) :-
  int8_type(i8),
  argv_alloc(argvAlloc),
  pointer_type_has_component(i8PtrType, i8),
  pointer_type_has_component(i8PtrPtrType, i8PtrType).

.decl argv_ptr_points_to(from: Allocation, to: Allocation)


basic_allocation(newAlloc),
static_allocation_type(newAlloc, i8PtrType),
argv_ptr_points_to(subAlloc, newAlloc),
dynamically_sized_alloc(newAlloc)
  :-
  argv_alloc(argvAlloc),
  static_subobjects.alloc_subregion_at_array_index(argvAlloc, index, subAlloc),
  int8_type(i8),
  pointer_type_has_component(i8PtrType, i8),
  newAlloc = cat(cat("*argv[", to_string(index)), "]-alloc").

.decl argv_var_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable)
argv_var_points_to(aCtx, argvAlloc, mainCtx, argvVar) :-
  main_func(main),
  argv_alloc(argvAlloc),
  func_param(main, 1, argvVar),
  empty_alloc_context(aCtx),
  main_context(mainCtx).






.decl called_at_startup(func:FunctionDecl)

called_at_startup(StartupFn) :-
   func_section(StartupFn, ".text.startup").
#line 2 "callgraph/callgraph.project"
#line 5 "common.project"
#line 1 "points-to/points-to.project"
#line 1 "allocations-decl.dl"




.type StackAllocation <: symbol
.type HeapAllocation <: symbol
.type GlobalAllocation <: symbol
.type SignatureAllocation <: symbol
.type BasicAllocation
  = GlobalAllocation
  | HeapAllocation
  | StackAllocation
  | SignatureAllocation
.type Allocation = BasicAllocation | AllocSubregion | NonAllocation

.decl allocation(?alloc:Allocation)
.decl basic_allocation(?basicAlloc:BasicAllocation)
.decl stack_allocation(?stackAlloc:StackAllocation)
.decl heap_allocation(?heapAlloc:HeapAllocation)
.decl global_allocation(?globalAlloc:GlobalAllocation)
.decl signature_allocation(?sigAlloc:SignatureAllocation)

allocation(?alloc) :-
  basic_allocation(?alloc).

basic_allocation(?alloc) :-
  stack_allocation(?alloc);
  heap_allocation(?alloc);
  global_allocation(?alloc);
  signature_allocation(?alloc).



.decl stack_allocation_by_instr(?insn:AllocaInstruction, ?stackAlloc:StackAllocation)
.decl stack_allocation_by_type_instr(?type:Type, ?insn:AllocaInstruction, ?stackAlloc:StackAllocation)
.decl stack_allocation_by_parameter(?func:FunctionDecl, ?index:number, ?stackAlloc:StackAllocation)

.decl heap_allocation_by_instr(?insn:CallBase, ?heapAlloc:HeapAllocation)
.decl heap_allocation_by_type_instr(?type:Type, ?insn:CallBase, ?heapAlloc:HeapAllocation)

.decl global_allocation_by_func(?func:FunctionDecl, ?globalAlloc:GlobalAllocation)
.decl global_allocation_by_variable(?var:GlobalVariable, ?globalAlloc:GlobalAllocation)
.decl global_allocation_by_name(?global:GlobalName, ?globalAlloc:GlobalAllocation)

.decl heap_alloc_func(?func:Function)
heap_alloc_func(?func) :-
   func_name(?func, "@malloc")
 ; func_name(?func, "@calloc")
 ; func_name(?func, "@realloc")
 ; func_name(?func, "@mmap").

.decl heap_allocation_by_malloc(?insn:CallInstruction, ?heapAlloc:HeapAllocation)
.decl heap_allocation_by_calloc(?insn:CallInstruction, ?heapAlloc:HeapAllocation)
.decl heap_allocation_by_realloc(?insn:CallInstruction, ?heapAlloc:HeapAllocation)
.decl heap_allocation_by_mmap(?insn:CallInstruction, ?heapAlloc:HeapAllocation)





.type AllocInstruction = CallBase | AllocaInstruction
.decl allocation_by_instr(?insn:AllocInstruction, ?alloc:Allocation)

allocation_by_instr(?insn, ?alloc) :-
  heap_allocation_by_instr(?insn, ?alloc).

allocation_by_instr(?insn, ?alloc) :-
  stack_allocation_by_instr(?insn, ?alloc).








.decl ptr_compatible_allocation(?alloc:Allocation)



ptr_compatible_allocation(?alloc) :-
   stack_allocation(?alloc)
 ; heap_allocation(?alloc)
 ; signature_allocation(?alloc).




ptr_compatible_allocation(?alloc) :-
   global_allocation_by_variable(?globalVar,?alloc),
   ! global_var_constant(?globalVar).





.type NonAllocation
  = NullAllocation
  | UnknownAllocation

.type NullAllocation <: symbol
.type UnknownAllocation <: symbol

.decl non_allocation(?alloc:NonAllocation)
.decl unknown_location(?alloc:UnknownAllocation)
.decl null_location(?alloc:NullAllocation)

non_allocation(?alloc) :-
   unknown_location(?alloc)
 ; null_location(?alloc).

unknown_location("*unknown*").

null_location("*null*").






.decl static_allocation_type(?alloc:Allocation, ?type:Type)


.decl allocation_size(?alloc: Allocation, ?size: Bytes)


.decl array_allocation(?alloc:Allocation)


.decl allocation_pos(?alloc:Allocation, ?line:LineNumber , ?column:ColumnNumber)
#line 2 "points-to/points-to.project"
#line 1 "allocations.dl"
.decl build_stack_allocation(stackAlloc: StackAllocation, func: Function, type: Type, var: Variable) inline
build_stack_allocation(stackAlloc, func, type, var) :-
  func_name(func, funcName),
  variable_has_name(var, varName),
  stackAlloc = cat("*stack_alloc", funcName, "[", type, " ", varName, "]").

.decl build_heap_allocation(heapAlloc: HeapAllocation, func: Function, type: Type, var: Variable) inline
build_heap_allocation(heapAlloc, func, type, var) :-
  func_name(func, funcName),
  variable_has_name(var, varName),
  heapAlloc = cat("*heap_alloc", funcName, "[", type, " ", varName, "]").






.decl any_reachable_func(?func: FunctionDecl) inline







stack_allocation(?stackAlloc),
 stack_allocation_by_instr(?instr, ?stackAlloc)
 :-
   alloca_instr(?instr),
   instr_assigns_to(?instr, ?var),
   instr_func(?instr, ?instrFunc),
   variable_has_type(?var,?type),
   any_reachable_func(?instrFunc),
   build_stack_allocation(?stackAlloc, ?instrFunc, ?type, ?var).

static_allocation_type(?stackAlloc, ?type) :-
   alloca_instr(?instr),
   alloca_instr_type(?instr,?type),
   stack_allocation_by_instr(?instr, ?stackAlloc).



stack_allocation(?stackAlloc),
 stack_allocation_by_parameter(?func, ?index, ?stackAlloc)
 :-
   func_param_by_value(?func, ?index),
   func_param(?func, ?index, ?param),
   variable_has_type(?param, ?type),
   any_reachable_func(?func),
   build_stack_allocation(?stackAlloc, ?func, ?type, ?param).

static_allocation_type(?stackAlloc, ?type) :-
   stack_allocation_by_parameter(?func, ?index, ?stackAlloc),
   func_ty(?func, ?funcType),
   func_type_param(?funcType, ?index, ?paramType),
   pointer_type_has_component(?paramType, ?type).








heap_allocation(?heapAlloc),
heap_allocation_by_instr(?instr, ?heapAlloc),
static_allocation_type(?heapAlloc, ?elementType)
 :-
   heap_alloc_func(?func),
   ( call_instr_fn_target(?instr, ?func)
   ; invoke_instr_fn_target(?instr, ?func)),
   instr_assigns_to(?instr, ?var),
   instr_func(?instr, ?instrFunc),

   variable_has_type(?var, ?type),
   pointer_type_has_component(?type, ?elementType),

   any_reachable_func(?instrFunc),
   build_heap_allocation(?heapAlloc, ?instrFunc, ?type, ?var).

heap_allocation(?heapAlloc),
heap_allocation_by_malloc(?insn, ?heapAlloc) :-
  func_name(?func, "@malloc"),
  call_instr_fn_target(?insn, ?func),
  heap_allocation_by_instr(?insn, ?heapAlloc).

heap_allocation(?heapAlloc),
heap_allocation_by_calloc(?insn, ?heapAlloc) :-
  func_name(?func, "@calloc"),
  call_instr_fn_target(?insn, ?func),
  heap_allocation_by_instr(?insn, ?heapAlloc).

heap_allocation(?heapAlloc),
heap_allocation_by_realloc(?insn, ?heapAlloc) :-
  func_name(?func, "@realloc"),
  call_instr_fn_target(?insn, ?func),
  heap_allocation_by_instr(?insn, ?heapAlloc).

heap_allocation(?heapAlloc),
heap_allocation_by_mmap(?insn, ?heapAlloc) :-
  func_name(?func, "@mmap"),
  call_instr_fn_target(?insn, ?func),
  heap_allocation_by_instr(?insn, ?heapAlloc).

.comp Allocations {






  .decl reachable_context(?ctx: Context, ?func: FunctionDecl) inline
  .decl alloc_subregion_base(?region: AllocSubregion, ?base: Allocation) inline








  .decl allocated_at(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable)
  .decl alloc_with_ctx(?aCtx: Context, ?alloc: Allocation)

  alloc_with_ctx(?aCtx, ?alloc) :- allocated_at(?aCtx, ?alloc, _, _).
  alloc_with_ctx(?aCtx, ?alloc) :-
    alloc_with_ctx(?aCtx, ?base),
    alloc_subregion_base(?alloc, ?base).

  alloc_with_ctx(?aCtx, ?alloc)
  :- empty_alloc_context(?aCtx),
     global_allocation(?alloc).

  alloc_with_ctx(?aCtx, ?alloc)
  :- empty_alloc_context(?aCtx),
     non_allocation(?alloc).

  alloc_with_ctx(?aCtx, ?alloc)
  :- argv_var_points_to(?aCtx, ?alloc, _, _).

  alloc_with_ctx(?aCtx, ?alloc)
  :- empty_alloc_context(?aCtx),
     argv_ptr_points_to(_, ?alloc).

  allocated_at(?newCtx, ?stackAlloc, ?ctx, ?var)
  :-
    stack_allocation_by_instr(?instr, ?stackAlloc),
    instr_assigns_to(?instr, ?var),
    instr_func(?instr, ?instrFunc),
    reachable_context(?ctx, ?instrFunc),
    record(?newCtx, ?stackAlloc, ?ctx).

  allocated_at(?newCtx, ?stackAlloc, ?ctx, ?param)
  :-
    stack_allocation_by_parameter(?func, ?index, ?stackAlloc),
    func_param_by_value(?func, ?index),
    func_param(?func, ?index, ?param),
    reachable_context(?ctx, ?func),
    record(?newCtx, ?stackAlloc, ?ctx).

  allocated_at(?newCtx, ?heapAlloc, ?ctx, ?var)
  :-
    heap_allocation_by_instr(?instr, ?heapAlloc),
    instr_assigns_to(?instr, ?var),
    instr_func(?instr, ?instrFunc),
    reachable_context(?ctx, ?instrFunc),
    record(?newCtx, ?heapAlloc, ?ctx).
}





allocation_pos(?alloc, ?line, ?column) :-
   (stack_allocation_by_instr(?insn, ?alloc);
   heap_allocation_by_instr(?insn, ?alloc)),
   instr_pos(?insn, ?line, ?column).

allocation_pos(?alloc, ?line, ?column) :-
   stack_allocation_by_parameter(?func, ?index, ?alloc),
   func_param(?func, ?index, ?param),
   variable_has_debug_decl_pos(?param, ?line, ?column).
#line 3 "points-to/points-to.project"
#line 1 "allocations-globals.dl"








global_allocation(?alloc),
global_allocation_by_variable(?gVar, ?alloc)
 :-
   global_var(?gVar),
   global_var_name(?gVar, ?name),
   ?alloc = cat("*global_alloc",?name).


global_allocation(?alloc),
global_allocation_by_func(?func, ?alloc)
 :-
   (func(?func);
   func_decl(?func),
   !func_decl_to_defn(?func,_)),

   func_name(?func, ?name),
   ?alloc = cat("*global_alloc",?name).

global_allocation_by_name(?globalName, ?alloc) :-
   global_var_name(?global, ?globalName),
   global_allocation_by_variable(?global, ?alloc).

global_allocation_by_name(?globalName, ?alloc) :-
   func_name(?global, ?globalName),
   global_allocation_by_func(?global, ?alloc).

static_allocation_type(?alloc, ?type) :-
   global_allocation_by_func(?func, ?alloc),
   func_ty(?func, ?type).

static_allocation_type(?alloc, ?type) :-
   global_allocation_by_variable(?gVar, ?alloc),
   global_var_type(?gVar, ?type).
#line 4 "points-to/points-to.project"
#line 1 "allocations-sizes.dl"






array_allocation(?alloc) :-
   static_allocation_type(?alloc, ?type),
   array_type(?type).





allocation_size(?globalAlloc, ?n) :-
  global_allocation_by_variable(?globalVar, ?globalAlloc),
  global_var_linkage(?globalVar, ?linkage),
  ! external_linkage_type(?linkage),
  static_allocation_type(?globalAlloc, ?type),
  type_has_size(?type, ?n),
  ! typeinfo_vtable(?globalVar, _).


dynamically_sized_alloc(?alloc) :-
  external_linkage_type(?externalLinkage),
  global_var_linkage(?globalVar, ?externalLinkage),
  global_allocation_by_variable(?globalVar, ?alloc).








array_allocation(?stackAlloc) :-
   alloca_instr_size(?insn, _),
   stack_allocation_by_instr(?insn, ?stackAlloc).





dynamically_sized_alloc(?stackAlloc) :-
  alloca_instr_size(?insn, ?operand),
  stack_allocation_by_instr(?insn, ?stackAlloc),
  ! constant_to_int(?operand, _).

allocation_size(?stackAlloc, ?n) :-
   alloca_instr_size(?insn, ?operand),
   constant_to_int(?operand, numElements),
   stack_allocation_by_instr(?insn, ?stackAlloc),
   static_allocation_type(?stackAlloc, ?type),
   type_has_size(?type, size),
   ?n = (numElements)*(size).

allocation_size(?stackAlloc, ?size) :-
   alloca_instr(?insn),
   !alloca_instr_size(?insn, _),
   stack_allocation_by_instr(?insn, ?stackAlloc),
   static_allocation_type(?stackAlloc, ?type),
   type_has_size(?type, ?size).

allocation_size(?stackAlloc, ?size) :-
   stack_allocation_by_parameter(_, _, ?stackAlloc),
   static_allocation_type(?stackAlloc, ?type),
   type_has_size(?type, ?size).





.decl dynamically_sized_alloc(?alloc: Allocation)

array_allocation(?heapAlloc),
  dynamically_sized_alloc(?heapAlloc)
  :-
  heap_allocation_by_instr(?insn, ?heapAlloc),
  ! sized_alloc_instr(?insn, _).



allocation_size(?heapAlloc, ?size) :-
   heap_allocation_by_instr(?insn, ?heapAlloc),
   sized_alloc_instr(?insn, ?size).




.decl sized_alloc_instr(?insn: Instruction, ?size: Bytes)

sized_alloc_instr(?insn, as(?size, Bytes)) :-
   func_name(?func, "@malloc"),
   call_instr_fn_target(?insn, ?func),
   call_instr_arg(?insn, 0, ?operand),
   constant_to_int(?operand, ?size).

sized_alloc_instr(?insn, as(?size, Bytes)) :-
   func_name(?func, "@malloc"),
   invoke_instr_fn_target(?insn, ?func),
   invoke_instr_arg(?insn, 0, ?operand),
   constant_to_int(?operand, ?size).

sized_alloc_instr(?insn, as(?size, Bytes)) :-
   func_name(?func, "@realloc"),
   invoke_instr_fn_target(?insn, ?func),
   invoke_instr_arg(?insn, 1, ?operand),
   constant_to_int(?operand, ?size).

sized_alloc_instr(?insn, as(?size, Bytes)) :-
   func_name(?func, "@realloc"),
   call_instr_fn_target(?insn, ?func),
   call_instr_arg(?insn, 1, ?operand),
   constant_to_int(?operand, ?size).

sized_alloc_instr(?insn, as(n, Bytes)) :-
   func_name(?func, "@calloc"),
   invoke_instr_fn_target(?insn, ?func),
   invoke_instr_arg(?insn, 0, ?nmembOp),
   invoke_instr_arg(?insn, 1, ?sizeOp),
   constant_to_int(?nmembOp, nmemb),
   constant_to_int(?sizeOp, size),
   n = size * nmemb.

sized_alloc_instr(?insn, as(n, Bytes)) :-
   func_name(?func, "@calloc"),
   call_instr_fn_target(?insn, ?func),
   call_instr_arg(?insn, 0, ?nmembOp),
   call_instr_arg(?insn, 1, ?sizeOp),
   constant_to_int(?nmembOp, nmemb),
   constant_to_int(?sizeOp, size),
   n = size * nmemb.





allocation_size(?alloc, ?size) :-
   stack_allocation_by_instr(?insn, ?stackAlloc),
   allocation_size(?stackAlloc, ?size),
   stack_allocation_by_type_instr(_, ?insn, ?alloc).

allocation_size(?alloc, ?size) :-
   heap_allocation_by_instr(?insn, ?heapAlloc),
   allocation_size(?heapAlloc, ?size),
   heap_allocation_by_type_instr(_, ?insn, ?alloc).

dynamically_sized_alloc(?alloc) :-
  stack_allocation_by_instr(?insn, ?stackAlloc),
  dynamically_sized_alloc(?stackAlloc),
  stack_allocation_by_type_instr(_, ?insn, ?alloc).

dynamically_sized_alloc(?alloc) :-
  heap_allocation_by_instr(?insn, ?heapAlloc),
  dynamically_sized_alloc(?heapAlloc),
  heap_allocation_by_type_instr(_, ?insn, ?alloc).
#line 5 "points-to/points-to.project"
#line 1 "allocations-type.dl"
.comp AllocationType {






  .decl alloc_subregion_type(?region: AllocSubregion, ?type: Type) inline
  .decl backpropagated_allocation_type(?alloc: Allocation, ?type: Type) inline
  .decl sig_allocation_type(?alloc: Allocation, ?type: Type) inline
  .decl is_init_by_ctor(?type: ClassType, ?ctor: FunctionDecl, ?inFunction: Function, ?alloc: Allocation) inline
  .decl heap_allocation_by_alloc_exc(?insn: Instruction, ?heapAlloc: HeapAllocation) inline





  .decl allocation_type(?alloc:Allocation, ?type:Type)

  allocation_type(?alloc, ?type) :-
    static_allocation_type(?alloc, ?type).

  allocation_type(?alloc, ?type) :-
    alloc_subregion_type(?alloc, ?type).

  allocation_type(?alloc, ?type) :-
    backpropagated_allocation_type(?alloc, ?type).

  allocation_type(?alloc, ?type) :-
    sig_allocation_type(?alloc, ?type).







  allocation_type(?heapAlloc, ?type) :-
    !inlined_constructors(),
    instr_func(?allocInsn, ?inFunction),
    heap_allocation_by_new(?allocInsn, ?heapAlloc),
    allocation_size(?heapAlloc, ?size),
    type_has_size(?type, ?size),
    is_init_by_ctor(?type, _, ?inFunction, ?heapAlloc).

  allocation_type(?excObj, ?type) :-
    !inlined_constructors(),
    instr_func(?allocInsn, ?inFunction),
    heap_allocation_by_alloc_exc(?allocInsn, ?excObj),
    allocation_size(?excObj, ?size),
    type_has_size(?type, ?size),
    is_init_by_ctor(?type, _, ?inFunction, ?excObj).
}
#line 6 "points-to/points-to.project"
#line 1 "allocations-subobjects.dl"
#line 39 "allocations-subobjects.dl"
.decl _alloc_region(?region: Region)
_alloc_region(?r) :- global_region(?r).
_alloc_region(?r) :- heap_region(?r).
_alloc_region(?r) :- stack_region(?r).

.decl pointer_index(?region: Region, ?type: Type, ?index: ArrayIndex)

pointer_index(?region, ?type, 0) :-
  _alloc_region(?region),
  type(?type).


pointer_index(?region, ?type, ?finalIdx) :-
  ( ( getelementptr_instr_index(?insn, 0, ?indexOp)
    , constant_to_int(?indexOp, ?index)
    , getelementptr_instr_base_type(?insn, ?declaredType)
    , _alloc_region(?region)
    )
  ; ( getelementptr_constant_expression_index(?expr, 0, ?indexOp)
    , constant_to_int(?indexOp, ?index)
    , _getelementptr_constant_expression_base_type(?expr, ?declaredType)
    , global_region(?region)
    )
  ),
  ?index >= 0,

  pointer_type_has_component(?declaredType, ?declaredElemType),
  ( ( type_compatible(?type, ?declaredElemType)
    , type_has_size(?type, ?size)
    )
  ;



    ( pointer_type_has_component(?ptrType, ?type)
    , type_compatible(?ptrType, ?declaredType)
    , type_has_size(?type, ?size)
    )
  ),

  ?size > 0,
  type_has_size(?declaredElemType, ?declaredSize),

  ?finalIdx = (?index * ?declaredSize) / max(?size, 1),

  (?finalIdx * ?size) = (?index * ?declaredSize).

.decl pointer_offset(?region: Region, ?type: Type, ?offset: SubregionOffset)


pointer_offset(?region, ?type, 0) :-
  pointer_index(?region, ?type, 0).

pointer_offset(?region, ?type, ?index * ?size) :-
  pointer_index(?region, ?type, ?index),
  type_has_size(?type, ?size).



.decl array_indices__no_typecomp(?region: Region, ?type: ArrayType, ?index: ArrayIndex)

array_indices__no_typecomp(?region, ?declaredType, as(?constantIndex, ArrayIndex)) :-
   ( ( getelementptr_instr_index(?insn, ?index, ?indexOp)
     , getelementptr_instrterm_type(?insn, ?index, ?declaredType)
     , _alloc_region(?region)
     )
   ; ( getelementptr_constant_expression_index(?expr, ?index, ?indexOp)
     , _getelementptr_constant_expression_interm_type(?expr, ?index, ?declaredType)
     , global_region(?region)
     )
   ),
   constant_to_int(?indexOp, ?constantIndex),
   array_type(?declaredType).



.decl array_indices(?region: Region, ?type: ArrayType, ?index: ArrayIndex)

array_indices(?region, ?type, ?constantIndex) :-
  array_type(?type),
  type_contains_pointer(?type),
  type_compatible(?type, ?declaredType),
  array_indices__no_typecomp(?region, ?declaredType, ?constantIndex).

.decl array_offset(?region: Region, ?type: Type, ?offset: SubregionOffset)
array_offset(?region, ?type, ?index * ?size) :-
  array_indices(?region, ?type, ?index),
  array_type_has_component(?type, ?elemType),
  type_has_size(?elemType, ?size).
#line 140 "allocations-subobjects.dl"
.type PathComponent
  = EmptyPathComponent
  | FieldPathComponent
  | ArrayPathComponent

.type EmptyPathComponent <: symbol
.type FieldPathComponent <: symbol

.type ArrayPathComponent
  = ArrayIndexPathComponent
  | AnyArrayIndexPathComponent

.type ArrayIndexPathComponent <: symbol
.type AnyArrayIndexPathComponent <: symbol

.decl path_component(?component: PathComponent)
.decl empty_path_component(?component: EmptyPathComponent)
.decl empty_path(?path: Path)
.decl path_component_at_field(?component: FieldPathComponent, ?field: FieldIndex)
.decl path_component_at_index(?component: ArrayIndexPathComponent, ?index: ArrayIndex)
.decl path_component_at_any_index(?component: AnyArrayIndexPathComponent)
empty_path_component("").
empty_path("").
path_component_at_any_index("[*]").

path_component(?component) :- empty_path_component(?component).
path_component(?component) :- path_component_at_field(?component, _).
path_component(?component) :- path_component_at_index(?component, _).
path_component(?component) :- path_component_at_any_index(?component).

.type Path <: symbol
.decl path(?path: Path)
.decl split_path(?path: Path, ?head: Path, ?tail: PathComponent)
.decl path_ends_in(?path: Path, ?component: PathComponent)
.decl component_to_path(?component: PathComponent, ?path: Path) inline


path(as(?component, Path))
, component_to_path(?component, as(?component, Path))
, path_ends_in(as(?component, Path), ?component)
:-
  path_component(?component).

split_path(?path, ?pathHead, ?component) :-
  component_to_path(?component, ?path),
  empty_path_component(?empty),
  component_to_path(?empty, ?pathHead).

path_ends_in(?path, ?component) :- split_path(?path, _, ?component).

.decl path_ends_in_array_index(?path: Path)
path_ends_in_array_index(?path) :-
  path_ends_in(?path, ?component),
  path_component_at_index(?component, _).



.decl not_array_index(?component: PathComponent)
not_array_index(?component) :- empty_path_component(?component).
not_array_index(?component) :- path_component_at_field(?component, _).
not_array_index(?component) :- path_component_at_any_index(?component).





.type AllocSubregion
  = FieldSubregion
  | ArraySubregion

.type FieldSubregion <: symbol

.type ArraySubregion
  = ArrayIndexSubregion
  | AnyArrayIndexSubregion

.type ArrayIndexSubregion <: symbol
.type AnyArrayIndexSubregion <: symbol

.comp AllocSubobjects {









  .decl allocation_type(?alloc:Allocation, ?type:Type) inline

  .decl input_allocation_size(?alloc: Allocation, ?size: Bytes) inline
#line 250 "allocations-subobjects.dl"
  .decl _alloc_subregion(
    ?region: AllocSubregion,
    ?base: Allocation,
    ?component: PathComponent,
    ?root: BasicAllocation,
    ?path: Path,
    ?type: Type)

  .decl alloc_subregion(?allocSub: AllocSubregion) inline
  alloc_subregion(?region) :-
    _alloc_subregion(?region, _, _, _, _, _).

  .decl alloc_subregion_base(?region: AllocSubregion, ?base: Allocation) inline
  alloc_subregion_base(?region, ?base) :-
    _alloc_subregion(?region, ?base, _, _, _, _).

  .decl alloc_subregion_root(?region: AllocSubregion, ?root: Allocation) inline
  alloc_subregion_root(?region, ?root) :-
    _alloc_subregion(?region, _, _, ?root, _, _).

  .decl alloc_subregion_type(?region: AllocSubregion, ?base: Type) inline
  alloc_subregion_type(?region, ?type) :-
    _alloc_subregion(?region, _, _, _, _, ?type).

  .decl alloc_subregion_at_path_component(?base: Allocation, ?component: PathComponent, ?obj: AllocSubregion) inline
  alloc_subregion_at_path_component(?base, ?component, ?obj) :-
    _alloc_subregion(?obj, ?base, ?component, _, _, _).

  .decl longest_path_to(?root: BasicAllocation, ?path: Path, ?alloc: AllocSubregion) inline
  longest_path_to(?root, ?path, ?region) :-
    _alloc_subregion(?region, _, _, ?root, ?path, _).

  .decl alloc_subregion_at_path(?base: Allocation, ?str: Path, ?obj: Allocation)
  alloc_subregion_at_path(?base, ?path, ?obj) :-
    alloc_subregion_at_path_component(?base, ?component, ?obj),
    component_to_path(?component, ?path).

  allocation(?region) :- alloc_subregion(?region).

  ptr_compatible_allocation(?alloc) :-
    ptr_compatible_allocation(?baseAlloc),
    alloc_subregion_base(?alloc, ?baseAlloc).

  alloc_subregion_at_path(?base, ?path, ?base) :-
    allocation(?base),
    empty_path(?path).

  alloc_subregion_at_path(?root, ?path, ?alloc) :-
    longest_path_to(?root, ?path, ?alloc).

  path(?path) :- longest_path_to(_, ?path, _).

  path_component_at_index(as(?component, ArrayIndexPathComponent), ?idx) :-
    alloc_subregion_at_array_index(?alloc, ?idx, ?subAlloc),
    _alloc_subregion(?subAlloc, ?alloc, ?component, _, _, _).

  path_component_at_field(as(?component, FieldPathComponent), ?field) :-
    alloc_subregion_at_field(?alloc, ?field, ?subAlloc),
    _alloc_subregion(?subAlloc, ?alloc, ?component, _, _, _).

  split_path(?fullPath, ?start, ?end) :-
    longest_path_to(?root, ?start, ?mid),
    _alloc_subregion(_, ?mid, ?end, ?root, ?fullPath, _).



  .decl _non_func_basic_allocation(?alloc: BasicAllocation)
  _non_func_basic_allocation(?alloc) :-
    basic_allocation(?alloc),
    ! global_allocation_by_func(_, ?alloc).







  .decl alloc_subregion_at_field(?alloc: Allocation, ?index: FieldIndex, ?region: FieldSubregion)




  _alloc_subregion(?newAlloc, ?alloc, ?component, ?root, cat(?path, ?component), ?fieldType)
  , alloc_subregion_at_field(?alloc, ?field, ?newAlloc)
  :-
    allocation_type(?alloc, ?type),

    longest_path_to(?root, ?path, ?alloc),

    struct_type(?type),
    struct_type_field(?type, ?field, ?fieldType),
    ?component = cat("/", to_string(?field)),
    ?newAlloc = cat(?alloc, ".?/", to_string(?field)).






  .decl alloc_subregion_at_any_array_index(?alloc: Allocation, ?region: AnyArrayIndexSubregion)




  _alloc_subregion(?newAlloc, ?alloc, ?component, ?alloc, ?path, ?type)
  , alloc_subregion_at_any_array_index(?alloc, ?newAlloc)
  :-
    allocation_type(?alloc, ?type),

    _non_func_basic_allocation(?alloc),
    path_component_at_any_index(?component),
    component_to_path(?component, ?path),
    ?newAlloc=cat(?alloc, ?component).




  _alloc_subregion(?newAlloc, ?alloc, ?component, ?root, cat(?path, ?component), ?elementType)
  , alloc_subregion_at_any_array_index(?alloc, ?newAlloc)
  :-
    allocation_type(?alloc, ?type),
    array_type_has_component(?type, ?elementType),

    longest_path_to(?root, ?path, ?alloc),
    path_component_at_any_index(?component),
    ?newAlloc = cat(?alloc, ?component).





  .decl index_in_bounds(?alloc: Allocation, ?index: ArrayIndex)

  index_in_bounds(?alloc, ?index) :-
    _non_func_basic_allocation(?alloc),
    input_allocation_size(?alloc, ?size),
    allocation_type(?alloc, ?type),
    alloc_region(?alloc, ?region),
    type_has_size(?type, ?elemSize),
    pointer_index(?region, ?type, ?index),



    ?elemSize * ?index < ?size.

  index_in_bounds(?alloc, ?index) :-
    _non_func_basic_allocation(?alloc),
    dynamically_sized_alloc(?alloc),
    allocation_type(?alloc, ?type),
    alloc_region(?alloc, ?region),
    pointer_index(?region, ?type, ?index).

  index_in_bounds(?alloc, ?index) :-
    alloc_subregion(?alloc),
    input_allocation_size(?alloc, ?size),
    allocation_type(?alloc, ?type),
    alloc_region(?alloc, ?region),
    array_type_has_component(?type, ?elementType),
    type_has_size(?elementType, ?elemSize),
    array_indices(?region, ?type, ?index),
    ?elemSize * ?index < ?size.

  index_in_bounds(?alloc, ?index) :-
    alloc_subregion(?alloc),
    dynamically_sized_alloc(?alloc),
    allocation_type(?alloc, ?type),
    alloc_region(?alloc, ?region),
    array_type(?type),
    array_indices(?region, ?type, ?index).



  .decl alloc_subregion_at_array_index(?alloc: Allocation, ?index: ArrayIndex, ?region: ArrayIndexSubregion)




  _alloc_subregion(?newAlloc, ?alloc, ?component, ?alloc, ?component, ?type)
  , alloc_subregion_at_array_index(?alloc, ?index, ?newAlloc)
  :-
    allocation_type(?alloc, ?type),

    _non_func_basic_allocation(?alloc),
    index_in_bounds(?alloc, ?index),
    ?newAlloc= cat(?alloc, "[", to_string(?index), "]"),
    ?component = cat("[", to_string(?index), "]").




  _alloc_subregion(?newAlloc, ?alloc, ?component, ?root, cat(?path, ?component), ?elementType)
  , alloc_subregion_at_array_index(?alloc, ?index, ?newAlloc)
  :-




    longest_path_to(?root, ?path, ?alloc),
    allocation_type(?alloc, ?type),
    array_type_has_component(?type, ?elementType),
    index_in_bounds(?alloc, ?index),
    ?newAlloc = cat(?alloc, "[", to_string(?index), "]"),
    ?component = cat("[", to_string(?index), "]").






  .decl alloc_subregion_offset(?base: Allocation, ?subAlloc: AllocSubregion, ?offset: SubregionOffset)

  alloc_subregion_offset(?base, ?subAlloc, ?offset) :-
    alloc_subregion_at_field(?base, ?field, ?subAlloc),
    allocation_type(?base, ?type),
    struct_type_field_offset(?type, ?field, ?offset).

  alloc_subregion_offset(?base, ?subAlloc, ?idx * ?size) :-
    alloc_subregion_at_array_index(?base, ?idx, ?subAlloc),
    allocation_type(?subAlloc, ?type),
    type_has_size(?type, ?size).







  allocation_size(?subAlloc, ?size) :-
    alloc_subregion_at_array_index(_, _, ?subAlloc),
    allocation_type(?subAlloc, ?type),
    type_has_size(?type, ?size).


  allocation_size(?subAlloc, ?size) :-
    alloc_subregion_at_any_array_index(_, ?subAlloc),
    allocation_type(?subAlloc, ?type),
    type_has_size(?type, ?size).



  allocation_size(?fieldAlloc, ?size) :-
    alloc_subregion_at_field(?base, ?field, ?fieldAlloc),
    alloc_subregion_at_field(?base, ?field + 1, _),
    allocation_type(?fieldAlloc, ?type),
    type_has_size(?type, ?size).


  allocation_size(?subAlloc, ?size - ?offset) :-
    alloc_subregion_at_field(?base, ?field, ?subAlloc),
    allocation_type(?base, ?type),
    struct_type_nfields(?type, ?field + 1),
    allocation_size(?base, ?size),
    struct_type_field_offset(?type, ?field, ?offset).


  dynamically_sized_alloc(?subAlloc) :-
    alloc_subregion_at_field(?base, ?field, ?subAlloc),
    allocation_type(?base, ?type),
    struct_type_nfields(?type, ?field + 1),
    dynamically_sized_alloc(?base).
#line 562 "allocations-subobjects.dl"
}

.init static_subobjects = AllocSubobjects

static_subobjects.allocation_type(?alloc, ?type) :-
  static_allocation_type(?alloc, ?type).

static_allocation_type(?alloc, ?type) :-
  static_subobjects.alloc_subregion_type(?alloc, ?type).
#line 7 "points-to/points-to.project"
#line 1 "assignment.dl"
#line 24 "assignment.dl"
.decl assign_instr(?toVar: Variable, ?value: Operand)

assign_instr(?toVar, ?value) :-
   any_reachable_func(?instrFunc),
   instr_func(?instr, ?instrFunc),
   bitcast_instr_from_operand(?instr, ?value),
   instr_assigns_to(?instr, ?toVar).


assign_instr(?toVar, ?value) :-
   any_reachable_func(?instrFunc),
   instr_func(?instr, ?instrFunc),
   ptrtoint_instr_from_operand(?instr, ?value),
   instr_assigns_to(?instr, ?toVar).



assign_instr(?toVar, ?value) :-
   any_reachable_func(?instrFunc),
   instr_func(?instr, ?instrFunc),
   phi_instr_pair(?instr, _, ?value, _),
   instr_assigns_to(?instr, ?toVar).


assign_instr(?toVar, ?value) :-
   any_reachable_func(?instrFunc),
   instr_func(?instr, ?instrFunc),
   select_instr(?instr),
   ( select_instr_first_operand(?instr, ?value)
   ; select_instr_second_operand(?instr, ?value) ),
   instr_assigns_to(?instr, ?toVar),
   instr_returns_type(?instr, ?type),
   !vector_type(?type).
#line 8 "points-to/points-to.project"
#line 1 "at-exit.dl"
#line 18 "at-exit.dl"
.decl cxx_atexit_func(?func: FunctionDecl)

cxx_atexit_func(?func) :-
   func_name(?func, "@__cxa_atexit"),
   func_ty(?func, ?fType),
   func_type_param(?fType, 0, ?type1),
   func_type_param(?fType, 1, ?type2),
   func_type_param(?fType, 2, ?type3),
   pointer_type_has_component(?type1, ?compType1),
   func_type(?compType1),
   integer_pointer_type(?type2),
   integer_pointer_type(?type3),
   func_type_nparams(?fType, 3).




.comp AtExit {






  .decl alloc_aliases(?alloc1: Allocation, ?alloc2: Allocation) inline
  .decl callgraph_edge(?calleeCtx: Context, ?callee: FunctionDecl, ?callerCtx: Context, ?callerInstr: CallBase) inline
  .decl operand_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?operand: Operand) inline
  .decl reachable_context(?ctx: Context, ?func: FunctionDecl) inline








  .decl _registers_dtor_atexit(?callCtx: Context, ?dtorOperand: Operand, ?recvOperand: Operand)
  _registers_dtor_atexit(?callCtx, ?dtorOperand, ?recvOperand) :-
    cxx_atexit_func(?atExit),
    callgraph_edge(_, ?atExit, ?callCtx, ?callInstr),
    call_instr_arg(?callInstr, 0, ?dtorOperand),
    call_instr_arg(?callInstr, 1, ?recvOperand).





  .decl _registers_atexit(?callerCtx: Context, ?funcOp: Operand)

  _registers_atexit(?callerCtx, ?funcOp) :-
    func_name(?atExit, "@atexit"),
    callgraph_edge(_, ?atExit, ?callerCtx, ?callerInstr),
    actual_arg(?callerInstr, 0, ?funcOp).



  .decl called_at_exit(func:FunctionDecl)

  called_at_exit(?callback) :-
    _registers_atexit(?ctx, ?funcOp),
    operand_points_to(_, ?alloc, ?ctx, ?funcOp),
    func_by_location(?alloc, ?callback).

  called_at_exit(Callback) :-
    func_name(AtExit, "@atexit"),
    callgraph_edge(_, AtExit, _, CallerInstr),
    call_instr_arg(CallerInstr, 0, Constant),


    constant_references_func(Constant, Callback).

  .decl _dtor_accepts_recv(?aCtx: Context, ?recvObj: GlobalAllocation , ?dtor: FunctionDecl)

  _dtor_accepts_recv(?aCtx, ?recvObj, ?dtor) :-
    _registers_dtor_atexit(?ctx, ?dtorOperand, ?recvOperand),
    operand_points_to(_, ?dtorObj, ?ctx, ?dtorOperand),
    operand_points_to(?aCtx, ?someObj, ?ctx, ?recvOperand),
    alloc_aliases(?recvObj, ?someObj),
    global_allocation(?recvObj),
    static_allocation_type(?recvObj, ?recvType),
    func_by_location(?dtorObj, ?dtor),
    func_ty(?dtor, ?dtorType),
    func_type_param(?dtorType, 0, ?ptrType),
    pointer_type_has_component(?ptrType, ?recvType).

  called_at_exit(?dtor) :- _dtor_accepts_recv(_, _, ?dtor).

  .decl at_exit_var_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable)
  at_exit_var_points_to(?aCtx, ?recvObj, ?exitCtx, ?this) :-
    exit_context(?exitCtx),
    _dtor_accepts_recv(?aCtx, ?recvObj, ?dtor),
    reachable_context(?exitCtx, ?dtor),
    func_param(?dtor, 0, ?this).
}
#line 9 "points-to/points-to.project"
#line 1 "type-compatibility.dl"
#line 13 "type-compatibility.dl"
.decl type_compatible(?type1:Type, ?type2:Type)

type_compatible(?type, ?type) :-
   type(?type),
   ! ?type= "fp128",
   ! ?type= "half".



.decl type_compatible_up_to_field(?type1:StructType, ?type2:StructType, ?field:FieldIndex)

type_compatible_up_to_field(?type1, ?type2, 0) :-
   struct_type_field(?type1, 0, ?field1),
   struct_type_field(?type2, 0, ?field2),
   type_compatible(?field1, ?field2).

type_compatible_up_to_field(?type1, ?type2, i + 1) :-
   type_compatible_up_to_field(?type1, ?type2, i),
   struct_type_field(?type1, i + 1, ?field1),
   struct_type_field(?type2, i + 1, ?field2),
   type_compatible(?field1, ?field2).

type_compatible(?type1,?type2) :-
   struct_type_nfields(?type1,?nfields),
   struct_type_nfields(?type2,?nfields),
   type_compatible_up_to_field(?type1,?type2,?nfields - 1).



.decl type_compatible_up_to_arg(?from:FunctionType, ?to:FunctionType, ?index:ArgumentIndex)

type_compatible_up_to_arg(?from, ?to, 0) :-
   func_type_return(?from, ?returnType1),
   func_type_return(?to , ?returnType2),
   type_compatible(?returnType1, ?returnType2).

type_compatible_up_to_arg(?from, ?to, i+1) :-
   type_compatible_up_to_arg(?from, ?to, i),
   func_type_param(?from, i , ?param1),
   func_type_param(?to, i , ?param2),
   type_compatible(?param1, ?param2).

type_compatible(?from,?to) :-
   func_type_nparams(?from, ?nparams),
   func_type_nparams(?to, ?nparams),
   type_compatible_up_to_arg(?from, ?to, ?nparams).

type_compatible(?from,?to) :-
   func_type_nparams(?from, 0),
   type_compatible_up_to_arg(?from, ?to, 0).

type_compatible(?from,?to) :-
   func_type_nparams(?to, ?nparams),
   func_type_has_varargs(?to),
   type_compatible_up_to_arg(?from, ?to, ?nparams).



type_compatible(?type1, ?type2) :-
   array_type_has_component(?type1, ?comp1),
   array_type_has_component(?type2, ?comp2),
   ( (!array_type_has_size(?type1, _) )
   ; (!array_type_has_size(?type2, _) )),
   type_compatible(?comp1, ?comp2).

type_compatible(?type1, ?type2) :-
   array_type_has_component(?type1, ?comp1),
   array_type_has_component(?type2, ?comp2),
   array_type_has_size(?type1, ?size),
   array_type_has_size(?type2, ?size),
   type_compatible(?comp1, ?comp2).



type_compatible(?ptrType1, ?ptrType2) :-
   pointer_type_has_component(?ptrType1 , ?type1),
   pointer_type_has_component(?ptrType2 , ?type2),
   type_compatible(?type1, ?type2).



type_compatible(?from, ?to) :-
   pointer_type_has_component(?to, ?i8),
   int8_type(?i8),
   pointer_type(?from).

type_compatible(?from, ?to) :-
   pointer_type_has_component(?from, ?i8),
   int8_type(?i8),
   pointer_type(?to).
#line 10 "points-to/points-to.project"
#line 1 "points-to-options.dl"









.decl analyze_pointer_arithmetic()

analyze_pointer_arithmetic() :-
   user_option_value("pointer_arithmetic","on").
#line 30 "points-to-options.dl"
.decl inlined_constructors()

inlined_constructors() :-
   user_option_value("optimized_code","on").
#line 11 "points-to/points-to.project"
#line 1 "class-type.dl"







.type ClassType = StructType
.decl class_type(?type: ClassType)



.decl class_type_name(?type: ClassType, ?name: symbol)




class_type(?type) :-
   struct_type(?type),
   ( contains("%class\\.", ?type)
   ; contains("%\"class\\.", ?type)
   ).

class_type_name(?type, ?name) :-
   struct_type(?type),
   !template_type(?type),
   contains("%\"class\\.", ?type),
   ?n=strlen(?type),
   ?name = substr(?type, 8, (?n) - 8).

class_type_name(?type, ?name) :-
   struct_type(?type),
   !template_type(?type),
   contains("%class\\.", ?type),
   ?n=strlen(?type),
   ?name = substr(?type, 7, (?n) - 7).

class_type_name(?type, ?name) :-
   struct_type(?type),
   !template_type(?type),
   contains("%\"struct\\.", ?type),
   ?n=strlen(?type),
   ?name = substr(?type, 9, (?n) - 9).

class_type_name(?type, ?name) :-
   struct_type(?type),
   !template_type(?type),
   contains("%struct\\.", ?type),
   ?n=strlen(?type),
   ?name = substr(?type, 8, (?n) - 8).









.decl class_type_vtable(?classType: ClassType, ?vt: GlobalVariable)

.decl class_type_typeinfo(?classType: ClassType, ?typeInfo: GlobalVariable)



.decl _typeinfo_class_name(?typeInfo: GlobalVariable, ?className: symbol)
_typeinfo_class_name(?typeInfo, ?className) :-
   typeinfo(?typeInfo),
   global_var_demangled_name(?typeInfo, ?tIName),
   contains("typeinfo for ", ?tIName),
   ?n = strlen(?tIName),
   ?className = substr(?tIName, 13, ?n - 13).


class_type_typeinfo(?classType, ?typeInfo) :-
   class_type_name(?classType, ?className),
   _typeinfo_class_name(?typeInfo, ?className).



.decl _vtable_class_name(?vt: GlobalVariable, ?className: symbol)
_vtable_class_name(?vt, ?className) :-
   vtable(?vt, _),
   global_var_demangled_name(?vt, ?demangledName),
   contains("vtable for ", ?demangledName),
   ?n = strlen(?demangledName),
   ?className = substr(?demangledName, 11, ?n - 11).


class_type_vtable(?classType, ?vt) :-
   class_type_name(?classType, ?className),
   _vtable_class_name(?vt, ?className).





.decl primary_superclass(?type: ClassType, ?superType: ClassType)
.decl secondary_superclass(?superType: ClassType, ?type: ClassType)



.decl _typeinfo_class_type(?typeInfo: GlobalVariable, ?classType: ClassType)

_typeinfo_class_type(?typeInfo, ?classType) :-
   !unpadded_struct_type(?classType),
   !template_typeinfo(?typeInfo),
   !template_type(?classType),
   class_type_typeinfo(?classType, ?typeInfo).

_typeinfo_class_type(?typeInfo, ?classType) :-
   !unpadded_struct_type(?classType),
   template_typeinfo(?typeInfo),
   template_type(?classType),
   class_type_typeinfo(?classType, ?typeInfo).

primary_superclass(?type, ?superType) :-
   typeinfo_base_class(?typeInfo, 0, ?baseTypeInfo),
   _typeinfo_class_type(?typeInfo, ?type),
   _typeinfo_class_type(?baseTypeInfo, ?superType).

secondary_superclass(?superType, ?type) :-
   typeinfo_base_class(?typeInfo, ?index, ?baseTypeInfo),
   _typeinfo_class_type(?typeInfo, ?type),
   _typeinfo_class_type(?baseTypeInfo, ?superType),
   ?index > 0.



.decl direct_superclass(?superType: ClassType, ?type: ClassType)
direct_superclass(?superType, ?type) :-
   primary_superclass(?type, ?superType)
 ; secondary_superclass(?superType, ?type).



.decl direct_subclass(?subType: ClassType, ?type: ClassType)
direct_subclass(?subtype, ?type) :-
   direct_superclass(?type, ?subtype).




.decl superclass(?superType: ClassType, ?type: ClassType)
superclass(?superType, ?type) :-
   direct_superclass(?superType, ?type).

superclass(?superType, ?type) :-
   direct_superclass(?superType, ?intermType),
   superclass(?intermType, ?type).
#line 180 "class-type.dl"
.decl _string_iteration_trick(?pos:number)
_string_iteration_trick(0).
_string_iteration_trick(?pos + 1) :- _string_iteration_trick(?pos), ?pos < 256.

.decl relevant_suffix_position(?typeName: symbol, ?pos:number)
relevant_suffix_position(?typeName, ?pos) :-
   struct_type(?typeName),
   _string_iteration_trick(?pos), ?pos < strlen(?typeName).

.decl suffix(?type:Type, ?suffix:symbol, ?suffixLen:number)


suffix(?type, ?suffix, ?suffixLen) :-
 struct_type_has_name(?type, _),
 relevant_suffix_position(?type, ?pos),
 substr(?type, ?pos, 1) = ".",
 ?suffixLen = strlen(?type) - ?pos - 1,
 ?suffix = substr(?type, ?pos + 1, ?suffixLen),
 contains(".", ?type),
 substr(?type, 0, ?pos + 1) != "%class.",
 substr(?type, 0, ?pos + 1) != "%\"class.",
 substr(?type, 0, ?pos + 1) != "%struct.",
 substr(?type, 0, ?pos + 1) != "%\"struct.",
 substr(?type, 0, ?pos + 1) != "%union.",
 substr(?type, 0, ?pos + 1) != "%\"union.".

.decl minimal_suffix_len(?type:StructType, ?suffixLen:number)

minimal_suffix_len(?type, ?suffixLen) :-
 struct_type(?type),
 ?suffixLen = min ?len : suffix(?type, _, ?len).


.decl minimal_suffix(?type:StructType, ?suffix:symbol)

minimal_suffix(?type, ?suffix) :-
 minimal_suffix_len(?type, ?suffixLen),
 suffix(?type, ?suffix, ?suffixLen).



.decl template_type(?type:StructType)
template_type(?type) :-
   minimal_suffix(?type , ?dotSuffix),
   ?dotSuffix != "base",
   ?dotSuffix != "base\"".



.decl unpadded_struct_type(?type: StructType)
unpadded_struct_type(?type) :-
   struct_type(?type),
   match(".*\\.base",?type).

.decl template_typeinfo(?typeInfo: GlobalVariable)


template_typeinfo(?typeInfo) :-
   match(".*<.*>", ?name),
   _typeinfo_class_name(?typeInfo, ?name).





.decl class_type_constructor(?cTor: FunctionDecl, ?type: ClassType)
.decl class_type_destructor(?dTor: FunctionDecl, ?type: ClassType)


class_type_constructor(?ctor, ?type)
 :-
   struct_type(?type),
   func_name(?ctor, ?funcName),
   func_ty(?ctor, ?fType),
   func_type_param(?fType, 0, ?ptrType),
   pointer_type_has_component(?ptrType, ?type),
   ( contains("C1", ?funcName)
   ; contains("C2", ?funcName)
   ).



class_type_destructor(?dtor, ?type)
 :-
   struct_type(?type),
   func_name(?dtor, ?funcName),
   func_ty(?dtor, ?fType),
   func_type_param(?fType, 0, ?ptrType),
   pointer_type_has_component(?ptrType, ?type),
   ( contains("D1", ?funcName)
   ; contains("D2", ?funcName)
   ).
#line 12 "points-to/points-to.project"
#line 1 "virtual-tables.dl"
#line 15 "virtual-tables.dl"
.decl vtable(?vt: VirtualTable, ?name: symbol)
.decl typeinfo(?typeInfo: GlobalVariable)
.decl vtable_typeinfo(?vt: VirtualTable,?typeInfo: GlobalVariable)

.type VirtualTable = GlobalVariable

.decl typeinfo_vtable(?vt: VirtualTable, ?name: symbol)
vtable(?vt, ?name) :-
   typeinfo_vtable(?vt, ?name).

typeinfo_vtable(?vt, ?name) :-
   external_linkage_type(?externalLinkage),
   global_var_linkage(?vt, ?externalLinkage),
   global_var_name(?vt, ?name),
   contains("class_type_info", ?name),
   contains("cxxabi", ?name).

.decl typeinfo_vtable_baseclass(?vt: VirtualTable, ?name: symbol)
typeinfo_vtable_baseclass(?vt, ?name) :-
   typeinfo_vtable(?vt, ?name),
   !contains("__si_class_type_info", ?name),
   !contains("__vmi_class_type_info", ?name),
   contains("__class_type_info", ?name).

.decl typeinfo_vtable_single_inheritance(?vt: VirtualTable, ?name: symbol)
typeinfo_vtable_single_inheritance(?vt, ?name) :-
   typeinfo_vtable(?vt, ?name),
   contains("__si_class_type_info", ?name).

.decl typeinfo_vtable_multiple_inheritance(?vt: VirtualTable, ?name: symbol)
typeinfo_vtable_multiple_inheritance(?vt, ?name) :-
   typeinfo_vtable(?vt, ?name),
   contains("__vmi_class_type_info", ?name).




.decl constant_contains_vptr(?vt: VirtualTable, ?constant: Constant)
constant_contains_vptr(?vt, ?constant) :-
   global_var_constant_name(?constant, ?name),
   vtable(?vt, ?name).

constant_contains_vptr(?vt, ?outer) :-
   getelementptr_constant_expression_base(?outer,?inner),
   constant_contains_vptr(?vt, ?inner).

constant_contains_vptr(?vt, ?outer) :-
   bitcast_constant_expression_from(?outer, ?inner),
   constant_contains_vptr(?vt, ?inner).

constant_contains_vptr(?vt, ?outer) :-
   constant_struct_index(?outer, 0, ?inner),
   constant_contains_vptr(?vt, ?inner).




.decl typeinfo_has_vtable(?typeInfo:GlobalVariable, ?vt: VirtualTable)
typeinfo(?typeInfo),
typeinfo_has_vtable(?typeInfo,?vt) :-
   constant_contains_vptr(?vt, ?initializer),
   typeinfo_vtable(?vt, _),
   global_var_initializer(?typeInfo, ?initializer).

.decl typeinfo_baseclass(?typeInfo: GlobalVariable)
typeinfo_baseclass(?typeInfo) :-
   typeinfo_has_vtable(?typeInfo, ?vt),
   typeinfo_vtable_baseclass(?vt,_).

.decl typeinfo_single_inheritance(?typeInfo: GlobalVariable)
typeinfo_single_inheritance(?typeInfo) :-
   typeinfo_has_vtable(?typeInfo, ?vt),
   typeinfo_vtable_single_inheritance(?vt, _).

.decl typeinfo_multiple_inheritance(?typeInfo: GlobalVariable)
typeinfo_multiple_inheritance(?typeInfo) :-
   typeinfo_has_vtable(?typeInfo, ?vt),
   typeinfo_vtable_multiple_inheritance(?vt, _).




.decl _constant_contains_typeinfo(?typeInfo: GlobalVariable, ?constant:Constant)
_constant_contains_typeinfo(?typeInfo, ?constant) :-
   global_var_constant_reference(?constant, ?typeInfo),
   typeinfo(?typeInfo).

_constant_contains_typeinfo(?typeinfo, ?outer) :-
   bitcast_constant_expression_from(?outer, ?inner),
   _constant_contains_typeinfo(?typeinfo, ?inner).

vtable(?vt, ?name),
vtable_typeinfo(?vt,?typeinfo) :-
   global_var_name(?vt, ?name),
   global_var_initializer(?vt, ?initializer),
   constant_array_index(?initializer, 1, ?tic),
   _constant_contains_typeinfo(?typeinfo, ?tic).




.decl _typeinfo_contains_typeinfo(?outer: GlobalVariable, ?index:number, ?inner: GlobalVariable)
_typeinfo_contains_typeinfo(?outer, ?index, ?inner) :-
   typeinfo(?outer),
   global_var_initializer(?outer, ?init),
   constant_struct_index(?init, ?index, ?tic),
   _constant_contains_typeinfo(?inner, ?tic).

.decl typeinfo_base_class(?typeinfo:GlobalVariable, ?offset: number, ?baseTypeinfo: GlobalVariable)


typeinfo_base_class(?typeinfo, 0, ?baseTypeinfo) :-
   typeinfo_single_inheritance(?typeinfo),
   _typeinfo_contains_typeinfo(?typeinfo, 2, ?baseTypeinfo).


typeinfo_base_class(?typeinfo, ?offset, ?baseTypeinfo) :-
   typeinfo_multiple_inheritance(?typeinfo),
   _typeinfo_contains_typeinfo(?typeinfo, ?index, ?baseTypeinfo),
   global_var_initializer(?typeinfo, ?init),
   constant_struct_index(?init, ?index + 1, ?constant),
   constant_to_int(?constant, ?offsetMask),
   ?offset = ?offsetMask / 256.




.decl vtable_func(?vt: VirtualTable, ?index: number, ?func: FunctionDecl)

vtable_func(?vt,?index,?func) :-
   vtable(?vt, _),
   global_var_initializer(?vt,?init),
   constant_array_index(?init, ?index, ?funcAsInteger),
   bitcast_constant_expression_from(?funcAsInteger, ?funcConstant),
   func_constant_fn_name(?funcConstant, ?funcName),
   func_name(?func,?funcName).
#line 13 "points-to/points-to.project"
#line 1 "type-back-propagation.dl"


.comp TypeIndication {







  .decl operand_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?operand: Operand) inline
  .decl var_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable) inline
  .decl alloc_with_ctx(?aCtx: Context, ?alloc: Allocation) inline
#line 25 "type-back-propagation.dl"
  .decl ty_indication(?type: Type, ?aCtx: Context, ?alloc: Allocation)
  .decl ty_indication1(?type: Type, ?aCtx: Context, ?alloc: Allocation)
  .decl ty_indication2(?type: Type, ?aCtx: Context, ?alloc: Allocation)
  .decl ty_indication3(?type: Type, ?aCtx: Context, ?alloc: Allocation)

  .decl backpropagated_allocation_type(?alloc: Allocation, ?type: Type) inline

  .decl _heap_allocation_by_instr(?insn: Instruction, ?alloc: Allocation, ?untyped: Allocation)
  _heap_allocation_by_instr(?insn, ?alloc, ?alloc) :-
    heap_allocation_by_instr(?insn, ?alloc).

  _heap_allocation_by_instr(?insn, ?alloc, ?untyped) :-
    heap_allocation_by_type_instr(_, ?insn, ?alloc),
    heap_allocation_by_instr(?insn, ?untyped).


  ty_indication1(?type, ?aCtx, ?untyped),
  ty_indication(?type, ?aCtx, ?untyped) :-
     bitcast_instr_to_type(?instr,?ptrType),
     bitcast_instr_from_operand(?instr,?fromOperand),
     operand_points_to(?aCtx, ?alloc, _, ?fromOperand),
     _heap_allocation_by_instr(?allocInstr, ?alloc, ?untyped),
     !sized_alloc_instr(?allocInstr,_),
     pointer_type_has_component(?ptrType,?type).

  ty_indication2(?type, ?aCtx, ?untyped),
  ty_indication(?type, ?aCtx, ?untyped) :-
     bitcast_instr_to_type(?instr,?ptrType),
     bitcast_instr_from_operand(?instr,?fromOperand),
     operand_points_to(?aCtx, ?alloc, _, ?fromOperand),
     _heap_allocation_by_instr(?allocInstr, ?alloc, ?untyped),
     pointer_type_has_component(?ptrType,?type),
     sized_alloc_instr(?allocInstr,?size),
     type_has_size(?type,?size).



  ty_indication3(?type, ?aCtx, ?untyped),
  ty_indication(?type, ?aCtx, ?untyped) :-
     bitcast_instr_to_type(?instr,?ptrType),
     bitcast_instr_from_operand(?instr,?fromOperand),
     operand_points_to(?aCtx, ?alloc, _, ?fromOperand),
     _heap_allocation_by_instr(?allocInstr, ?alloc, ?untyped),
     pointer_type_has_component(?ptrType,?type),
     pointer_type_base_component(?ptrType, ?baseType),
     sized_alloc_instr(?allocInstr, size),
     type_has_size(?baseType,baseSize),
     baseSize != 0,
     size = (size / baseSize) * baseSize.

  .decl heap_allocation_by_type_instr(?type: Type, ?insn: CallBase, ?heapAlloc: HeapAllocation)
  .decl assign_rebase_alloc(?typedAlloc: Allocation, ?aCtx: Context, ?alloc: Allocation, ?var: Variable)

  heap_allocation_by_type_instr(?type, ?allocInstr, ?typedAlloc),
    assign_rebase_alloc(?typedAlloc, ?aCtx, ?alloc, ?var),
    heap_allocation(?typedAlloc),
    backpropagated_allocation_type(?typedAlloc, ?type),
    alloc_with_ctx(?aCtx, ?typedAlloc)
   :-
     heap_allocation_by_instr(?allocInstr, ?alloc),
     ty_indication(?type, ?aCtx, ?alloc),
     instr_assigns_to(?allocInstr, ?var),
     variable_in_func(?var, ?func),
     variable_has_name(?var, ?name),
     func_name(?func, ?funcName),
     pointer_type_has_component(?ptrType, ?type),
     ?typedAlloc= cat("*typed_heap_alloc", ?funcName, "[" , ?ptrType , " ", ?name, "]").

  allocation_pos(?alloc, ?line, ?column) :-
     heap_allocation_by_type_instr(_, ?insn, ?alloc),
     instr_pos(?insn, ?line, ?column).
#line 140 "type-back-propagation.dl"
  .decl stack_allocation_by_type_instr(?type: Type, ?insn: AllocaInstruction, ?stackAlloc: StackAllocation)
  .decl stack_type_indication(?type: Type, ?aCtx: Context, ?alloc: Allocation)

  stack_type_indication(?type, ?aCtx, ?alloc) :-
     bitcast_instr_to_type(?instr,?ptrType),
     bitcast_instr_from_operand(?instr,?fromOperand),
     operand_points_to(?aCtx, ?alloc, _, ?fromOperand),
     stack_allocation_by_instr(?allocInstr, ?alloc),
     alloca_instr_type(?allocInstr, ?allocaType),
     integer_type(?allocaType),
     pointer_type_has_component(?ptrType,?type).

  stack_allocation_by_type_instr(?type, ?allocInstr, ?typedAlloc),
    assign_rebase_alloc(?typedAlloc, ?aCtx, ?alloc, ?var),
    stack_allocation(?typedAlloc),
    backpropagated_allocation_type(?typedAlloc, ?type),
    alloc_with_ctx(?aCtx, ?typedAlloc)
   :-
     stack_allocation_by_instr(?allocInstr, ?alloc),
     stack_type_indication(?type, ?aCtx, ?alloc),
     instr_assigns_to(?allocInstr, ?var),
     variable_in_func(?var, ?func),
     variable_has_name(?var, ?name),
     func_name(?func, ?funcName),
     pointer_type_has_component(?ptrType, ?type),
     ?typedAlloc= cat("*typed_stack_alloc", ?funcName, "[", ?ptrType, " ", ?name, "]").

  allocation_pos(?alloc, ?line, ?column) :-
    stack_allocation_by_type_instr(_, ?insn, ?alloc),
    instr_pos(?insn, ?line, ?column).
}
#line 14 "points-to/points-to.project"
#line 1 "constant-init.dl"


.decl initialized_by_constant(?alloc: Allocation, ?constant: Constant)

initialized_by_constant(?baseAlloc, ?init) :-
   global_var_initializer(?var, ?init),
   global_allocation_by_variable(?var, ?baseAlloc).

initialized_by_constant(?alloc, ?init) :-
   global_var_initializer(?var, ?init),
   global_allocation_by_variable(?var, ?baseAlloc),
   static_subobjects.alloc_subregion_at_array_index(?baseAlloc, 0, ?alloc).

initialized_by_constant(?alloc, ?innerConstant) :-
   initialized_by_constant(?baseAlloc, ?constant),
   constant_struct(?constant),
   constant_struct_index(?constant, ?field, ?innerConstant),
   static_subobjects.alloc_subregion_at_field(?baseAlloc, ?field, ?alloc),

   constant_has_type(?constant, ?constantType),
   static_allocation_type(?baseAlloc, ?type),
   struct_type(?type),
   struct_type(?constantType),
   type_compatible_up_to_field(?type, ?constantType, ?field).

initialized_by_constant(?alloc, ?innerConstant) :-
   initialized_by_constant(?baseAlloc, ?constant),
   constant_array(?constant),
   constant_array_index(?constant, ?index, ?innerConstant),
   static_subobjects.alloc_subregion_at_array_index(?baseAlloc, ?index, ?alloc),

   constant_has_type(?constant, ?constantType),
   static_allocation_type(?baseAlloc, ?type),
   array_type(?type),
   array_type(?constantType),
   type_compatible(?type, ?constantType).



array_indices__no_typecomp(?region, ?constantType, as(?index, ArrayIndex)) :-
  constant_has_type(?constant, ?constantType),
  constant_array_index(?constant, ?index, _),
  array_type(?constantType),




  type_contains_pointer(?constantType),
  global_region(?region).





.decl constant_ptr_points_to(?aCtx: Context, ?alloc: Allocation, ?ptrACtx: Context, ?ptrAlloc: Allocation)
constant_ptr_points_to(?aCtx, ?someAlloc, ?aCtx, ?alloc) :-
   empty_alloc_context(?aCtx),
   initialized_by_constant(?alloc, ?constant),
   constant_points_to(?constant, ?someAlloc).
#line 15 "points-to/points-to.project"
#line 1 "constant-exprs.dl"



constant_points_to(?otherConstant, ?alloc)
 :-
   aliased_constants(?otherConstant, ?constant),
   constant_points_to(?constant, ?alloc).










constant_points_to(?constant, ?unknown) :-
   inttoptr_constant_expression(?constant),
   unknown_location(?unknown).







constant_points_to(?intConstant, ?alloc) :-
   ptrtoint_constant_expression_from(?intConstant, ?ptrConstant),
   constant_points_to(?ptrConstant, ?alloc).




constant_points_to(?outerConstant, ?alloc) :-
   bitcast_constant_expression_from(?outerConstant, ?innerConstant),
   constant_points_to(?innerConstant, ?alloc).
#line 51 "constant-exprs.dl"
.decl gep_constant_expr_indexes_from(?cExpr: GetElementPtrConstantExpression, ?index: GepIndex, ?alloc: Allocation, ?type: Type)
.decl gep_constant_expr_points_to(?cExpr: GetElementPtrConstantExpression, ?index: GepIndex, ?alloc: Allocation)

.decl gep_constant_expr_index_offset(?insn: GetElementPtrConstantExpression, ?index: GepIndex, ?alloc: Allocation, ?offset: number)


gep_constant_expr_index_offset(?insn, 0, ?alloc, ?offset) :-
   gep_constant_expr_indexes_from(?insn, 0, ?alloc, ?ptrType),
   pointer_type_has_component(?ptrType, ?type),
   static_allocation_type(?alloc, ?allocType),
   type_has_size(?type, ?pSize),
   type_has_size(?allocType, ?aSize),
   getelementptr_constant_expression_index(?insn, 0, ?indexOp),
   constant_to_int(?indexOp, ?offset),
   ?aSize != 0,
   ?offset = (?offset * ?pSize) / ?aSize.

gep_constant_expr_index_offset(?insn, ?n, ?alloc, ?offset) :-
   gep_constant_expr_indexes_from(?insn, ?n, ?alloc, _),
   ?n > 0,
   getelementptr_constant_expression_index(?insn, ?n, ?indexOp),
   constant_to_int(?indexOp, ?offset).

gep_constant_expr_indexes_from(?cExpr, 0, ?alloc, ?type) :-
   getelementptr_constant_expression_base(?cExpr, ?base),
   constant_points_to(?base, ?alloc),
   _getelementptr_constant_expression_base_type(?cExpr, ?type).

gep_constant_expr_indexes_from(?cExpr, ?n, ?alloc, ?type) :-
   getelementptr_constant_expression_index(?cExpr, ?n, _),
   gep_constant_expr_points_to(?cExpr, ?n - 1, ?alloc),
   _getelementptr_constant_expression_interm_type(?cExpr, ?n, ?type).

gep_constant_expr_points_to(?cExpr, ?n, ?alloc) :-
   gep_constant_expr_indexes_from(?cExpr, ?n, ?parent, ?type),
   (array_type(?type); pointer_type(?type)),
   gep_constant_expr_index_offset(?cExpr, ?n, ?parent, ?offset),
   static_subobjects.alloc_subregion_at_array_index(?parent, ?offset, ?alloc).

gep_constant_expr_points_to(?cExpr, ?n, ?alloc) :-
   gep_constant_expr_indexes_from(?cExpr, ?n, ?parent, ?type),
   (array_type(?type); pointer_type(?type)),
   gep_constant_expr_index_offset(?cExpr, ?n, ?parent, ?offset),
   static_subobjects.alloc_subregion(?parent),
   global_region(?region),
   static_allocation_type(?parent, ?type),
   ! array_indices(?region, ?type, ?offset),
   static_subobjects.alloc_subregion_at_any_array_index(?parent, ?alloc).

gep_constant_expr_points_to(?cExpr, ?n, ?alloc) :-
   gep_constant_expr_indexes_from(?cExpr, ?n, ?parent, ?type),
   (array_type(?type); pointer_type(?type)),
   static_subobjects.alloc_subregion_at_array_index(?grandparent, ?start, ?parent),
   gep_constant_expr_index_offset(?cExpr, ?n, ?parent, ?offset),
   static_subobjects.alloc_subregion_at_array_index(?grandparent, ?start + ?offset, ?alloc).

gep_constant_expr_points_to(?cExpr, ?n, ?alloc) :-
   gep_constant_expr_indexes_from(?cExpr, ?n, ?parent, ?type),
   (array_type(?type); pointer_type(?type)),
   static_subobjects.alloc_subregion_at_array_index(?grandparent, ?start, ?parent),
   gep_constant_expr_index_offset(?cExpr, ?n, ?parent, ?offset),
   static_subobjects.alloc_subregion(?grandparent),
   global_region(?region),
   static_allocation_type(?grandparent, ?type),
   ! array_indices(?region, ?type, ?start + ?offset),
   static_subobjects.alloc_subregion_at_any_array_index(?grandparent, ?alloc).

gep_constant_expr_points_to(?cExpr, ?n, ?alloc) :-
   gep_constant_expr_indexes_from(?cExpr, ?n, ?parent, ?type),
   struct_type(?type),
   gep_constant_expr_index_offset(?cExpr, ?n, ?parent, ?field),
   static_subobjects.alloc_subregion_at_field(?parent, ?field, ?alloc).

gep_constant_expr_points_to(?cExpr, ?n, ?alloc) :-
   gep_constant_expr_indexes_from(?cExpr, ?n, ?parent, ?type),
   pointer_type_has_component(?type, ?i8),
   int8_type(?i8),
   static_allocation_type(?parent, ?parentType),
   struct_type(?parentType),
   getelementptr_constant_expression_index(?cExpr, ?n, ?indexOp),
   constant_to_int(?indexOp, ?offset),
   struct_type_field_offset(?parentType, ?field, ?offset),
   static_subobjects.alloc_subregion_at_field(?parent, ?field, ?alloc).

constant_points_to(?cExpr, ?alloc) :-
   getelementptr_constant_expression_nindices(?cExpr, ?total),
   gep_constant_expr_points_to(?cExpr, ?total - 1, ?alloc).
#line 16 "points-to/points-to.project"
#line 1 "constant-points-to.dl"
#line 12 "constant-points-to.dl"
.decl constant_points_to(?constant: Constant, ?alloc: Allocation)


constant_points_to(?constant, ?null) :-
   nullptr_constant(?constant),
   null_location(?null).





constant_points_to(?constant, ?alloc) :-
   global_var_constant_name(?constant, ?name),
   global_var_name(?gVar, ?name),
   global_allocation_by_variable(?gVar, ?alloc).

constant_points_to(?constant, ?alloc) :-
   func_constant_fn_name(?constant, ?fName),
   func_name(?func, ?fName),
   global_allocation_by_func(?func, ?alloc).

constant_points_to(?constant, ?alloc) :-
   constant_references_variable(?constant, ?gVar),
   global_allocation_by_variable(?gVar, ?alloc).

constant_points_to(?constant, ?alloc) :-
   constant_references_func(?constant, ?func),
   global_allocation_by_func(?func, ?alloc).
#line 17 "points-to/points-to.project"
#line 1 "allocations-subobjects-aliases.dl"
#line 15 "allocations-subobjects-aliases.dl"
.comp Aliases {







  .decl alloc_subregion_at_field(?alloc: Allocation, ?index: FieldIndex, ?region:AllocSubregion) inline
  .decl alloc_subregion_at_array_index(?alloc: Allocation, ?index: ArrayIndex, ?region: AllocSubregion) inline
  .decl alloc_subregion_at_any_array_index(?alloc: Allocation, ?region: AllocSubregion) inline





  .decl alloc_aliases(?alloc1: Allocation, ?alloc2: Allocation)



  alloc_aliases(?alloc, ?alloc) :-
    allocation(?alloc).



  alloc_aliases(?alloc1, ?alloc2) :-
    alloc_aliases(?alloc1, ?intermAlloc),
    alloc_aliases(?alloc2, ?intermAlloc).



  alloc_aliases(?alloc1, ?alloc2) :-
    alloc_aliases(?alloc2, ?alloc1).





  alloc_aliases(?base, ?zeroIndexBase) :-
    alloc_subregion_at_array_index(?base, 0, ?zeroIndexBase).

  alloc_aliases(?base, ?firstField) :-
    alloc_subregion_at_field(?base, 0, ?firstField).
#line 95 "allocations-subobjects-aliases.dl"
  .decl alloc_matches(?alloc: Allocation, ?starredAlloc: Allocation)

  alloc_matches(?alloc, ?starredAlloc) :-
    alloc_matches(?base1, ?base2),
    alloc_subregion_at_array_index(?base1, _, ?alloc),
    alloc_subregion_at_any_array_index(?base2, ?starredAlloc).

  alloc_matches(?alloc, ?starredAlloc) :-
    alloc_subregion_at_array_index(?base, _, ?alloc),
    alloc_subregion_at_any_array_index(?base, ?starredAlloc).

  alloc_matches(?alloc1, ?alloc2) :-
    alloc_matches(?base1, ?base2),
    alloc_subregion_at_any_array_index(?base1, ?alloc1),
    alloc_subregion_at_any_array_index(?base2, ?alloc2).

  alloc_matches(?alloc1, ?alloc2) :-
    alloc_matches(?base1, ?base2),
    alloc_subregion_at_array_index(?base1, ?index, ?alloc1),
    alloc_subregion_at_array_index(?base2, ?index, ?alloc2).

  alloc_matches(?alloc1, ?alloc2) :-
    alloc_matches(?base1, ?base2),
    alloc_subregion_at_field(?base1, ?field, ?alloc1),
    alloc_subregion_at_field(?base2, ?field, ?alloc2).








  .decl alloc_may_alias(?alloc1: Allocation, ?alloc2: Allocation)





  alloc_may_alias(?alloc1, ?alloc2) :-
    alloc_may_alias(?alloc2, ?alloc1).

  alloc_may_alias(?alloc1, ?alloc2) :-
    alloc_aliases(?alloc1, ?alloc2).

  alloc_may_alias(?alloc1, ?alloc2) :-
    alloc_matches(?alloc1, ?alloc2).

}
#line 18 "points-to/points-to.project"
#line 1 "core.dl"






.comp PointsTo {




  .init callgraph = Callgraph

  callgraph.merge(?newCtx, ?callerInstr, ?callerCtx) :-
    _merge.merge(?newCtx, ?callerInstr, ?callerCtx).

  .init _merge = Merge

  _merge.reachable_context(?ctx, ?func) :-
    callgraph.reachable_context(?ctx, ?func).

  callgraph.func_pointer_operand_points_to(?aCtx, ?alloc, ?ctx, ?operand) :-
    operand_points_to(?aCtx, ?alloc, ?ctx, ?operand).

  memcpy_pass_by_value(?calleeCtx, ?param, ?callerCtx, ?argument) :-
    func_by_value_param(?callee, ?index, ?param),
    callgraph.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr),
    actual_arg(?callerInstr, ?index, ?argument).

  ptr_points_to(aCtx, to, aCtx, from) :-
    empty_alloc_context(aCtx),
    argv_ptr_points_to(from, to).

  var_points_to(aCtx, argvAlloc, mainCtx, argvVar) :-
    argv_var_points_to(aCtx, argvAlloc, mainCtx, argvVar).

  any_reachable_func(?func) :- callgraph.reachable_func(?func).





  .decl var_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable)





  var_points_to(?aCtx, ?alloc, ?ctx, ?toVar) :-

    assign_instr(?toVar, ?value),
    operand_points_to(?aCtx, ?alloc, ?ctx, ?value).





  var_points_to(?aCtx, ?unknown, ?ctx, ?toVar) :-
    empty_alloc_context(?aCtx),
    unknown_location(?unknown),
    inttoptr_instr(?instr),
    instr_assigns_to(?instr, ?toVar),
    instr_func(?instr, ?instrFunc),
    callgraph.reachable_context(?ctx, ?instrFunc).








  .decl ptr_points_to(?aCtx: Context, ?alloc: Allocation, ?ptrACtx: Context, ?ptrAlloc: Allocation)

  ptr_points_to(?aCtx, ?someAlloc, ?aCtx, ?alloc) :-
    constant_ptr_points_to(?aCtx, ?someAlloc, ?aCtx, ?alloc).


  ptr_points_to(?aCtx, ?unknown, ?aCtx, ?unknown) :-
    empty_alloc_context(?aCtx),
    unknown_location(?unknown).



  .decl operand_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?operand: Operand)

  operand_points_to(?aCtx, ?alloc, ?ctx, ?ptrVar) :-
    var_points_to(?aCtx, ?alloc, ?ctx, ?ptrVar).

  operand_points_to(?aCtx, ?alloc, ?ctx, ?cons) :-
    empty_alloc_context(?aCtx),
    constant_in_func(?cons, ?enclosingFunc),
    constant_points_to(?cons, ?alloc),
    callgraph.reachable_context(?ctx, ?enclosingFunc).










  callgraph.reachable_context(?ctx, ?func) :-
    user_option_value("entrypoints", "library"),
    empty_context(?ctx),
    func(?func).





  .decl merge(?newCtx: Context, ?callerInstr: Instruction, ?callerCtx: Context) inline
  merge(?newCtx, ?callerInstr, ?callerCtx) :-
    _merge.merge(?newCtx, ?callerInstr, ?callerCtx).





  .init exception_object = ExceptionObjectComponent

  exception_object.heap_allocation_by_type_instr(?type, ?insn, ?heapAlloc) :-
    type_indication.heap_allocation_by_type_instr(?type, ?insn, ?heapAlloc).

  .init interp_assignment = InterpAssignment

  interp_assignment.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr) :-
    callgraph.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr).

  .init stripctx = StripCtx

  stripctx.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr) :-
    callgraph.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr).

  stripctx.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand) :-
    operand_points_to(?aCtx, ?alloc, ?ctx, ?operand).

  stripctx.ptr_points_to(?aCtx, ?alloc, ?ctx, ?ptr) :-
    ptr_points_to(?aCtx, ?alloc, ?ctx, ?ptr).

  stripctx.var_points_to(?aCtx, ?alloc, ?ctx, ?var) :-
    var_points_to(?aCtx, ?alloc, ?ctx, ?var).

  .init type_indication = TypeIndication

  type_indication.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand) :-
    operand_points_to(?aCtx, ?alloc, ?ctx, ?operand).

  type_indication.var_points_to(?aCtx, ?alloc, ?ctx, ?var) :-
    var_points_to(?aCtx, ?alloc, ?ctx, ?var).

  heap_allocation_by_type_instr(?type, ?insn, ?alloc) :-
    type_indication.heap_allocation_by_type_instr(?type, ?insn, ?alloc).

  stack_allocation_by_type_instr(?type, ?insn, ?alloc) :-
    type_indication.stack_allocation_by_type_instr(?type, ?insn, ?alloc).





}
#line 19 "points-to/points-to.project"
#line 1 "cplusplus.dl"




.decl cxx_new_func(?func: FunctionDecl)




cxx_new_func(?func),
   heap_alloc_func(?func)
 :-
   func_signature(?func, ?signature),
   func_ty(?func, ?fType),
   contains("operator new", ?signature),
   func_type_param(?fType, 0, ?type),
   integer_type(?type),
   func_type_nparams(?fType, 1),
   !func_decl_to_defn(?func, _).


.decl heap_allocation_by_new(?insn: CallBase, ?heapAlloc: HeapAllocation)

heap_allocation_by_new(?insn, ?heapAlloc) :-
   cxx_new_func(?func),
   ( call_instr_fn_target(?insn, ?func)
   ; invoke_instr_fn_target(?insn, ?func) ),
   heap_allocation_by_instr(?insn, ?heapAlloc).



sized_alloc_instr(?insn, as(?size, Bytes)) :-
   cxx_new_func(?func),
   call_instr_fn_target(?insn, ?func),
   call_instr_arg(?insn, 0, ?operand),
   constant_to_int(?operand, ?size).

sized_alloc_instr(?insn, as(?size, Bytes)) :-
   cxx_new_func(?func),
   invoke_instr_fn_target(?insn, ?func),
   invoke_instr_arg(?insn, 0, ?operand),
   constant_to_int(?operand, ?size).










.comp CPlusPlus {







  .decl allocation_type(?alloc:Allocation, ?type:Type) inline
  .decl stripctx_operand_points_to(?alloc: Allocation, ?operand: Operand) inline
#line 76 "cplusplus.dl"
  .decl is_init_by_ctor(?type: ClassType, ?ctor: FunctionDecl, ?inFunction: Function, ?alloc: Allocation)
  is_init_by_ctor(?type, ?ctor, ?inFunction, ?alloc)
  :-
    ( call_instr_fn_target(?initInstr, ?ctor)
    ; invoke_instr_fn_target(?initInstr, ?ctor) ),
    class_type_constructor(?ctor, ?type),
    instr_func(?initInstr, ?inFunction),
    actual_arg(?initInstr, 0, ?this),
    stripctx_operand_points_to(?alloc, ?this).




  .decl untyped_allocation(?insn: CallBase, ?alloc: Allocation)
  untyped_allocation(?insn, ?heapAlloc) :-
    inlined_constructors(),
    heap_allocation_by_new(?insn, ?heapAlloc).





  .decl _class_instance(?alloc: BasicAllocation)
  _class_instance(?alloc) :-
    allocation_type(?alloc, ?type),
    class_type(?type),
    basic_allocation(?alloc).

  .decl class_instance_constructor(?alloc: BasicAllocation, ?ctor: FunctionDecl)
  class_instance_constructor(?alloc, ?ctor) :-
    allocation_type(?alloc, ?type),
    is_init_by_ctor(?type, ?ctor, _, ?alloc),
    basic_allocation(?alloc).





  .decl class_instance_vtable(?alloc: Allocation, ?vTable: VirtualTable)

  class_instance_vtable(?alloc, ?vTable)
  :-
    class_instance_constructor(?alloc, ?ctor),
    instr_func(?storeInsn, ?ctor),
    store_instr_value(?storeInsn, ?value),
    store_instr_address(?storeInsn, ?pointer),
    stripctx_operand_points_to(?alloc, ?pointer),
    constant(?value),
    constant_contains_vptr(?vTable, ?value).

}








.decl _eligible_base_type(?superType: StructType, ?type: StructType)
_eligible_base_type(?superType, ?type) :-
   struct_type_field(?type, 0, ?unpaddedType),
   struct_type_nfields(?unpaddedType, ?nFields),
   type_compatible_up_to_field(?superType, ?unpaddedType, ?nFields - 1).

.decl _type_expands_base_type(?superType: StructType, ?type: StructType)
_type_expands_base_type(?superType, ?type) :-
   _eligible_base_type(?superType, ?type)
   ;
   _eligible_base_type(?superType, ?intermType),
   _type_expands_base_type(?intermType, ?type).

type_compatible(?ptrActualType, ?ptrDeclaredType) :-
   pointer_type_has_component(?ptrActualType, ?actualType),
   pointer_type_has_component(?ptrDeclaredType, ?declaredType),
   _type_expands_base_type(?declaredType, ?actualType).
#line 20 "points-to/points-to.project"
#line 1 "strip-context-projections.dl"




.comp StripCtx {






  .decl callgraph_edge(?calleeCtx: Context, ?callee: FunctionDecl, ?callerCtx: Context, ?callerInstr: CallBase) inline
  .decl operand_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?operand: Operand) inline
  .decl ptr_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?ptr: Allocation) inline
  .decl var_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable) inline





  .decl stripctx_callgraph_edge(?callee: FunctionDecl, ?callerInstr: Instruction)
  stripctx_callgraph_edge(?callee, ?callerInstr) :-
    callgraph_edge(_, ?callee, _, ?callerInstr).

  .decl stripctx_var_points_to(?alloc: Allocation, ?var: Variable)
  stripctx_var_points_to(?alloc, ?var) :-
    var_points_to(_, ?alloc, _, ?var).

  .decl stripctx_ptr_points_to(?to: Allocation, ?from: Allocation)
  stripctx_ptr_points_to(?to, ?from) :-
    ptr_points_to(_, ?to, _, ?from).

  .decl stripctx_operand_points_to(?to: Allocation, ?from: Operand)
  stripctx_operand_points_to(?to, ?from) :-
    operand_points_to(_, ?to, _, ?from).
}
#line 21 "points-to/points-to.project"
#line 1 "interprocedural.dl"




.decl func_by_location(?alloc: GlobalAllocation, ?callee: FunctionDecl)
func_by_location(?alloc, ?callee) :-
  global_allocation_by_func(?callee, ?alloc).

.comp Callgraph {







  .decl called_at_exit(func: FunctionDecl) inline
  .decl func_pointer_operand_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?operand: Operand) inline

  .decl merge(?newCtx: Context, ?callerInstr: CallBase, ?callerCtx: Context)










  .decl reachable_context(?ctx: Context, ?func: FunctionDecl)
  .decl reachable_func(func: FunctionDecl)
  .decl reachable_instr(instr: Instruction)

  reachable_context(?calleeCtx, ?callee) :-
     callgraph_edge(?calleeCtx, ?callee, _, _).

  reachable_func(?func) :-
    reachable_context(_, ?func).

  reachable_instr(Instr) :-
    reachable_func(Func),
    instr_func(Instr, Func).



  reachable_context(?ctx, ?func) :-
    ! insensitive(),
    ( main_func(?func),
      main_context(?ctx)
    ; called_at_startup(?func),
      startup_context(?ctx)
    ; called_at_exit(?func),
      exit_context(?ctx)
    ).

  reachable_context(?ctx, ?func) :-
    insensitive(),
    empty_context(?ctx),
    ( main_func(?func)
    ; called_at_startup(?func)
    ; called_at_exit(?func)
    ).

  .decl reachable_store(?ctx: Context, ?toAddress: Operand, ?value: Operand)

  reachable_store(?ctx, ?toAddress, ?value) :-
    reachable_context(?ctx, ?instrFunc),
    instr_func(?instr, ?instrFunc),
    store_instr_value(?instr, ?value),
    store_instr_address(?instr, ?toAddress).

  .decl reachable_load(?ctx: Context, ?toVar: Variable, ?fromAdress: Operand)

  reachable_load(?ctx, ?toVar, ?fromAddress) :-
    reachable_context(?ctx, ?instrFunc),
    instr_func(?instr, ?instrFunc),
    load_instr_address(?instr, ?fromAddress),
    instr_assigns_to(?instr, ?toVar).



  .decl callgraph_edge(?calleeCtx: Context, ?callee: FunctionDecl, ?callerCtx: Context, ?callerInstr: CallBase)



  .decl _callgraph_edge_interim_direct_call(?callee: FunctionDecl, ?callerCtx: Context, ?callerInstr: CallBase)

  _callgraph_edge_interim_direct_call(?callee, ?callerCtx, ?callerInstr)
   :-
     direct_call_instr(?callerInstr),
     call_instr_fn_target(?callerInstr, ?callee),
     instr_func(?callerInstr, ?instrFunc),
     reachable_context(?callerCtx, ?instrFunc).

  callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr)
   , context(?calleeCtx)
   :-
     _callgraph_edge_interim_direct_call(?callee, ?callerCtx, ?callerInstr),
     merge(?calleeCtx, ?callerInstr, ?callerCtx).

  .decl _callgraph_edge_interim_direct_invoke(?callee: FunctionDecl, ?callerCtx: Context, ?callerInstr: CallBase)

  _callgraph_edge_interim_direct_invoke(?callee, ?callerCtx, ?callerInstr)
   :-
     direct_invoke_instr(?callerInstr),
     invoke_instr_fn_target(?callerInstr, ?callee),
     instr_func(?callerInstr, ?instrFunc),
     reachable_context(?callerCtx, ?instrFunc).

  callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr)
   , context(?calleeCtx)
   :-
     _callgraph_edge_interim_direct_invoke(?callee, ?callerCtx, ?callerInstr),
     merge(?calleeCtx, ?callerInstr, ?callerCtx).




  .decl _callgraph_edge_interim_indirect_call(?callee: FunctionDecl, ?callerCtx: Context, ?aCtx: Context, ?callerInstr: CallBase)

  _callgraph_edge_interim_indirect_call(?callee, ?callerCtx, ?aCtx, ?callerInstr)
   :-
     indirect_call_instr(?callerInstr),
     call_instr_func_operand(?callerInstr, ?funcOp),
     func_pointer_operand_points_to(?aCtx, ?funcLoc, ?callerCtx, ?funcOp),
     func_by_location(?funcLoc, ?callee),
     func_ty(?callee, ?actualType),
     operand_has_type(?funcOp, ?funcOpType),
     pointer_type_has_component(?funcOpType, ?declaredType),
     type_compatible(?actualType, ?declaredType).

  callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr)
   , context(?calleeCtx)
   :-
     _callgraph_edge_interim_indirect_call(?callee, ?callerCtx, _, ?callerInstr),
     merge(?calleeCtx, ?callerInstr, ?callerCtx).

  .decl _callgraph_edge_interim_indirect_invoke(?callee: FunctionDecl, ?callerCtx: Context, ?aCtx: Context, ?callerInstr: CallBase)



  _callgraph_edge_interim_indirect_invoke(?callee, ?callerCtx, ?aCtx, ?callerInstr)
   :-
     invoke_instr(?callerInstr),
     invoke_instr_func_operand(?callerInstr, ?funcOp),
     func_pointer_operand_points_to(?aCtx, ?funcLoc, ?callerCtx, ?funcOp),
     func_by_location(?funcLoc, ?callee),
     func_ty(?callee, ?actualType),
     operand_has_type(?funcOp, ?funcOpType),
     pointer_type_has_component(?funcOpType, ?declaredType),
     type_compatible(?actualType, ?declaredType).

  callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr)
   , context(?calleeCtx)
   :-
     _callgraph_edge_interim_indirect_invoke(?callee, ?callerCtx, _, ?callerInstr),
     merge(?calleeCtx, ?callerInstr, ?callerCtx).
}







.decl actual_arg(?instr: CallBase, ?index: ArgumentIndex, ?argument: Operand)

actual_arg(?invokeInstr, ?index, ?argument) :-
  invoke_instr_arg(?invokeInstr, ?index, ?argument).

actual_arg(?callInstr, ?index, ?argument) :-
  call_instr_arg(?callInstr, ?index, ?argument).

.decl func_param_not_by_value(?callee: Function, ?index: ArgumentIndex, ?param: Variable)

func_param_not_by_value(?callee, ?index, ?param) :-
  func_param(?callee, ?index, ?param),
  !func_param_by_value(?callee, ?index).

.decl func_returns_value(?retValue: Operand, ?inFunction: Function)

func_returns_value(?retValue, ?inFunction) :-
  ret_instr_operand(?retInsn, ?retValue),
  instr_func(?retInsn, ?inFunction).

.comp InterpAssignment {







  .decl callgraph_edge(?calleeCtx: Context, ?callee: FunctionDecl, ?callerCtx: Context, ?callerInstr: CallBase) inline









  .decl interp_assignment(?toCtx: Context, ?toVar: Variable, ?fromCtx: Context, ?fromValue: Operand)


  interp_assignment(?calleeCtx, ?param, ?callerCtx, ?argument) :-
    callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr),
    func_param_not_by_value(?callee, ?index, ?param),
    actual_arg(?callerInstr, ?index, ?argument).



  interp_assignment(?callerCtx, ?toVar, ?calleeCtx, ?retValue) :-
    callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr),
    func_returns_value(?retValue, ?callee),
    instr_assigns_to(?callerInstr, ?toVar).










  .decl _va_arg_target(?toVar: Variable, ?argType: Type, ?callee: Function)

  _va_arg_target(?toVar, ?argType, ?callee) :-
    va_arg_instr(?vAArgInstr),
    va_arg_instr_type(?vAArgInstr, ?argType),
    instr_assigns_to(?vAArgInstr, ?toVar),
    instr_func(?vAArgInstr, ?callee).

  interp_assignment(?calleeCtx, ?toVar, ?callerCtx, ?argument) :-
    _va_arg_target(?toVar, ?argType, ?callee),
    func_ty(?callee, ?type),
    func_type_has_varargs(?type),
    func_type_nparams(?type, ?n),
    callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr),
    actual_arg(?callerInstr, ?index, ?argument),
    ?index >= ?n,
    operand_has_type(?argument, ?argType).

}







.decl memcpy_pass_by_value(?toCtx: Context, ?toVar: Variable, ?fromCtx: Context, ?fromValue: Operand)

.decl func_by_value_param(?callee: Function, ?index: ArgumentIndex, ?param: Variable)

func_by_value_param(?callee, ?index, ?param) :-
   func_param(?callee, ?index, ?param),
   func_param_by_value(?callee, ?index).
#line 22 "points-to/points-to.project"
#line 1 "memcpy.dl"







.comp Memcpy {







  .decl alloc_subregion(?alloc:Allocation) inline
  .decl alloc_subregion_at_any_array_index(?alloc: Allocation, ?region: AllocSubregion) inline
  .decl alloc_subregion_offset(?alloc: Allocation, ?region: AllocSubregion, ?offset: SubregionOffset) inline
  .decl allocation_type(?alloc:Allocation, ?type:Type) inline
  .decl callgraph_edge(?calleeCtx: Context, ?callee: FunctionDecl, ?callerCtx: Context, ?callerInstr: CallBase) inline
  .decl memcpy_sig(?toCtx: Context, ?to: Allocation, ?fromCtx: Context , ?from: Allocation) inline
  .decl operand_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?operand: Operand) inline
  .decl var_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable) inline
#line 38 "memcpy.dl"
  .decl _memcpy_call(?ctx: Context, ?to: Operand, ?from: Operand, ?size: number)

  _memcpy_call(?callerCtx, ?to, ?from, ?size) :-
    func_name(?callee, ?name),
    (
    "@memcpy"=substr(?name,0,7);
    "@llvm.memcpy"=substr(?name,0,12)
    ),
    callgraph_edge(_, ?callee, ?callerCtx, ?memcpyInstr),
    actual_arg(?memcpyInstr, 0, ?to),
    actual_arg(?memcpyInstr, 1, ?from),
    actual_arg(?memcpyInstr, 2, ?sizeOp),
    ( operand_to_int(?sizeOp, ?size)
    ; ( ! operand_to_int(?sizeOp, _)
      , ?size = 0
      )
    ).
#line 66 "memcpy.dl"
  .decl _try_memcpy(?toCtx: Context, ?to: Allocation, ?fromCtx: Context, ?from: Allocation, size: number)

  _try_memcpy(?toACtx, ?toAlloc, ?fromACtx, ?fromAlloc, ?size)
  :-
    _memcpy_call(?ctx, ?to, ?from, ?size),
    operand_points_to(?toACtx, ?toAlloc, ?ctx, ?to),
    operand_points_to(?fromACtx, ?fromAlloc, ?ctx, ?from).

  _try_memcpy(?toACtx, ?toAlloc, ?fromACtx, ?fromAlloc, 0)
  :-
    memcpy_pass_by_value(?toCtx, ?to, ?fromCtx, ?from),
    operand_points_to(?fromACtx, ?fromAlloc, ?fromCtx, ?from),
    var_points_to(?toACtx, ?toAlloc, ?toCtx, ?to).

  _try_memcpy(?toACtx, ?toAlloc, ?fromACtx, ?fromAlloc, 0)
  :-
    memcpy_sig(?toACtx, ?toAlloc, ?fromACtx, ?fromAlloc).

  .decl _stripctx_memcpy(?toAlloc: Allocation, ?fromAlloc: Allocation, ?size: number)
  _stripctx_memcpy(?toAlloc, ?fromAlloc, ?size) :-
    _try_memcpy(_, ?toAlloc, _, ?fromAlloc, ?size),
    ptr_compatible_allocation(?toAlloc).

  .decl _type_compatible_memcpy(?to: Allocation, ?from: Allocation, ?size: number)
  _type_compatible_memcpy(?toAlloc, ?fromAlloc, ?size) :-
    _stripctx_memcpy(?toAlloc, ?fromAlloc, ?size),
    allocation_type(?toAlloc, ?toType),
    allocation_type(?fromAlloc, ?fromType),
    type_compatible(?fromType, ?toType).

  .decl _well_typed_and_sized_memcpy(?to: Allocation, ?from: Allocation, ?size: number)
  _well_typed_and_sized_memcpy(?toAlloc, ?fromAlloc, ?size) :-
    _type_compatible_memcpy(?toAlloc, ?fromAlloc, ?size),
    ( dynamically_sized_alloc(?fromAlloc)
    ; ( allocation_size(?fromAlloc, ?fromSize)
      , ?fromSize >= ?size
      )
    ),
    ( dynamically_sized_alloc(?toAlloc)
    ; ( allocation_size(?toAlloc, ?toSize)
      , ?toSize >= ?size
      )
    ).

  .decl _do_memcpy(?toCtx: Context, ?to: Allocation, ?fromCtx: Context, ?from: Allocation)
  _do_memcpy(?toCtx, ?to, ?fromCtx, ?from) :-
    _try_memcpy(?toCtx, ?to, ?fromCtx, ?from, ?size),
    _well_typed_and_sized_memcpy(?to, ?from, ?size).










  .decl rec_memcpy(?toCtx: Context, ?to: Allocation, ?fromCtx: Context, ?from: Allocation)

  rec_memcpy(?toCtx, ?to, ?fromCtx, ?from) :-
    _do_memcpy(?toCtx, ?to, ?fromCtx, ?from).


  rec_memcpy(?toCtx, ?to, ?fromCtx, ?from) :-
    rec_memcpy(?toCtx, ?toOuter, ?fromCtx, ?fromOuter),
    alloc_subregion_offset(?fromOuter, ?from, ?offset),
    alloc_subregion_offset(?toOuter, ?to, ?offset).

  rec_memcpy(?toCtx, ?to, ?fromCtx, ?from) :-
    rec_memcpy(?toCtx, ?toOuter, ?fromCtx, ?fromOuter),
    alloc_subregion_at_any_array_index(?fromOuter, ?from),
    alloc_subregion_at_any_array_index(?toOuter, ?to).


  rec_memcpy(?toCtx, ?to, ?fromCtx, ?from) :-
    rec_memcpy(?toCtx, ?toOuter, ?fromCtx, ?fromOuter),
    alloc_subregion_offset(?fromOuter, ?from, ?offset),
    allocation_type(?toOuter, ?toOuterType),
    alloc_region(?toOuter, ?toOuterRegion),
    ( ( alloc_subregion(?toOuter)
      , array_type(?toOuterType)
      , ! array_offset(?toOuterRegion, ?toOuterType, ?offset)
      )
    ; ( basic_allocation(?toOuter)
      , ! pointer_offset(?toOuterRegion, ?toOuterType, ?offset)
      )
    ),
    alloc_subregion_at_any_array_index(?toOuter, ?to).
}
#line 23 "points-to/points-to.project"
#line 1 "field-sensitivity.dl"
#line 14 "field-sensitivity.dl"
.decl gep_zero_index_offset(?insn: GetElementPtrInstruction, ?offset: SubregionOffset)


gep_zero_index_offset(?insn, 0) :-
  getelementptr_instr_index(?insn, 0, ?indexOp),
  constant_to_int(?indexOp, 0).

gep_zero_index_offset(?insn, ?index * ?size) :-
  getelementptr_instr_index(?insn, 0, ?indexOp),
  constant_to_int(?indexOp, ?index),
  getelementptr_instr_base_type(?insn, ?ptrType),
  pointer_type_has_component(?ptrType, ?type),
  type_has_size(?type, ?size).

.comp GEP {






  .decl allocation_type(?alloc:Allocation, ?type:Type) inline
  .decl alloc_subregion_at_path_component(?component: PathComponent, ?obj: AllocSubregion) inline
  .decl alloc_subregion_at_field(?alloc: Allocation, ?index: FieldIndex, ?region: AllocSubregion) inline
  .decl alloc_subregion_at_array_index(?alloc: Allocation, ?index: ArrayIndex, ?region: AllocSubregion) inline
  .decl alloc_subregion_at_any_array_index(?alloc: Allocation, ?region: AllocSubregion) inline
  .decl alloc_subregion_offset(?alloc: Allocation, ?region: AllocSubregion, ?offset: SubregionOffset) inline
  .decl operand_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?operand: Operand) inline
#line 66 "field-sensitivity.dl"
  .decl _alloc_type_and_path(?alloc: Allocation, ?allocType: Type, ?component: PathComponent)

  _alloc_type_and_path(?alloc, ?allocType, ?component) :-
    allocation_type(?alloc, ?allocType),
    alloc_subregion_at_path_component(?component, ?alloc).

  _alloc_type_and_path(?alloc, ?allocType, ?empty) :-
    allocation_type(?alloc, ?allocType),
    basic_allocation(?alloc),
    empty_path_component(?empty).

  _alloc_type_and_path(?alloc, ?allocType, ?empty) :-
    allocation_type(?alloc, ?allocType),
    non_allocation(?alloc),
    empty_path_component(?empty).

  .decl _some_alloc_type_and_path(?allocType: Type, ?component: PathComponent)

  _some_alloc_type_and_path(?allocType, ?component) :-
    _alloc_type_and_path(_, ?allocType, ?component).

  .decl _gep_type_compatible(?gepType: Type, ?allocType: Type, ?component: PathComponent)


  _gep_type_compatible(?gepType, ?allocType, ?component) :-
    _some_alloc_type_and_path(?allocType, ?component),
    type_compatible(?gepType, ?allocType).




  _gep_type_compatible(?gepType, ?allocType, ?component) :-
    _some_alloc_type_and_path(?allocType, ?component),
    ( path_component_at_index(?component, _)
    ; path_component_at_any_index(?component)
    ),
    pointer_type_has_component(?type, ?allocType),
    type_compatible(?gepType, ?type).
#line 121 "field-sensitivity.dl"
  .decl gep_indexes_from(?insn: GetElementPtrInstruction,
                        ?index: GepIndex,
                ?baseAlloc: Allocation,
                ?alloc: Allocation,
                ?type: Type)



  gep_indexes_from(?insn, 0, ?alloc, ?alloc, ?type) :-
    !gep_is_vector_based(?insn),
    getelementptr_instr_base(?insn, ?base),
    operand_points_to(_, ?alloc, _, ?base),
    getelementptr_instr_base_type(?insn, ?type).




  gep_indexes_from(?insn, ?n, ?baseAlloc, ?alloc, ?type) :-
    getelementptr_instr_index(?insn, ?n, _),
    gep_points_to(?insn, ?n - 1, ?baseAlloc, ?alloc),
    getelementptr_instrterm_type(?insn, ?n, ?type),
    _alloc_type_and_path(?alloc, ?allocType, ?component),
    _gep_type_compatible(?type, ?allocType, ?component).



  .decl gep_points_to(?insn: GetElementPtrInstruction,
                      ?index: GepIndex,
              ?baseAlloc: Allocation,
              ?alloc: Allocation)
#line 164 "field-sensitivity.dl"
  gep_points_to(?insn, 0, ?alloc, ?alloc) :-
    gep_indexes_from(?insn, 0, ?alloc, ?alloc, ?type),
    pointer_type(?type),
    gep_zero_index_offset(?insn, 0).







  gep_points_to(?insn, 0, ?baseAlloc, ?alloc) :-
    gep_indexes_from(?insn, 0, ?baseAlloc, ?baseAlloc, ?type),
    pointer_type(?type),
    basic_allocation(?baseAlloc),
    gep_zero_index_offset(?insn, ?offset),
    alloc_subregion_offset(?baseAlloc, ?alloc, ?offset).
#line 197 "field-sensitivity.dl"
  gep_points_to(?insn, 0, ?baseAlloc, ?alloc)
    :-
    gep_indexes_from(?insn, 0, ?baseAlloc, ?baseAlloc, ?type),
    pointer_type(?type),
    basic_allocation(?baseAlloc),
    gep_zero_index_offset(?insn, ?offset),
    allocation_type(?baseAlloc, ?allocType),
    alloc_region(?baseAlloc, ?region),
    ! pointer_offset(?region, ?allocType, ?offset),
    type_has_size(?allocType, ?elemSize),
    ?elemSize != 0,
    ?offset % max(?elemSize, 1) = 0,
    alloc_subregion_at_any_array_index(?baseAlloc, ?alloc).








  gep_points_to(?insn, 0, ?baseAlloc, ?alloc) :-
    gep_indexes_from(?insn, 0, ?baseAlloc, ?baseAlloc, ?type),
    pointer_type(?type),
    alloc_subregion_at_array_index(?grandparent, _, ?baseAlloc),
    alloc_subregion_offset(?grandparent, ?baseAlloc, ?startOffset),
    gep_zero_index_offset(?insn, ?offset),
    alloc_subregion_offset(?grandparent, ?alloc, ?startOffset + ?offset).
#line 238 "field-sensitivity.dl"
  gep_points_to(?insn, 0, ?baseAlloc, ?alloc)
    :-
    gep_indexes_from(?insn, 0, ?baseAlloc, ?baseAlloc, ?type),
    pointer_type(?type),
    alloc_subregion_at_array_index(?grandparent, _, ?baseAlloc),
    alloc_subregion_offset(?grandparent, ?baseAlloc, ?startOffset),
    gep_zero_index_offset(?insn, ?offset),
    allocation_type(?grandparent, ?allocType),
    alloc_region(?grandparent, ?region),
    ( ( basic_allocation(?grandparent)
      , ! pointer_offset(?region, ?allocType, ?startOffset + ?offset)
      , type_has_size(?allocType, ?elemSize)
      )
    ; ( alloc_subregion_at_path_component(_, ?grandparent)
      , ! array_offset(?region, ?allocType, ?startOffset + ?offset)
      , array_type_has_component(?allocType, ?elemType)
      , type_has_size(?allocType, ?elemSize)
      )
    ),
    ?elemSize != 0,
    (?startOffset + ?offset) % max(?elemSize, 1) = 0,
    alloc_subregion_at_any_array_index(?grandparent, ?alloc).






  gep_points_to(?insn, 0, ?baseAlloc, ?baseAlloc) :-
    gep_indexes_from(?insn, 0, ?baseAlloc, ?baseAlloc, ?type),
    pointer_type(?type),
    alloc_subregion_at_any_array_index(_, ?baseAlloc).






  gep_points_to(?insn, 0, ?baseAlloc, ?alloc) :-
    gep_indexes_from(?insn, 0, ?baseAlloc, ?baseAlloc, ?type),
    pointer_type(?type),
    getelementptr_instr_index(?insn, 0, ?indexOp),
    ! operand_to_int(?indexOp, _),
    alloc_subregion_at_any_array_index(?baseAlloc, ?alloc).









  gep_points_to(?insn, 0, ?baseAlloc, ?alloc) :-
    gep_indexes_from(?insn, 0, ?baseAlloc, ?baseAlloc, ?type),
    array_type(?type),
    getelementptr_instr_index(?insn, 0, ?indexOp),
    ! operand_to_int(?indexOp, _),
    alloc_subregion_at_array_index(?grandparent, _, ?baseAlloc),
    alloc_subregion_at_any_array_index(?grandparent, ?alloc).
#line 311 "field-sensitivity.dl"
  gep_points_to(?insn, ?n, ?baseAlloc, ?alloc) :-
    getelementptr_instr_index(?insn, ?n, ?indexOp),
    gep_points_to(?insn, ?n - 1, ?baseAlloc, ?alloc),
    constant_to_int(?indexOp, 0).
#line 328 "field-sensitivity.dl"
  gep_points_to(?insn, ?n, ?baseAlloc, ?alloc) :-
    gep_indexes_from(?insn, ?n, ?baseAlloc, ?parent, ?type),
    struct_type(?type),
    getelementptr_instr_index(?insn, ?n, ?indexOp),
    constant_to_int(?indexOp, ?field),
    alloc_subregion_at_field(?parent, ?field, ?alloc).







  gep_points_to(?insn, ?n, ?baseAlloc, ?alloc) :-
    gep_indexes_from(?insn, ?n, ?baseAlloc, ?parent, ?type),
    pointer_type_has_component(?type, ?i8),
    int8_type(?i8),
    allocation_type(?parent, ?parentType),
    struct_type(?parentType),
    getelementptr_instr_index(?insn, ?n, ?indexOp),
    constant_to_int(?indexOp, ?offset),
    struct_type_field_offset(?parentType, ?field, ?offset),
    alloc_subregion_at_field(?parent, ?field, ?alloc).




  gep_points_to(?insn, ?n, ?baseAlloc, ?alloc) :-
    gep_indexes_from(?insn, ?n, ?baseAlloc, ?parent, ?type),
    pointer_type_has_component(?type, ?i8),
    int8_type(?i8),
    allocation_type(?parent, ?parentType),
    struct_type(?parentType),
    getelementptr_instr_index(?insn, ?n, ?indexOp),
    ! operand_to_int(?indexOp, _),
    alloc_subregion_at_field(?parent, _, ?alloc).









  gep_points_to(?insn, ?n, ?baseAlloc, ?alloc) :-
    gep_indexes_from(?insn, ?n, ?baseAlloc, ?parent, ?type),
    array_type(?type),
    getelementptr_instr_index(?insn, ?n, ?indexOp),
    constant_to_int(?indexOp, ?offset),
    alloc_subregion_at_array_index(?parent, ?offset, ?alloc).






  gep_points_to(?insn, ?n, ?baseAlloc, ?alloc) :-
    gep_indexes_from(?insn, ?n, ?baseAlloc, ?parent, ?type),
    array_type(?type),
    getelementptr_instr_index(?insn, ?n, ?indexOp),
    constant_to_int(?indexOp, ?offset),
    allocation_type(?parent, ?allocType),
    alloc_region(?parent, ?region),
    ( ( basic_allocation(?parent)
      , ! pointer_index(?region, ?allocType, ?offset)
      )
    ; ( alloc_subregion_at_path_component(_, ?parent)
      , ! array_indices(?region, ?allocType, ?offset)
      )
    ),
    alloc_subregion_at_any_array_index(?parent, ?alloc).





  gep_points_to(?insn, ?n, ?baseAlloc, ?alloc) :-
    gep_indexes_from(?insn, ?n, ?baseAlloc, ?parent, ?type),
    array_type(?type),
    getelementptr_instr_index(?insn, ?n, ?indexOp),
    ! operand_to_int(?indexOp, _),
    alloc_subregion_at_any_array_index(?parent, ?alloc).





  .decl _gep_last_index_points_to(?alloc: Allocation, ?baseAlloc: Allocation, ?insn: GetElementPtrInstruction)
  _gep_last_index_points_to(?alloc, ?baseAlloc, ?insn) :-
    gep_points_to(?insn, ?n, ?baseAlloc, ?alloc),
    getelementptr_instr_nindices(?insn, ?n + 1).

  .decl _gep_address_ctx_points_to(?ctx: Context, ?aCtx: Context, ?baseAlloc: Allocation, ?insn: GetElementPtrInstruction)
  _gep_address_ctx_points_to(?ctx, ?aCtx, ?baseAlloc, ?insn) :-
    getelementptr_instr_base(?insn, ?base),
    operand_points_to(?aCtx, ?baseAlloc, ?ctx, ?base).

  .decl gep_var_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable) inline

  gep_var_points_to(?aCtx, ?alloc, ?ctx, ?toVar) :-
    _gep_last_index_points_to(?alloc, ?baseAlloc, ?insn),
    _gep_address_ctx_points_to(?ctx, ?aCtx, ?baseAlloc, ?insn),
    instr_assigns_to(?insn, ?toVar).
}
#line 24 "points-to/points-to.project"
#line 1 "cplusplus-exceptions.dl"
#line 22 "cplusplus-exceptions.dl"
.decl cxx_alloc_exception(?func: FunctionDecl)

cxx_alloc_exception(?func),
   heap_alloc_func(?func)
 :-
   func_name(?func, "@__cxa_allocate_exception"),
   func_ty(?func, ?fType),
   func_type_param(?fType, 0, ?type),
   integer_type(?type),
   func_type_nparams(?fType, 1).




sized_alloc_instr(?insn, as(?size, Bytes)) :-
  cxx_alloc_exception(?func),
  call_instr_fn_target(?insn, ?func),
  call_instr_arg(?insn, 0, ?sizeOp),
  constant_to_int(?sizeOp, ?size).

sized_alloc_instr(?insn, as(?size, Bytes)) :-
  cxx_alloc_exception(?func),
  invoke_instr_fn_target(?insn, ?func),
  invoke_instr_arg(?insn, 0, ?sizeOp),
  constant_to_int(?sizeOp, ?size).

.type ExceptionObject = Allocation
.comp ExceptionObjectComponent {






  .decl heap_allocation_by_type_instr(?type: Type, ?insn: CallBase, ?heapAlloc: HeapAllocation) inline








  .decl untyped_allocation(?insn: AllocInstruction, ?alloc: Allocation)

  .decl _exception_object(?alloc: ExceptionObject)

  allocation(?alloc) :-
    _exception_object(?alloc).



  .decl heap_allocation_by_alloc_exc(?insn: CallBase, ?heapAlloc: HeapAllocation)

  heap_allocation_by_alloc_exc(?insn, ?heapAlloc)
  , _exception_object(?heapAlloc)
  :-
    cxx_alloc_exception(?func),
    call_instr_fn_target(?insn, ?func),
    heap_allocation_by_instr(?insn, ?heapAlloc).

  heap_allocation_by_alloc_exc(?insn, ?heapAlloc)
  , _exception_object(?heapAlloc)
  :-
    cxx_alloc_exception(?func),
    invoke_instr_fn_target(?insn, ?func),
    heap_allocation_by_instr(?insn, ?heapAlloc).






  untyped_allocation(?insn, ?excObj) :-
    inlined_constructors(),
    heap_allocation_by_alloc_exc(?insn, ?excObj).

  _exception_object(?typedExcObj)
  :-
    inlined_constructors(),
    heap_allocation_by_alloc_exc(?insn, _),
    heap_allocation_by_type_instr(_, ?insn, ?typedExcObj).
}
#line 126 "cplusplus-exceptions.dl"
.decl cxx_throw_func(?func: FunctionDecl)

cxx_throw_func(?func) :-
   func_name(?func, "@__cxa_throw"),
   func_ty(?func, ?fType),
   func_type_param(?fType, 0, ?type1),
   func_type_param(?fType, 1, ?type2),
   func_type_param(?fType, 2, ?type3),
   pointer_type(?type1),
   pointer_type(?type2),
   pointer_type(?type3),
   func_type_nparams(?fType, 3).






.decl _type_info_by_alloc(?obj: GlobalAllocation, ?excTypeInfo: GlobalVariable)
_type_info_by_alloc(?obj, ?excTypeInfo) :-
   typeinfo(?excTypeInfo),
   global_allocation_by_variable(?excTypeInfo, ?obj).




.decl external_typeinfo(?var: GlobalVariable)
typeinfo(?var),
   external_typeinfo(?var) :-
   external_linkage_type(?externalLinkage),
   global_var_linkage(?var, ?externalLinkage),
   global_var_name(?var, ?name),
   substr(?name, 0, strlen("@_ZTI")) = "@_ZTI".


.comp ThrowInstruction {







  .decl allocation_type(?alloc:Allocation, ?type:Type) inline
  .decl callgraph_edge(?calleeCtx: Context, ?callee: FunctionDecl, ?callerCtx: Context, ?callerInstr: CallBase) inline
  .decl operand_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?operand: Operand) inline
  .decl stripctx_operand_points_to(?alloc: Allocation, ?operand: Operand) inline
  .decl untyped_allocation(?insn: AllocInstruction, ?alloc: Allocation) inline








  .decl _cxx_throw_instr(?throwInsn: CallBase)
  _cxx_throw_instr(?throwInsn) :-
    cxx_throw_func(?throwFunc),
    callgraph_edge(_, ?throwFunc, _, ?throwInsn).

  .decl _cxx_throw_instr_exception(?excObj: ExceptionObject, ?throwInsn: CallBase)
  _cxx_throw_instr_exception(?excObj, ?throwInsn) :-
    _cxx_throw_instr(?throwInsn),
    actual_arg(?throwInsn, 0, ?exc),
    operand_points_to(_, ?excObj, _, ?exc).

  .decl _cxx_throw_instr_full_exception(?aCtx: Context, ?excObj: ExceptionObject, ?throwInsn: CallBase)
  _cxx_throw_instr_full_exception(?aCtx, ?excObj, ?throwInsn) :-
    _cxx_throw_instr(?throwInsn),
    actual_arg(?throwInsn, 0, ?exc),
    operand_points_to(?aCtx, ?excObj, _, ?exc).





  .decl _cxx_throw_instr_destructor(?dtor: FunctionDecl, ?throwInsn: CallBase)
  _cxx_throw_instr_destructor(?dtor, ?throwInsn) :-
    _cxx_throw_instr(?throwInsn),
    actual_arg(?throwInsn, 2, ?dtorArg),
    stripctx_operand_points_to(?alloc, ?dtorArg),
    func_by_location(?alloc, ?dtor).

  .decl _cxx_throw_instr_no_dtor(?throwInsn: CallBase)
  _cxx_throw_instr_no_dtor(?throwInsn) :-
    null_location(?null),
    _cxx_throw_instr(?throwInsn),
    actual_arg(?throwInsn, 2, ?dtorArg),
    stripctx_operand_points_to(?null, ?dtorArg).





  .decl _cxx_throw_instr_typeinfo(?excTypeInfo: GlobalVariable, ?throwInsn: CallBase)
  _cxx_throw_instr_typeinfo(?excTypeInfo, ?throwInsn) :-
    _cxx_throw_instr(?throwInsn),
    actual_arg(?throwInsn, 1, ?typeInfoArg),
    stripctx_operand_points_to(?typeInfoObj, ?typeInfoArg),
    _type_info_by_alloc(?typeInfoObj, ?excTypeInfo).
#line 240 "cplusplus-exceptions.dl"
  .decl ty_indication4(?type: Type, ?aCtx: Context, ?excObj: Allocation)
  .decl ty_indication5(?type: Type, ?aCtx: Context, ?excObj: Allocation)

  ty_indication4(?type, ?aCtx, ?excObj)
    :-
    untyped_allocation(_, ?excObj),
    _cxx_throw_instr_full_exception(?aCtx, ?excObj, ?throwInsn),
    _cxx_throw_instr_destructor(?dtor, ?throwInsn),
    class_type_destructor(?dtor, ?type).

  ty_indication5(?classType, ?aCtx, ?excObj)
    :-
    untyped_allocation(_, ?excObj),
    _cxx_throw_instr_full_exception(?aCtx, ?excObj, ?throwInsn),
    _cxx_throw_instr_typeinfo(?typeInfo, ?throwInsn),
    class_type_typeinfo(?classType, ?typeInfo).
#line 267 "cplusplus-exceptions.dl"
  .decl _typeinfo_no_class(?typeInfo: GlobalVariable)
  _typeinfo_no_class(?typeInfo) :-
    typeinfo(?typeInfo),
    !class_type_typeinfo(_, ?typeInfo).

  .decl _cxx_throws(?dtor: FunctionDecl, ?typeInfo: GlobalVariable, ?excObj: ExceptionObject, ?throwInsn: CallBase)
  _cxx_throws(?dtor, ?typeInfo, ?excObj, ?throwInsn)
    :-
    _cxx_throw_instr_exception(?excObj, ?throwInsn),
    _cxx_throw_instr_typeinfo(?typeInfo, ?throwInsn),
    _cxx_throw_instr_destructor(?dtor, ?throwInsn),
    allocation_type(?excObj, ?type),
    class_type_typeinfo(?type, ?typeInfo),
    class_type_destructor(?dtor, ?type).

  _cxx_throws(?dtor, ?typeInfo, ?excObj, ?throwInsn)
    :-
    _cxx_throw_instr_exception(?excObj, ?throwInsn),
    _cxx_throw_instr_typeinfo(?typeInfo, ?throwInsn),
    _cxx_throw_instr_destructor(?dtor, ?throwInsn),
    _typeinfo_no_class(?typeInfo),
    allocation_type(?excObj, ?type),
    class_type_destructor(?dtor, ?type).

  .decl _cxx_throws_no_dtor(?typeInfo: GlobalVariable, ?excObj: ExceptionObject, ?throwInsn: CallBase)
  _cxx_throws_no_dtor(?typeInfo, ?excObj, ?throwInsn)
    :-
    _cxx_throw_instr_exception(?excObj, ?throwInsn),
    _cxx_throw_instr_typeinfo(?typeInfo, ?throwInsn),
    _cxx_throw_instr_no_dtor(?throwInsn),
    _typeinfo_no_class(?typeInfo).

  _cxx_throws_no_dtor(?typeInfo, ?excObj, ?throwInsn)
    :-
    _cxx_throw_instr_exception(?excObj, ?throwInsn),
    _cxx_throw_instr_typeinfo(?typeInfo, ?throwInsn),
    _cxx_throw_instr_no_dtor(?throwInsn),
    allocation_type(?excObj, ?type),
    class_type_typeinfo(?type, ?typeInfo).
}
#line 25 "points-to/points-to.project"
#line 1 "signatures.dl"

.decl signature_return_alloc(?func : FunctionName)
.decl signature_return_alloc_once(?func : FunctionName)
.decl signature_return_aliases_arg(?func : FunctionName, ?index : ArgumentIndex)
.decl signature_return_aliases_arg_reachable(?func : FunctionName, ?index : ArgumentIndex)
.decl signature_return_points_to_global(?func : FunctionName, ?global : GlobalVarName)
.decl signature_return_aliases_global(?func : FunctionName, ?global : GlobalVarName)
.decl signature_return_aliases_global_reachable(?func : FunctionName, ?global : GlobalVarName)
.decl signature_arg_alloc(?func : FunctionName, ?index : ArgumentIndex)
.decl signature_arg_alloc_once(?func : FunctionName, ?index : ArgumentIndex)
.decl signature_arg_memcpy_arg(?func : FunctionName, ?index1 : ArgumentIndex, ?index2 : ArgumentIndex)
.decl signature_arg_memcpy_arg_reachable(?func : FunctionName, ?index1 : ArgumentIndex, ?index2 : ArgumentIndex)
.decl signature_arg_points_to_global(?func : FunctionName, ?index : ArgumentIndex, ?global : GlobalVarName)
.decl signature_arg_memcpy_global(?func : FunctionName, ?index : ArgumentIndex, ?global : GlobalVarName)
.decl signature_arg_memcpy_global_reachable(?func : FunctionName, ?index : ArgumentIndex, ?global : GlobalVarName)
.decl signature_global_memcpy_arg(?func : FunctionName, ?global : GlobalVarName, ?index : ArgumentIndex)
.decl signature_global_memcpy_arg_reachable(?func : FunctionName, ?global : GlobalVarName, ?index : ArgumentIndex)
.decl signature_none(?func : FunctionName)

.decl func_needs_signature(?func : FunctionDecl)
.decl func_pts_signature(?func : FunctionDecl)
.decl func_missing_signature(?func : FunctionDecl)

.decl type_has_subelement(?type : Type, ?elem : Type)

type_has_subelement(?type, ?elem) :-
  type_has_subelement(?type, ?mid),
  array_type_has_component(?mid, ?elem).

type_has_subelement(?type, ?elem) :-
  type_has_subelement(?type, ?mid),
  struct_type_field(?mid, _, ?elem).

type_has_subelement(?type, ?elem) :-
  type_has_subelement(?type, ?mid),
  vector_type_has_component(?mid, ?elem).

type_has_subelement(?type, ?type) :-
  type(?type).

func_needs_signature(?func) :-
  func_decl(?func),
  func_name(?func, ?name),
  !(func_decl_to_defn(?func,_);
    heap_alloc_func(?func);
    "@memcpy"=substr(?name,0,7);
    "@llvm.memcpy"=substr(?name,0,12)),
  func_ty(?func, ?type),
  func_type_return(?type, ?rtype),
  pointer_type(?rtype).

func_needs_signature(?func) :-
  func_decl(?func),
  func_name(?func, ?name),
  !(func_decl_to_defn(?func,_);
    heap_alloc_func(?func);
    "@memcpy"=substr(?name,0,7);
    "@llvm.memcpy"=substr(?name,0,12)),
  func_ty(?func, ?type),
  func_type_param(?type, _, ?ptype),
  pointer_type_has_component(?ptype, ?comp),
  type_has_subelement(?comp, ?elem),
  pointer_type(?elem).

func_pts_signature(?func) :-
  func_name(?func, ?name),
  (signature_none(?name);
   signature_return_alloc(?name);
   signature_return_alloc_once(?name);
   signature_return_aliases_arg(?name, _);
   signature_return_aliases_arg_reachable(?name, _);
   signature_return_points_to_global(?name, _);
   signature_return_aliases_global(?name, _);
   signature_return_aliases_global_reachable(?name, _);
   signature_arg_alloc(?name, _);
   signature_arg_alloc_once(?name, _);
   signature_arg_memcpy_arg(?name, _, _);
   signature_arg_memcpy_arg_reachable(?name, _, _);
   signature_arg_points_to_global(?name, _, _);
   signature_arg_memcpy_global(?name, _, _);
   signature_arg_memcpy_global_reachable(?name, _, _);
   signature_global_memcpy_arg(?name, _, _);
   signature_global_memcpy_arg_reachable(?name, _, _)).

func_missing_signature(?func) :-
  func_needs_signature(?func),
  !func_pts_signature(?func).





.decl build_signature_allocation(sigAlloc: SignatureAllocation, func: Function, caller: Function, type: Type, var: Variable, pos: symbol) inline
build_signature_allocation(sigAlloc, func, caller, type, var, pos) :-
  func_name(func, funcName),
  func_name(caller, callerName),
  variable_has_name(var, varName),
  sigAlloc = cat("*sig_alloc", funcName, "|", callerName, "[", type, " ", varName, "(", pos, ")", "]").

.decl build_signature_allocation_once(sigAlloc: SignatureAllocation, func: Function, type: Type, pos: symbol) inline
build_signature_allocation_once(sigAlloc, func, type, pos) :-
  func_name(func, funcName),
  sigAlloc = cat("*sig_alloc", funcName, "[", type, "(", pos, ")]").

.comp Signatures {







  .decl allocation_type(?alloc:Allocation, ?type:Type) inline
  .decl alloc_may_alias(?alloc1: Allocation, ?alloc2: Allocation) inline
  .decl alloc_with_ctx(?aCtx: Context, ?alloc: Allocation) inline
  .decl callgraph_edge(?calleeCtx: Context, ?callee: FunctionDecl, ?callerCtx: Context, ?callerInstr: CallBase) inline
  .decl reachable_context(?ctx: Context, ?func: FunctionDecl) inline
  .decl operand_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?operand: Operand) inline
  .decl ptr_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?ptr: Allocation) inline
  .decl var_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable) inline








  .decl sig_allocation_type(?alloc:Allocation, ?type:Type) inline

  .decl sig_ptr_points_to(?aCtx: Context, ?alloc: Allocation, ?ptrACtx: Context, ?ptrAlloc: Allocation)
  .decl sig_var_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable) inline

  .decl _sig_var_alloc(?aCtx: Context, ?sigAlloc: SignatureAllocation, ?ctx: Context, ?var: Variable, ?type: Type)
  .decl _sig_ptr_alloc(?aCtx: Context, ?sigAlloc: SignatureAllocation, ?ctx: Context, ?ptr: Allocation, ?type: Type)

  .decl _sig_alloc(?aCtx: Context, ?sigAlloc: SignatureAllocation, ?ctx: Context, ?type: Type) inline

  _sig_alloc(?aCtx, ?sigAlloc, ?ctx, ?type) :-
    _sig_var_alloc(?aCtx, ?sigAlloc, ?ctx, _, ?type).

  _sig_alloc(?aCtx, ?sigAlloc, ?ctx, ?type) :-
    _sig_ptr_alloc(?aCtx, ?sigAlloc, ?ctx, _, ?type).

  alloc_with_ctx(?aCtx, ?sigAlloc) :-
    _sig_alloc(?aCtx, ?sigAlloc, _, _).

  signature_allocation(?sigAlloc) :-
    _sig_alloc(_, ?sigAlloc, _, _).

  sig_allocation_type(?sigAlloc, ?type) :-
    _sig_alloc(_, ?sigAlloc, _, ?type).

  sig_var_points_to(?newCtx, ?sigAlloc, ?ctx, ?var) :-
    _sig_var_alloc(?newCtx, ?sigAlloc, ?ctx, ?var, _).

  sig_ptr_points_to(?newCtx, ?sigAlloc, ?ctx, ?ptr) :-
    _sig_ptr_alloc(?newCtx, ?sigAlloc, ?ctx, ?ptr, _).

  _sig_var_alloc(?newCtx, ?sigAlloc, ?ctx, ?var, ?type) :-
     func_name(?func, ?sname),
     signature_return_alloc(?sname),
     ( call_instr_fn_target(?instr, ?func)
     ; invoke_instr_fn_target(?instr, ?func)),
     instr_assigns_to(?instr, ?var),
     instr_func(?instr, ?instrFunc),

     variable_has_type(?var,?ptrType),
     pointer_type_has_component(?ptrType, ?type),

     reachable_context(?ctx, ?instrFunc),
     build_signature_allocation(?sigAlloc, ?func, ?instrFunc, ?ptrType, ?var, "return"),
     record(?newCtx, ?sigAlloc, ?ctx).

  _sig_var_alloc(?newCtx, ?sigAlloc, ?ctx, ?var, ?type) :-
     func_name(?func, ?sname),
     signature_return_alloc_once(?sname),
     ( call_instr_fn_target(?instr, ?func)
     ; invoke_instr_fn_target(?instr, ?func)),
     instr_assigns_to(?instr, ?var),
     instr_func(?instr, ?instrFunc),

     variable_has_type(?var,?ptrType),
     pointer_type_has_component(?ptrType, ?type),

     reachable_context(?ctx, ?instrFunc),
     build_signature_allocation_once(?sigAlloc, ?func, ?ptrType, "return"),
     empty_alloc_context(?newCtx).

  _sig_ptr_alloc(?newCtx, ?sigAlloc, ?ptrCtx, ?ptr, ?type) :-
     func_name(?func, ?sname),
     signature_arg_alloc(?sname, ?index),
     ( call_instr_fn_target(?instr, ?func)
     ; invoke_instr_fn_target(?instr, ?func)),
     instr_func(?instr, ?instrFunc),
     actual_arg(?instr, ?index, ?var),

     reachable_context(?ctx, ?instrFunc),
     var_points_to(?ptrCtx, ?ptr, ?ctx, ?var),

     allocation_type(?ptr, ?ptrType),
     pointer_type_has_component(?ptrType, ?type),

     ?indexStr = to_string(?index),
     build_signature_allocation(?sigAlloc, ?func, ?instrFunc, ?ptrType, ?var, ?indexStr),
     record(?newCtx, ?sigAlloc, ?ctx).

  _sig_ptr_alloc(?newCtx, ?sigAlloc, ?ptrCtx, ?ptr, ?type) :-
     func_name(?func, ?sname),
     signature_arg_alloc_once(?sname, ?index),
     ( call_instr_fn_target(?instr, ?func)
     ; invoke_instr_fn_target(?instr, ?func)),
     instr_func(?instr, ?instrFunc),
     actual_arg(?instr, ?index, ?var),

     reachable_context(?ctx, ?instrFunc),
     var_points_to(?ptrCtx, ?ptr, ?ctx, ?var),

     allocation_type(?ptr, ?ptrType),
     pointer_type_has_component(?ptrType, ?type),

     ?indexStr = to_string(?index),
     build_signature_allocation_once(?sigAlloc, ?func, ?ptrType, ?indexStr),
     user_options("context_sensitivity", _),
     empty_alloc_context(?newCtx).

  dynamically_sized_alloc(?sigAlloc) :-
    signature_allocation(?sigAlloc).





  .decl signature_var_points_to_base(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable)
  .decl signature_ptr_points_to_base(?aCtx: Context, ?alloc: Allocation, ?ptrACtx : Context, ?ptrAlloc : Allocation)

  .decl memcpy_sig(?toCtx: Context, ?to: Allocation, ?fromCtx: Context , ?from: Allocation)

  .decl _ptr_reaches_to_request(?ptrACtx: Context, ?ptrAlloc: Allocation)
  .decl _ptr_reaches_to(?aCtx: Context, ?alloc: Allocation, ?ptrACtx: Context, ?ptrAlloc: Allocation)

  _ptr_reaches_to(?ptrACtx, ?ptrAllocAlias, ?ptrACtx, ?ptrAlloc) :-
     _ptr_reaches_to_request(?ptrACtx, ?ptrAlloc),
     alloc_may_alias(?ptrAlloc, ?ptrAllocAlias).

  _ptr_reaches_to(?aCtx, ?allocAlias, ?ptrACtx, ?ptrAlloc) :-
     _ptr_reaches_to(?ptrMidACtx, ?ptrMid, ?ptrACtx, ?ptrAlloc),
     ptr_points_to(?aCtx, ?alloc, ?ptrMidACtx, ?ptrMid),
     alloc_may_alias(?alloc, ?allocAlias).

  signature_var_points_to_base(?aCtx, ?alloc, ?callerCtx, ?toVar) :-
     callgraph_edge(_, ?callee, ?callerCtx, ?callerInstr),
     func_name(?callee, ?name),
     signature_return_aliases_arg(?name, ?index),
     instr_assigns_to(?callerInstr, ?toVar),
     actual_arg(?callerInstr, ?index, ?fromValue),
     operand_points_to(?aCtx, ?alloc, ?callerCtx, ?fromValue).

  _ptr_reaches_to_request(?ptrACtx, ?ptrAlloc) :-
     callgraph_edge(_, ?callee, ?callerCtx, ?callerInstr),
     func_name(?callee, ?name),
     signature_return_aliases_arg_reachable(?name, ?index),
     actual_arg(?callerInstr, ?index, ?fromValue),
     operand_points_to(?ptrACtx, ?ptrAlloc, ?callerCtx, ?fromValue).

  signature_var_points_to_base(?aCtx, ?alloc, ?callerCtx, ?toVar) :-
     callgraph_edge(_, ?callee, ?callerCtx, ?callerInstr),
     func_name(?callee, ?name),
     signature_return_aliases_arg_reachable(?name, ?index),
     instr_assigns_to(?callerInstr, ?toVar),
     actual_arg(?callerInstr, ?index, ?fromValue),
     operand_points_to(?ptrACtx, ?ptrAlloc, ?callerCtx, ?fromValue),
     _ptr_reaches_to(?aCtx, ?alloc, ?ptrACtx, ?ptrAlloc).

  signature_var_points_to_base(?aCtx, ?alloc, ?callerCtx, ?toVar) :-
     callgraph_edge(_, ?callee, ?callerCtx, ?callerInstr),
     func_name(?callee, ?name),
     signature_return_points_to_global(?name, ?globalName),
     global_allocation_by_name(?globalName, ?alloc),
     empty_context(?aCtx),
     instr_assigns_to(?callerInstr, ?toVar).

  signature_var_points_to_base(?aCtx, ?alloc, ?callerCtx, ?toVar) :-
     callgraph_edge(_, ?callee, ?callerCtx, ?callerInstr),
     func_name(?callee, ?name),
     signature_return_aliases_global(?name, ?globalName),
     global_allocation_by_name(?globalName, ?globalAlloc),
     empty_context(?globalCtx),
     instr_assigns_to(?callerInstr, ?toVar),
     ptr_points_to(?aCtx, ?alloc, ?globalCtx, ?globalAlloc).

  _ptr_reaches_to_request(?globalCtx, ?globalAlloc) :-
     callgraph_edge(_, ?callee, _, ?callerInstr),
     func_name(?callee, ?name),
     signature_return_aliases_global_reachable(?name, ?globalName),
     global_allocation_by_name(?globalName, ?globalAlloc),
     empty_context(?globalCtx),
     instr_assigns_to(?callerInstr, _).

  signature_var_points_to_base(?aCtx, ?alloc, ?callerCtx, ?toVar) :-
     callgraph_edge(_, ?callee, ?callerCtx, ?callerInstr),
     func_name(?callee, ?name),
     signature_return_aliases_global_reachable(?name, ?globalName),
     global_allocation_by_name(?globalName, ?globalAlloc),
     empty_context(?globalCtx),
     instr_assigns_to(?callerInstr, ?toVar),
     _ptr_reaches_to(?aCtx, ?alloc, ?globalCtx, ?globalAlloc).

  memcpy_sig(?toACtx, ?toAlloc, ?fromACtx, ?fromAlloc) :-
     callgraph_edge(_, ?callee, ?callerCtx, ?callerInstr),
     func_name(?callee, ?name),
     signature_arg_memcpy_arg(?name, ?toIndex, ?fromIndex),
     actual_arg(?callerInstr, ?toIndex, ?toValue),
     actual_arg(?callerInstr, ?fromIndex, ?fromValue),
     operand_points_to(?toACtx, ?toAlloc, ?callerCtx, ?toValue),
     operand_points_to(?fromACtx, ?fromAlloc, ?callerCtx, ?fromValue).

  _ptr_reaches_to_request(?fromPtrACtx, ?fromPtrAlloc) :-
     callgraph_edge(_, ?callee, ?callerCtx, ?callerInstr),
     func_name(?callee, ?name),
     signature_arg_memcpy_arg_reachable(?name, ?toIndex, ?fromIndex),
     actual_arg(?callerInstr, ?toIndex, ?toValue),
     actual_arg(?callerInstr, ?fromIndex, ?fromValue),
     operand_points_to(_, _, ?callerCtx, ?toValue),
     operand_points_to(?fromPtrACtx, ?fromPtrAlloc, ?callerCtx, ?fromValue).

  memcpy_sig(?toACtx, ?toAlloc, ?fromACtx, ?fromAlloc) :-
     callgraph_edge(_, ?callee, ?callerCtx, ?callerInstr),
     func_name(?callee, ?name),
     signature_arg_memcpy_arg_reachable(?name, ?toIndex, ?fromIndex),
     actual_arg(?callerInstr, ?toIndex, ?toValue),
     actual_arg(?callerInstr, ?fromIndex, ?fromValue),
     operand_points_to(?toACtx, ?toAlloc, ?callerCtx, ?toValue),
     operand_points_to(?fromPtrACtx, ?fromPtrAlloc, ?callerCtx, ?fromValue),
     _ptr_reaches_to(?fromACtx, ?fromAlloc, ?fromPtrACtx, ?fromPtrAlloc).

  signature_ptr_points_to_base(?gACtx, ?gAlloc, ?ptrACtx, ?ptrAlloc) :-
     callgraph_edge(_, ?callee, ?callerCtx, ?callerInstr),
     func_name(?callee, ?name),
     signature_arg_points_to_global(?name, ?index, ?globalName),
     actual_arg(?callerInstr, ?index, ?toValue),
     operand_points_to(?ptrACtx, ?ptrAlloc, ?callerCtx, ?toValue),
     global_allocation_by_name(?globalName, ?gAlloc),
     empty_context(?gACtx).

  memcpy_sig(?toACtx, ?toAlloc, ?fromACtx, ?fromAlloc) :-
     callgraph_edge(_, ?callee, ?callerCtx, ?callerInstr),
     func_name(?callee, ?name),
     signature_arg_memcpy_global(?name, ?index, ?globalName),
     actual_arg(?callerInstr, ?index, ?toValue),
     operand_points_to(?toACtx, ?toAlloc, ?callerCtx, ?toValue),
     global_allocation_by_name(?globalName, ?fromAlloc),
     empty_context(?fromACtx).

  _ptr_reaches_to_request(?gACtx, ?gAlloc) :-
     callgraph_edge(_, ?callee, ?callerCtx, ?callerInstr),
     func_name(?callee, ?name),
     signature_arg_memcpy_global_reachable(?name, ?index, ?globalName),
     actual_arg(?callerInstr, ?index, ?toValue),
     operand_points_to(_, _, ?callerCtx, ?toValue),
     global_allocation_by_name(?globalName, ?gAlloc),
     empty_context(?gACtx).

  memcpy_sig(?toACtx, ?toAlloc, ?fromACtx, ?fromAlloc) :-
     callgraph_edge(_, ?callee, ?callerCtx, ?callerInstr),
     func_name(?callee, ?name),
     signature_arg_memcpy_global_reachable(?name, ?index, ?globalName),
     actual_arg(?callerInstr, ?index, ?toValue),
     operand_points_to(?toACtx, ?toAlloc, ?callerCtx, ?toValue),
     global_allocation_by_name(?globalName, ?gAlloc),
     empty_context(?gACtx),
     _ptr_reaches_to(?fromACtx, ?fromAlloc, ?gACtx, ?gAlloc).

  memcpy_sig(?toACtx, ?toAlloc, ?fromACtx, ?fromAlloc) :-
     callgraph_edge(_, ?callee, ?callerCtx, ?callerInstr),
     func_name(?callee, ?name),
     signature_global_memcpy_arg(?name, ?globalName, ?index),
     actual_arg(?callerInstr, ?index, ?toValue),
     operand_points_to(?fromACtx, ?fromAlloc, ?callerCtx, ?toValue),
     global_allocation_by_name(?globalName, ?toAlloc),
     empty_context(?toACtx).

  _ptr_reaches_to_request(?ptrACtx, ?ptrAlloc) :-
     callgraph_edge(_, ?callee, ?callerCtx, ?callerInstr),
     func_name(?callee, ?name),
     signature_global_memcpy_arg_reachable(?name, _, ?index),
     actual_arg(?callerInstr, ?index, ?toValue),
     operand_points_to(?ptrACtx, ?ptrAlloc, ?callerCtx, ?toValue).

  memcpy_sig(?toACtx, ?toAlloc, ?fromACtx, ?fromAlloc) :-
     callgraph_edge(_, ?callee, ?callerCtx, ?callerInstr),
     func_name(?callee, ?name),
     signature_global_memcpy_arg_reachable(?name, ?globalName, ?index),
     actual_arg(?callerInstr, ?index, ?toValue),
     operand_points_to(?ptrACtx, ?ptrAlloc, ?callerCtx, ?toValue),
     global_allocation_by_name(?globalName, ?toAlloc),
     empty_context(?toACtx),
     _ptr_reaches_to(?fromACtx, ?fromAlloc, ?ptrACtx, ?ptrAlloc).





  sig_var_points_to(?baseACtx, ?baseAlloc, ?callerCtx, ?toVar) :-
     signature_var_points_to_base(?baseACtx, ?baseAlloc, ?callerCtx, ?toVar),
     variable_has_type(?toVar, ?toPtrType),
     pointer_type_has_component(?toPtrType, ?toType),
     allocation_type(?baseAlloc, ?allocType),
     type_compatible(?allocType, ?toType).









  sig_ptr_points_to(?baseACtx, ?baseAlloc, ?ptrACtx, ?ptrAlloc) :-
     signature_ptr_points_to_base(?baseACtx, ?baseAlloc, ?ptrACtx, ?ptrAlloc),
     allocation_type(?baseAlloc, ?allocType),
     allocation_type(?ptrAlloc, ?ptrType),
     pointer_type_has_component(?ptrType, ?toType),
     type_compatible(?allocType, ?toType).
#line 451 "signatures.dl"
}
#line 26 "points-to/points-to.project"
#line 1 "types.dl"

.type Bytes <: number


.type LineNumber <: number


.type ColumnNumber <: number


.type FunctionName <: symbol


.type GlobalVarName <: symbol

.type GlobalName
  = FunctionName
  | GlobalVarName


.type GepIndex <: number


.type ArrayIndex <: number


.type FieldIndex <: number


.type ArgumentIndex <: number
#line 27 "points-to/points-to.project"
#line 1 "region.dl"


.type Region <: symbol
.decl region(r: Region)
.decl global_region(r: Region)
.decl heap_region(r: Region)
.decl stack_region(r: Region)
region(r) :- global_region(r).
region(r) :- heap_region(r).
region(r) :- stack_region(r).

heap_region("heap").
stack_region("stack").
global_region("global").
region("func").
region("null").
region("unknown").

.decl alloc_region(?alloc: Allocation, ?region: Region)

alloc_region(?alloc, "null") :- null_location(?alloc).
alloc_region(?alloc, "unknown") :- unknown_location(?alloc).
alloc_region(?alloc, "heap") :- argv_alloc(?alloc).
alloc_region(?alloc, "heap") :- argv_ptr_points_to(_, ?alloc).
alloc_region(?alloc, "heap") :- heap_allocation(?alloc).
alloc_region(?alloc, "heap") :- heap_allocation_by_new(_, ?alloc).
alloc_region(?alloc, "stack") :- stack_allocation(?alloc).
alloc_region(?alloc, "global") :- global_allocation_by_variable(_, ?alloc).



alloc_region(?alloc, as(?func, Region)),
  region(as(?func, Region))
  :-
  global_allocation_by_func(?func, ?alloc).
#line 28 "points-to/points-to.project"
#line 6 "common.project"
#line 1 "context/context.project"
#line 1 "drop.dl"




.decl drop_context_by_invoc(?invoc: Instruction)
.decl drop_context_item_by_invoc(?invoc: Instruction)
#line 26 "drop.dl"
.decl num_direct_calls_to_func(?n: number, ?func: FunctionDecl)
num_direct_calls_to_func(?n, ?func) :-
  func_decl(?func),
  ?n = count : _instr_calls_func(_, ?func).

.decl call_or_invoke_instr_fn_type(?instr: Instruction, ?type: Type)
call_or_invoke_instr_fn_type(?instr, ?fnType) :-
  ( call_instr_fn_type(?instr, ?fnType)
  ; invoke_instr_fn_type(?instr, ?fnType)
  ).

.decl indirect_call_or_invoke_instr(?instr: Instruction)
indirect_call_or_invoke_instr(?instr) :-
  indirect_call_instr(?instr);
  indirect_invoke_instr(?instr).

.decl num_indirect_calls_to_compatible_func(?n: number, ?func: FunctionDecl)
num_indirect_calls_to_compatible_func(?n, ?func) :-
  func_ty(?func, ?targetType),
  ?n = count : {
    indirect_call_or_invoke_instr(?instr),
    call_or_invoke_instr_fn_type(?instr, ?fnType),
    type_compatible(?fnType, ?targetType)
  }.

.decl max_num_callsites(?func: FunctionDecl, ?n: number)
max_num_callsites(?func, ?n1 + ?n2) :-
  num_direct_calls_to_func(?n1, ?func),
  num_indirect_calls_to_compatible_func(?n2, ?func).

drop_context_item_by_invoc(?invoc) :-
  user_option_value("drop_redundant_context_entries", "on"),
  _instr_calls_func(?invoc, ?func),
  max_num_callsites(?func, 1).





.decl type_contains_pointer(?type: Type)
type_contains_pointer(?type) :-
  type_has_subelement(?type, ?sub),
  pointer_type(?sub).

.decl func_type_has_pointer_arg(?funcType: FunctionType)
func_type_has_pointer_arg(?funcType) :-
  func_type_param(?funcType, _, ?paramType),
  type_contains_pointer(?paramType).

.decl func_type_has_no_pointer_args(?funcType: FunctionType)
func_type_has_no_pointer_args(?funcType) :-
  func_type(?funcType),
  !func_type_has_pointer_arg(?funcType).

.decl func_type_has_pointer_return(?funcType: FunctionType)
func_type_has_pointer_return(?funcType) :-
  func_type_return(?funcType, ?returnType),
  type_contains_pointer(?returnType).

.decl func_type_has_no_pointer_return(?funcType: FunctionType)
func_type_has_no_pointer_return(?funcType) :-
  func_type(?funcType),
  !func_type_has_pointer_return(?funcType).

drop_context_by_invoc(?invoc) :-
  user_option_value("drop_redundant_contexts", "on"),
  ( call_instr_func_operand(?invoc, ?funcOp)
  ; invoke_instr_func_operand(?invoc, ?funcOp)
  ),
  operand_has_type(?funcOp, ?funcOpType),
  pointer_type_has_component(?funcOpType, ?declaredType),
  func_type_has_no_pointer_args(?declaredType),
  func_type_has_no_pointer_return(?declaredType).
#line 2 "context/context.project"
#line 1 "interface.dl"
.type ContextItem = CallBase | symbol










.type Context = [
    head : ContextItem,
    tail : Context
]


.decl context(ctx: Context)

.decl max_context_depth(n: number)

.decl insensitive()
insensitive() :- user_options("context_sensitivity", "insensitive").

max_context_depth(n) :-
  !insensitive(),
  user_options("context_sensitivity", Config),
  ns = substr(Config, 0, 1),
  n = to_number(ns).





.decl context_depth(n: number, ctx: Context)

context_depth(0, nil).
context_depth(1 + tailLen, [head, tail]) :-
  context([head, tail]),
  context_depth(tailLen, tail).

.decl drop_last(out: Context, in: Context)

drop_last(nil, ?in)
  :-
  context_depth(1, ?in).

drop_last(?out, ?in),
  context(?out)
  :-
  context(?in),


  ?in = [?head, [?tailHead, nil]],
  ?out = [?head, nil].

drop_last(?out, ?in),
  context(?out)
  :-
  context(?in),
  ?in = [?head, [?tailHead, ?tailTail]],
  drop_last(?droppedTailTail, ?tailTail),
  ?out = [?head, [?tailHead, ?droppedTailTail]].


.comp Merge {







  .decl reachable_context(?ctx: Context, ?func: FunctionDecl) inline








  .decl _reachable_call(?ctx: Context, ?instr: CallBase)
  _reachable_call(?ctx, ?instr) :-
    (call_instr(?instr); invoke_instr(?instr)),
    instr_func(?instr, ?func),
    reachable_context(?ctx, ?func).







  .decl merge(?newCtx: Context,
              ?callerInstr: CallBase,
              ?callerCtx: Context)


  merge(?oldCtx,
        ?callerInstr,
        ?oldCtx)
   :-
    ! insensitive(),
    _reachable_call(?oldCtx, ?callerInstr),
    drop_context_item_by_invoc(?callerInstr),
    ! drop_context_by_invoc(?callerInstr).


  merge(nil,
        ?callerInstr,
        ?oldCtx)
   :-
    ! insensitive(),
    _reachable_call(?oldCtx, ?callerInstr),
    drop_context_by_invoc(?callerInstr).


  merge(?oldCtx,
        ?callerInstr,
        ?oldCtx)
   :-
    _reachable_call(?oldCtx, ?callerInstr),
    insensitive().


  merge(?newCtx,
        ?callerInstr,
        ?callerCtx),
   context(?newCtx)
   :-
    ! insensitive(),
    _reachable_call(?callerCtx, ?callerInstr),
    context_depth(?callerCtxDepth, ?callerCtx),
    max_context_depth(?maxDepth),
    ?callerCtxDepth < ?maxDepth,
    context_item_by_invoc(?callerInstr, ?newItem),
    ?newCtx = [?newItem, ?callerCtx].


  merge(?newCtx,
        ?callerInstr,
        ?callerCtx),
   context(?newCtx)
   :-
    ! insensitive(),
    _reachable_call(?callerCtx, ?callerInstr),
    context_depth(?callerCtxDepth, ?callerCtx),
    max_context_depth(?maxDepth),
    ?callerCtxDepth = ?maxDepth,
    drop_last(?droppedCallerCtx, ?callerCtx),
    context_item_by_invoc(?callerInstr, ?newItem),
    ?newCtx = [?newItem, ?droppedCallerCtx].





  .decl count_context_items(?instr: CallBase, ?nContextItems: number)
  count_context_items(?instr, ?nContextItems) :-
    (call_instr(?instr); invoke_instr(?instr)),
    !drop_context_by_invoc(?instr),
    !drop_context_item_by_invoc(?instr),
    ?nContextItems = count : context_item_by_invoc(?instr, _).

  .decl count_contexts(?instr: CallBase, ?nContexts: number)
  count_contexts(?instr, ?nContexts) :-
    (call_instr(?instr); invoke_instr(?instr)),
    !drop_context_by_invoc(?instr),
    !drop_context_item_by_invoc(?instr),

    ?nContexts = count : merge(_, ?instr, _).

  .decl assert_reachable_calls_have_context_items(?instr: CallBase)
  assert_reachable_calls_have_context_items(?instr) :-
    user_options("context_sensitivity", _),
    _reachable_call(_, ?instr),
    count_context_items(?instr, 0).

  .decl assert_reachable_calls_have_contexts(?instr: CallBase)
  assert_reachable_calls_have_contexts(?instr) :-
    user_options("context_sensitivity", _),
    _reachable_call(_, ?instr),
    count_contexts(?instr, 0).
}





.decl alloc_context(?ctx : Context)




.decl record(?out: Context, alloc: symbol, ?in: Context) inline

record(?ctx, ?alloc, ?ctx), alloc_context(?ctx) :- context(?ctx).





.decl empty_alloc_context(?ctx: Context)
alloc_context(nil).
empty_alloc_context(nil).

.decl empty_context(?ctx: Context)
.decl main_context(?ctx: Context)
.decl startup_context(?ctx: Context)
.decl exit_context(?ctx: Context)

context(nil).
empty_context(nil).

context(?ctx),
  main_context(?ctx)
  :-
  ?ctx = ["<<main-context>>", nil].

context(?ctx),
  startup_context(?ctx)
  :-
  ?ctx = ["<<startup-context>>", nil].

context(?ctx),
  exit_context(?ctx)
  :-
  ?ctx = ["<<exit_context>>", nil].





.decl context_item_by_invoc(?invoc : CallBase, ?ctxItem : ContextItem)
.decl context_item_by_invoc_interim(?invoc : CallBase, ?ctxItem : ContextItem)

context_item_by_invoc(?invoc, ?ctxItem) :-
  context_item_by_invoc_interim(?invoc, ?ctxItem),
  !drop_context_by_invoc(?invoc),
  !drop_context_item_by_invoc(?invoc).

context_item_by_invoc_interim(?invoc, ?ctxItem) :-
  user_options("context_sensitivity", Config),
  ( Config = "insensitive"
  ; Config = "1-callsite"
  ; Config = "2-callsite"
  ; Config = "3-callsite"
  ; Config = "4-callsite"
  ; Config = "5-callsite"
  ; Config = "6-callsite"
  ; Config = "7-callsite"
  ; Config = "8-callsite"
  ; Config = "9-callsite"
  ),
  (call_instr(?invoc);
   invoke_instr(?invoc)),
  ?ctxItem = ?invoc.

context_item_by_invoc_interim(?invoc, ?ctxItem) :-
  user_options("context_sensitivity", Config),
  ( Config = "1-caller"
  ; Config = "2-caller"
  ; Config = "3-caller"
  ; Config = "4-caller"
  ; Config = "5-caller"
  ; Config = "6-caller"
  ; Config = "7-caller"
  ; Config = "8-caller"
  ; Config = "9-caller"
  ),
  (call_instr(?invoc); invoke_instr(?invoc)),
  instr_func(?invoc, ?func),
  func_name(?func, ?name),
  ?ctxItem = ?name.





.decl context_to_string(ctx: Context, str: symbol)
context_to_string(nil, "nil").
context_to_string(ctx, str) :-
  context(ctx),
  ctx = [item, tail],
  context_to_string(tail, tailStr),
  str = cat(item, "#", tailStr).
#line 3 "context/context.project"
#line 1 "lift.dl"






.comp Lift {






  .decl alloc_aliases(?alloc1: Allocation, ?alloc2: Allocation) inline
  .decl alloc_may_alias(?alloc1: Allocation, ?alloc2: Allocation) inline
  .decl alloc_subregion_at_path(?alloc: Allocation, ?path: Path, ?subAlloc: Allocation) inline
  .decl alloc_subregion_base(?alloc: AllocSubregion, ?baseAlloc: Allocation) inline
  .decl reachable_context(?ctx: Context, ?func: FunctionDecl) inline
  .decl operand_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?operand: Operand) inline
  .decl ptr_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?ptr: Allocation) inline
  .decl var_points_to(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable) inline





  .decl _allocation_with_context(?aCtx: Context, ?alloc: Allocation)

  _allocation_with_context(?aCtx, ?alloc) :-
    var_points_to(?aCtx, ?alloc, _, _).

  _allocation_with_context(?aCtx, ?alloc) :-
    ptr_points_to(?aCtx, ?alloc, _, _).

  _allocation_with_context(?aCtx, ?alloc) :-
    ptr_points_to(_, _, ?aCtx, ?alloc).

  _allocation_with_context(?aCtx, ?alloc) :-
    operand_points_to(?aCtx, ?alloc, _, _).

  .decl alloc_may_alias_ctx(?aCtx: Context, ?alloc1: Allocation, ?alloc2: Allocation)

  alloc_may_alias_ctx(?aCtx, ?alloc1, ?alloc2) :-
    _allocation_with_context(?aCtx, ?alloc1),
    _allocation_with_context(?aCtx, ?alloc2),
    alloc_may_alias(?alloc1, ?alloc2).

  .decl alloc_must_alias_ctx(?aCtx: Context, ?alloc1: Allocation, ?alloc2: Allocation)

  alloc_must_alias_ctx(?aCtx, ?alloc1, ?alloc2) :-
    _allocation_with_context(?aCtx, ?alloc1),
    _allocation_with_context(?aCtx, ?alloc2),
    alloc_aliases(?alloc1, ?alloc2).

  .decl alloc_subregion_ctx(?aCtx: Context, ?alloc1: Allocation, ?alloc2: Allocation)

  alloc_subregion_ctx(?aCtx, ?alloc1, ?alloc2) :-
    _allocation_with_context(?aCtx, ?alloc1),
    _allocation_with_context(?aCtx, ?alloc2),
    alloc_subregion_base(?alloc1, ?alloc2).

  .decl alloc_contains_ctx(?aCtx: Context, ?alloc1: Allocation, ?alloc2: Allocation)

  alloc_contains_ctx(?aCtx, ?alloc1, ?alloc2) :-
    _allocation_with_context(?aCtx, ?alloc1),
    _allocation_with_context(?aCtx, ?alloc2),
    alloc_subregion_at_path(?alloc1, _, ?alloc2).

  .decl allocation_by_instr_ctx(?ctx: Context, ?insn: Instruction, ?aCtx: Context, ?alloc: Allocation)

  allocation_by_instr_ctx(ctx, insn, actx, alloc) :-
    reachable_context(ctx, fun),
    instr_func(insn, fun),
    allocation_by_instr(insn, alloc),
    instr_assigns_to(insn, var),
    var_points_to(actx, alloc, ctx, var).

  .decl allocation_size_ctx(?actx: Context, ?alloc: Allocation, ?size: number)

  allocation_size_ctx(actx, alloc, size) :-
    allocation_size(alloc, size),
    var_points_to(actx, alloc, _, _).
}
#line 4 "context/context.project"
#line 7 "common.project"
#line 1 "options/user-options.dl"
.decl user_options(?key : symbol, ?value : symbol)
.decl user_option_valid_value(?key : symbol, ?value : symbol)
.decl user_option_default(?key : symbol, ?value : symbol)

.decl user_option_selected(?key : symbol, ?value : symbol)
.decl user_option_invalid(?key : symbol, ?value : symbol)
.decl user_option_defaulted(?key : symbol, ?value : symbol)
.decl user_option_value(?key : symbol, ?value : symbol)

user_option_selected(?key, ?value) :-
  user_options(?key, ?value),
  user_option_valid_value(?key, ?value).

user_option_invalid(?key, ?value) :-
  user_options(?key, ?value),
  !user_option_valid_value(?key, ?value).

user_option_defaulted(?key, ?value) :-
  user_option_default(?key, ?value),
  !user_option_selected(?key, _).

user_option_value(?key, ?value) :-
  user_option_selected(?key, ?value).

user_option_value(?key, ?value) :-
  user_option_defaulted(?key, ?value).








user_option_valid_value("context_sensitivity","insensitive").
user_option_valid_value("context_sensitivity","1-callsite").
user_option_valid_value("context_sensitivity","2-callsite").
user_option_valid_value("context_sensitivity","3-callsite").
user_option_valid_value("context_sensitivity","4-callsite").
user_option_valid_value("context_sensitivity","5-callsite").
user_option_valid_value("context_sensitivity","6-callsite").
user_option_valid_value("context_sensitivity","7-callsite").
user_option_valid_value("context_sensitivity","8-callsite").
user_option_valid_value("context_sensitivity","9-callsite").
user_option_valid_value("context_sensitivity","1-caller").
user_option_valid_value("context_sensitivity","2-caller").
user_option_valid_value("context_sensitivity","3-caller").
user_option_valid_value("context_sensitivity","4-caller").
user_option_valid_value("context_sensitivity","5-caller").
user_option_valid_value("context_sensitivity","6-caller").
user_option_valid_value("context_sensitivity","7-caller").
user_option_valid_value("context_sensitivity","8-caller").
user_option_valid_value("context_sensitivity","9-caller").

user_option_default("context_sensitivity","insensitive").







user_option_valid_value("drop_redundant_context_entries","on").
user_option_valid_value("drop_redundant_context_entries","off").

user_option_default("drop_redundant_context_entries","on").







user_option_valid_value("drop_redundant_contexts","on").
user_option_valid_value("drop_redundant_contexts","off").

user_option_default("drop_redundant_contexts","on").










user_option_valid_value("entrypoints","main").
user_option_valid_value("entrypoints","library").

user_option_default("entrypoints","main").









user_option_valid_value("pointer_arithmetic","on").
user_option_valid_value("pointer_arithmetic","off").

user_option_default("pointer_arithmetic","on").
#line 121 "options/user-options.dl"
user_option_valid_value("optimized_code","on").
user_option_valid_value("optimized_code","off").

user_option_default("optimized_code","on").
#line 8 "common.project"
#line 2 "subset-and-unification.project"
#line 1 "export/subset.dl"
.output subset.callgraph.callgraph_edge (compress=true)
.output subset.var_points_to (compress=true)
.output subset.ptr_points_to (compress=true)
.output subset.operand_points_to (compress=true)
.output subset_lift.allocation_size_ctx (compress=true)
.output subset_lift.alloc_must_alias_ctx (compress=true)
.output subset_lift.alloc_may_alias_ctx (compress=true)
.output subset_lift.alloc_subregion_ctx (compress=true)
.output subset_lift.alloc_contains_ctx (compress=true)
.output subset_lift.allocation_by_instr_ctx (compress=true)
.output global_allocation_by_variable (compress=true)
.output context_to_string (compress=true)
#line 3 "subset-and-unification.project"
#line 1 "export/unification.dl"
.output unification.callgraph.callgraph_edge (compress=true)
.output unification.var_points_to_final (compress=true)
.output unification.ptr_points_to_final (compress=true)
.output unification.operand_points_to_final (compress=true)
.output unification_lift.allocation_size_ctx (compress=true)
.output unification_lift.alloc_must_alias_ctx (compress=true)
.output unification_lift.alloc_may_alias_ctx (compress=true)
.output unification_lift.alloc_subregion_ctx (compress=true)
.output unification_lift.alloc_contains_ctx (compress=true)
.output unification_lift.allocation_by_instr_ctx (compress=true)
.output global_allocation_by_variable (compress=true)
.output context_to_string (compress=true)
#line 4 "subset-and-unification.project"
#line 1 "points-to/assertions.dl"
#line 12 "points-to/assertions.dl"
.decl assert_every_allocation_has_a_type(?alloc: Allocation)
assert_every_allocation_has_a_type(?alloc) :-
  allocation(?alloc),
  ! argv_alloc(?alloc),
  ! subset_allocation_type.allocation_type(?alloc, _),
  ! unification_allocation_type.allocation_type(?alloc, _).

.decl assert_array_type_size(?type: Type, ?numElems: number, ?elemSize: number, ?size: number)
assert_array_type_size(?type, ?numElems, ?elemSize, ?size) :-
  array_type_has_component(?type, ?elemType),
  type_has_size(?type, ?size),
  array_type_has_size(?type, ?numElems),
  type_has_size(?elemType, ?elemSize),
  ?numElems * ?elemSize != ?size.

.decl assert_type_has_size(?type: Type)
assert_type_has_size(?type) :-
  type(?type),
  ! func_type(?type),
  ! opaque_struct_type(?type),
  ! void_type(?type),
  ! label_type(?type),
  ! metadata_type(?type),
  ! x86mmx_type(?type),
  ! type_has_size(?type, _).

.decl assert_type_unique_size(?type: Type, ?sz1: number, ?sz2: number)
assert_type_unique_size(?type, ?sz1, ?sz2) :-
  type_has_size(?type, ?sz1),
  type_has_size(?type, ?sz2),
  ?sz1 != ?sz2.





.decl _assert_type_compatible_relaxed(?from: Type, ?to: Type) eqrel
.decl _assert_type_compatible_relaxed_inner(?from: Type, ?to: Type)









_assert_type_compatible_relaxed(?from, ?to) :-
  type_compatible(?from, ?to).




_assert_type_compatible_relaxed(?integerType, ?to) :-
  integer_type(?integerType),
  int8_type(?i8Type),
  pointer_type_has_component(?i8PtrType, ?i8Type),
  _assert_type_compatible_relaxed(?i8PtrType, ?to).









_assert_type_compatible_relaxed(?fromPtr, ?toPtr) :-
  pointer_type_has_component(?fromPtr, ?from),
  pointer_type_has_component(?toPtr, ?to),
  _assert_type_compatible_relaxed_inner(?from, ?to).

_assert_type_compatible_relaxed(?fromPtr, ?toPtr) :-
  pointer_type_has_component(?fromPtr, ?from),
  array_type_has_component(?toPtr, ?to),
  _assert_type_compatible_relaxed_inner(?from, ?to).

_assert_type_compatible_relaxed(?fromPtr, ?toPtr) :-
  array_type_has_component(?fromPtr, ?from),
  pointer_type_has_component(?toPtr, ?to),
  _assert_type_compatible_relaxed_inner(?from, ?to).

_assert_type_compatible_relaxed(?fromPtr, ?toPtr) :-
  array_type_has_component(?fromPtr, ?from),
  array_type_has_component(?toPtr, ?to),
  _assert_type_compatible_relaxed_inner(?from, ?to).

_assert_type_compatible_relaxed_inner(?from, ?to) :-
  type_compatible(?from, ?to).

_assert_type_compatible_relaxed_inner(?from, ?to) :-
  struct_type_field(?from, 0, ?element),
  _assert_type_compatible_relaxed_inner(?element, ?to).

_assert_type_compatible_relaxed_inner(?from, ?to) :-
  type_compatible_up_to_arg(?from, ?to, _).

.decl assert_type_compatible_constant_points_to(?from: Constant, ?to: Allocation, ?fromType: Type, ?toType: Type)
assert_type_compatible_constant_points_to(?from, ?to, ?fromTy, ?toTy) :-
  constant_points_to(?from, ?to),
  constant_has_type(?from, ?fromTy),
  subset_allocation_type.allocation_type(?to, ?toTy),
  pointer_type_has_component(?toTyPtr, ?toTy),
  ! null_location(?to),
  ! unknown_location(?to),
  ! _assert_type_compatible_relaxed(?fromTy, ?toTyPtr).

.decl _assert_type_compatible_ptr_points_to_alias(?from: Allocation, ?to: Allocation)

_assert_type_compatible_ptr_points_to_alias(?from, ?to) :-
  subset.ptr_points_to(_, ?to, _, ?from),
  subset_aliases.alloc_aliases(?from, ?fromAlias),
  subset_aliases.alloc_aliases(?to, ?toAlias),
  subset_allocation_type.allocation_type(?fromAlias, ?fromTy),
  subset_allocation_type.allocation_type(?toAlias, ?toTy),
  pointer_type_has_component(?toTyPtr, ?toTy),
  _assert_type_compatible_relaxed(?fromTy, ?toTyPtr).

.decl assert_type_compatible_ptr_points_to(?from: Allocation, ?to: Allocation, ?fromType: Type, ?toType: Type)
assert_type_compatible_ptr_points_to(?from, ?to, ?fromTy, ?toTy) :-
  subset.ptr_points_to(_, ?to, _, ?from),
  subset_allocation_type.allocation_type(?from, ?fromTy),
  subset_allocation_type.allocation_type(?to, ?toTy),
  ! null_location(?to),
  ! unknown_location(?to),
  ! _assert_type_compatible_ptr_points_to_alias(?from, ?to).


.decl failing_assert_type_compatible_var_points_to(?from: Variable, ?to: Allocation, ?fromType: Type, ?toType: Type)
failing_assert_type_compatible_var_points_to(?from, ?to, ?fromTy, ?toTy) :-
  subset.var_points_to(_, ?to, _, ?from),
  variable_has_type(?from, ?fromTy),
  subset_allocation_type.allocation_type(?to, ?toTy),
  pointer_type_has_component(?toTyPtr, ?toTy),
  ! null_location(?to),
  ! unknown_location(?to),
  ! _assert_type_compatible_relaxed(?fromTy, ?toTyPtr).





.decl assert_alloc_with_ctx_complete(?aCtx: Context, ?alloc: Allocation)
assert_alloc_with_ctx_complete(?aCtx, ?alloc) :-
  subset.operand_points_to(?aCtx, ?alloc, _, _),
  ! subset_allocations.alloc_with_ctx(?aCtx, ?alloc).

assert_alloc_with_ctx_complete(?aCtx, ?alloc) :-
  subset.ptr_points_to(?aCtx, ?alloc, _, _),
  ! subset_allocations.alloc_with_ctx(?aCtx, ?alloc).

assert_alloc_with_ctx_complete(?aCtx, ?alloc) :-
  unification.unify(_, _, ?aCtx, ?alloc),
  ! unification_allocations.alloc_with_ctx(?aCtx, ?alloc).





.decl _assert_every_gep_instr_points_to_something(?ctx: Context, ?insn: GetElementPtrInstruction)
_assert_every_gep_instr_points_to_something(?ctx, ?insn) :-
  subset_gep._gep_address_ctx_points_to(?ctx, _, ?alloc, ?insn),
  subset_gep._gep_last_index_points_to(_, ?alloc, ?insn).




.decl failing_assert_every_gep_instr_points_to_something(?ctx: Context, ?insn: GetElementPtrInstruction)
failing_assert_every_gep_instr_points_to_something(?ctx, ?insn) :-
  subset_gep._gep_address_ctx_points_to(?ctx, _, _, ?insn),
  ! _assert_every_gep_instr_points_to_something(?ctx, ?insn).

.decl assert_every_gep_constant_expr_points_to_something(?cExpr: GetElementPtrConstantExpression)
assert_every_gep_constant_expr_points_to_something(?cExpr) :-
  getelementptr_constant_expression_nindices(?cExpr, _),
  ! constant_points_to(?cExpr, _).

.decl assert_every_pointer_constant_points_to_something(?constant: Constant)
assert_every_pointer_constant_points_to_something(?constant) :-
  constant_has_type(?constant, ?constantType),
  pointer_type(?constantType),
  ! constant_points_to(?constant, _),
  ! undef_constant(?constant),
  ! inline_asm(?constant).








.decl failing_assert_reachable_pointer_vars_point_to_something(?var: Variable)
failing_assert_reachable_pointer_vars_point_to_something(?var) :-
  instr_assigns_to(?inst, ?var),
  subset.callgraph.reachable_instr(?inst),
  variable_has_type(?var, ?ty),
  pointer_type(?ty),
  ! subset.var_points_to(_, _, _, ?var).





.decl assert_global_allocations_have_static_types(?alloc: GlobalAllocation)
  assert_global_allocations_have_static_types(?alloc) :-
  global_allocation(?alloc),
  ! static_allocation_type(?alloc, _).

.decl assert_global_allocations_have_dynamic_types(?alloc: GlobalAllocation)
assert_global_allocations_have_dynamic_types(?alloc) :-
   global_allocation(?alloc),
   ! subset_allocation_type.allocation_type(?alloc, _).

.decl assert_global_allocations_have_one_type(?alloc: GlobalAllocation)
assert_global_allocations_have_one_type(?alloc) :-
  global_allocation(?alloc),
  subset_allocation_type.allocation_type(?alloc, ?type1),
  subset_allocation_type.allocation_type(?alloc, ?type2),
  ?type1 != ?type2.



.decl failing_assert_global_allocations_have_sizes(?alloc: GlobalAllocation)
failing_assert_global_allocations_have_sizes(?alloc) :-


   global_allocation_by_variable(_, ?alloc),
   ! allocation_size(?alloc, _).
#line 253 "points-to/assertions.dl"
.decl assert_var_points_to_implies_reachable(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable)
assert_var_points_to_implies_reachable(?aCtx, ?alloc, ?ctx, ?toVar) :-
  subset.var_points_to(?aCtx, ?alloc, ?ctx, ?toVar),
  instr_assigns_to(?instr, ?toVar),
  instr_func(?instr, ?instrFunc),
  ! subset.callgraph.reachable_context(?ctx, ?instrFunc).


.decl assert_bitcast_operand_in_same_func(?bitcastInstr: Instruction)
assert_bitcast_operand_in_same_func(?bitcastInstr) :-
  bitcast_instr_from_operand(?bitcastInstr, ?fromOperand),
  instr_assigns_to(?instr, ?fromOperand),
  instr_func(?bitcastInstr, ?instrFunc),
  ! instr_func(?instr, ?instrFunc).

.decl assert_reachable_direct_calls_have_callees(?ctx: Context, ?call : Instruction)

assert_reachable_direct_calls_have_callees(?ctx, ?call) :-
  subset.callgraph.reachable_context(?ctx, ?instrFunc),
  instr_func(?call, ?instrFunc),
  direct_call_instr(?call),
  call_instr_func_operand(?call, ?funcOp),
  ! undef_constant(?funcOp),
  ! subset.callgraph.callgraph_edge(_, _, ?ctx, ?call).
#line 295 "points-to/assertions.dl"
.decl assert_subset_var_points_to_inhabited_implies_unification(?ctx: Context, ?var: Variable)
assert_subset_var_points_to_inhabited_implies_unification(?ctx, ?var) :-
  subset.var_points_to(_, _, ?ctx, ?var),
  ! unification.var_points_to_final(_, _, ?ctx, ?var).



.decl assert_subset_aliases_are_unification_aliases(?uCtx: Context, ?uAlloc: Allocation, ?aCtx: Context, ?alloc: Allocation, ?var1: Variable, ?var2: Variable)
assert_subset_aliases_are_unification_aliases(?uCtx, ?uAlloc, ?aCtx, ?alloc, ?var1, ?var2) :-
   subset.var_points_to(?aCtx, ?alloc, ?ctx1, ?var1),
   subset.var_points_to(?aCtx, ?alloc, ?ctx2, ?var2),
   unification.unify_repr(?aCtx, ?alloc, ?uCtx, ?uAlloc),
   unification.var_points_to_final(?uCtx, ?uAlloc, ?ctx1, ?var1),
   ! unification.var_points_to_final(?uCtx, ?uAlloc, ?ctx2, ?var2).
.plan 0: (1, 2, 3, 4),
      1: (2, 1, 3, 4),
      2: (3, 4, 1, 2),
      3: (4, 3, 2, 1)



.decl assert_unification_var_points_to_unique(?ctx: Context, ?var: Variable)
assert_unification_var_points_to_unique(?ctx, ?var) :-
  unification.var_points_to_choice(_, ?alloc1, ?ctx, ?var, ?region, ?type, ?info),
  unification.var_points_to_choice(_, ?alloc2, ?ctx, ?var, ?region, ?type, ?info),
  ?alloc1 != ?alloc2.
.plan 0: (1, 2),
      1: (2, 1)

assert_unification_var_points_to_unique(?ctx, ?var) :-
  unification.var_points_to_choice(?aCtx1, _, ?ctx, ?var, ?region, ?type, ?info),
  unification.var_points_to_choice(?aCtx2, _, ?ctx, ?var, ?region, ?type, ?info),
  ?aCtx1 != ?aCtx2.
.plan 0: (1, 2),
      1: (2, 1)

.decl assert_subset_reachable_ctx_implies_unification_reachable_ctx(?ctx: Context, ?func: FunctionDecl)
assert_subset_reachable_ctx_implies_unification_reachable_ctx(?ctx, ?func) :-
  subset.callgraph.reachable_context(?ctx, ?func),
  ! unification.callgraph.reachable_context(?ctx, ?func).

.decl assert_subset_callgraph_edge_implies_unification_callgraph_edge(?calleeCtx: Context, ?callee: FunctionDecl, ?callerCtx: Context, ?callerInstr: Instruction)
assert_subset_callgraph_edge_implies_unification_callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr) :-
  subset.callgraph.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr),
  ! unification.callgraph.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr).

.decl assert_every_allocation_has_a_region(?alloc: Allocation)
assert_every_allocation_has_a_region(?alloc) :-
  allocation(?alloc),
  ! alloc_region(?alloc, _).

.decl assert_every_allocation_has_one_region(?alloc: Allocation)
assert_every_allocation_has_one_region(?alloc) :-
  allocation(?alloc),
  alloc_region(?alloc, ?region1),
  alloc_region(?alloc, ?region2),
  ?region1 != ?region2.

.decl assert_has_repr(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable)
assert_has_repr(?aCtx, ?alloc, ?ctx, ?var) :-
  unification.var_points_to(?aCtx, ?alloc, ?ctx, ?var),
  ! unification.unify_repr(?aCtx, ?alloc, _, _).

.decl assert_unique_repr(?inpCtx: Context, ?inpAlloc: Allocation)
assert_unique_repr(?inpCtx, ?inpAlloc) :-
  unification.unify_repr(?inpCtx, ?inpAlloc, ?reprCtx1, _),
  unification.unify_repr(?inpCtx, ?inpAlloc, ?reprCtx2, _),
  ?reprCtx1 != ?reprCtx2.
.plan 0: (1, 2),
      1: (2, 1)

assert_unique_repr(?inpCtx, ?inpAlloc) :-
  unification.unify_repr(?inpCtx, ?inpAlloc, _, ?reprAlloc1),
  unification.unify_repr(?inpCtx, ?inpAlloc, _, ?reprAlloc2),
  ?reprAlloc1 != ?reprAlloc2.
.plan 0: (1, 2),
      1: (2, 1)

.decl _typed_alloc(?alloc: Allocation)
_typed_alloc(?alloc) :-
  unification.type_indication.heap_allocation_by_type_instr(_, _, ?alloc).
_typed_alloc(?alloc) :-
  unification.type_indication.stack_allocation_by_type_instr(_, _, ?alloc).
_typed_alloc(?subAlloc) :-
  _typed_alloc(?alloc),
  unification_subobjects.alloc_subregion_base(?alloc, ?subAlloc).





.decl assert_basic_or_path(?alloc: Allocation)
assert_basic_or_path(?alloc) :-
  allocation(?alloc),
  !basic_allocation(?alloc),
  !subset_subobjects.alloc_subregion_at_path(_, _, ?alloc),
  !unification_subobjects.alloc_subregion_at_path(_, _, ?alloc),
  !_typed_alloc(?alloc).





.decl assert_dynamic_or_known_size(?alloc: Allocation)
assert_dynamic_or_known_size(?alloc) :-
  allocation(?alloc),
  ! global_allocation_by_func(_, ?alloc),
  ! allocation_size(?alloc, _),
  ! dynamically_sized_alloc(?alloc).

.decl assert_size_less_than_parent(?alloc: Allocation, ?size: number, ?subAlloc: Allocation, ?subSize: number)
assert_size_less_than_parent(?alloc, ?size, ?subAlloc, ?subSize) :-
  allocation_size(?alloc, ?size),
  subset_subobjects.alloc_subregion_offset(?alloc, ?subAlloc, ?offset),
  allocation_size(?subAlloc, ?subSize),


  as(?offset, number) < ?size,
  ?subSize > ?size.

.decl assert_size_sum_less_than_parent(?alloc: Allocation)
assert_size_sum_less_than_parent(?alloc) :-
  allocation_size(?alloc, ?size),
  ?sumSize = sum ?subSize : {

    subset_subobjects._alloc_subregion(?subAlloc, ?alloc, _, _, _, _),

    subset_subobjects.alloc_subregion_offset(?alloc, ?subAlloc, ?offset),
    as(?offset, number) < ?size,
    allocation_size(?subAlloc, ?subSize)
  },
  ?sumSize > ?size.
#line 5 "subset-and-unification.project"
#line 1 "points-to/points-to-statistics.dl"





variable_in_func(?var, ?func) :-
   variable_in_func_name(?var, ?funcName),
   func_name(?func, ?funcName).



.decl reachable_var(?var: Variable)
.decl reachable_vars(?nVars: number)
.decl empty_var(?var: Variable)
.decl nonempty_var(?var: Variable)
.decl empty_vars(?nVars: number)
.decl nonempty_vars(?nVars: number)
.decl var_points_to_sizes(?var: Variable, ?nAllocs: number)
.decl nvars_by_pt_size(?nAllocs: number, ?nVars: number)
.decl empty_ptr(?ptr: Allocation)
.decl empty_ptrs(?nPtrs: number)
.decl nonempty_ptr(?ptr: Allocation)
.decl nonempty_ptrs(?nPtrs: number)
.decl alloc_points_to_sizes(?alloc: Allocation, ?nAllocs: number)
.decl _alloc_pt_size(?nAllocs: number, ?alloc: Allocation)
.decl nallocs_by_pt_size(?nAllocs: number, ?nPtrs: number)
.decl var_alias(?var1 : Variable, ?var2 : Variable)
.decl var_alias_sizes(?var : Variable, ?nAlias : number)
.decl stripctx_var_alias(?var1 : Variable, ?var2 : Variable)

reachable_var(?var) :-
   variable_in_func(?var, ?func),
   subset.callgraph.reachable_func(?func).

reachable_vars(?nVars) :-
   ?nVars = count : reachable_var(_).









empty_var(?var) :-
   variable(?var),
   !subset.stripctx.stripctx_var_points_to(_, ?var).

nonempty_var(?var) :-
   subset.stripctx.stripctx_var_points_to(_, ?var).

empty_vars(?nVars) :-
   ?nVars = count : empty_var(_).

nonempty_vars(?nVars) :-
   ?nVars = count : nonempty_var(_).



var_points_to_sizes(?var, ?nAllocs) :-
   variable(?var),
   ?nAllocs = count : subset.stripctx.stripctx_var_points_to(_, ?var).





stripctx_var_alias(?var1, ?var2) :-
  subset.stripctx.stripctx_var_points_to(?alloc, ?var1),
  !null_location(?alloc),
  subset.stripctx.stripctx_var_points_to(?alloc, ?var2),
  ?var1 != ?var2.

var_alias(?var1, ?var2) :-
  stripctx_var_alias(?var1, ?var2),
  subset.var_points_to(?aCtx, ?alloc, _, ?var1),
  !null_location(?alloc),
  subset.var_points_to(?aCtx, ?alloc, _, ?var2).

var_alias_sizes(?var, ?nAlias) :-
  reachable_var(?var),
  ?nAlias = count : var_alias(?var, _).



nvars_by_pt_size(?nAllocs, ?nVars) :-
   var_points_to_sizes(_, ?nAllocs),
   ?nVars = count : var_points_to_sizes(_, ?nAllocs).
#line 113 "points-to/points-to-statistics.dl"
empty_ptr(?ptr) :-
   allocation(?ptr),
   !subset.stripctx.stripctx_ptr_points_to(_, ?ptr).

empty_ptrs(?nPtrs) :-
   ?nPtrs = count : empty_ptr(_).

nonempty_ptr(?ptr) :-
   subset.stripctx.stripctx_ptr_points_to(_, ?ptr).

nonempty_ptrs(?nPtrs) :-
   ?nPtrs = count : nonempty_ptr(_).



alloc_points_to_sizes(?alloc, ?nAllocs) :-
   subset.stripctx.stripctx_ptr_points_to(_, ?alloc),
   ?nAllocs = count : subset.stripctx.stripctx_ptr_points_to(_, ?alloc).

_alloc_pt_size(?nAllocs, ?alloc) :-
   alloc_points_to_sizes(?alloc, ?nAllocs).





nallocs_by_pt_size(?nAllocs, ?nPtrs) :-
   _alloc_pt_size(?nAllocs, _),
   ?nPtrs = count : _alloc_pt_size(?nAllocs, _).
#line 162 "points-to/points-to-statistics.dl"
.decl func_calls_func(?caller: Function, ?callee: Function)
func_calls_func(?caller, ?callee) :-
  instr_func(?callerInstr, ?caller),
  subset.callgraph.callgraph_edge(_, ?callee, _, ?callerInstr).


.decl func_out_degree(?funcName: FunctionName, ?degree: number)

.decl func_degree(?funcName: FunctionName, ?degree: number)

.decl funcs_by_in_degree(?degree: number, ?funcs: number)

.decl funcs_by_out_degree(?degree: number, ?funcs: number)

func_out_degree(?funcName, ?degree) :-
   func_name(?func, ?funcName),
   ?degree = count : func_calls_func(?func, _).

func_degree(?funcName, ?degree) :-
   func_name(?func, ?funcName),
   ?degree = count : func_calls_func(_, ?func).

funcs_by_out_degree(?degree, ?funcs) :-
   func_out_degree(_, ?degree),
   ?funcs = count : func_out_degree(_, ?degree).

funcs_by_in_degree(?degree, ?funcs) :-
   func_degree(_, ?degree),
   ?funcs = count : func_degree(_, ?degree).
#line 6 "subset-and-unification.project"
#line 1 "points-to/subset.dl"
#line 12 "points-to/subset.dl"
.comp SubsetPointsTo : PointsTo {

  var_points_to(?aCtx, ?alloc, ?toCtx, ?toVar) :-
    interp_assignment.interp_assignment(?toCtx, ?toVar, ?fromCtx, ?fromValue),
    operand_points_to(?aCtx, ?alloc, ?fromCtx, ?fromValue).


  ptr_points_to(?aCtx, ?alloc, ?baseACtx, ?baseAlloc1) :-
    ptr_points_to(?aCtx, ?alloc, ?baseACtx, ?baseAlloc2),
    subset_aliases.alloc_aliases(?baseAlloc1, ?baseAlloc2).



  ptr_points_to(?aCtx, ?alloc1, ?baseACtx, ?baseAlloc) :-
    ptr_points_to(?aCtx, ?alloc2, ?baseACtx, ?baseAlloc),
    subset_aliases.alloc_aliases(?alloc1, ?alloc2).
  .plan 0: (1, 2),
        1: (2, 1)





  ptr_points_to(?aCtx, ?alloc, ?baseACtx, ?baseAlloc) :-
     callgraph.reachable_store(?ctx, ?toAddress, ?value),
     operand_points_to(?aCtx, ?alloc, ?ctx, ?value),
     operand_points_to(?baseACtx, ?baseAlloc, ?ctx, ?toAddress),
     ptr_compatible_allocation(?baseAlloc).
  .plan 0: (1, 2, 3, 4),
        1: (2, 1, 3, 4),
        2: (3, 1, 2, 4),
        3: (4, 3, 1, 2)

  var_points_to(?aCtx, ?alloc, ?ctx, ?toVar) :-
     callgraph.reachable_load(?ctx, ?toVar, ?fromAddress),
     operand_points_to(?baseACtx, ?baseAlloc, ?ctx, ?fromAddress),
     ptr_points_to(?aCtx, ?alloc, ?baseACtx, ?baseAlloc).
  .plan 0: (1, 2, 3),
        1: (2, 1, 3),
        2: (3, 2, 1)







  var_points_to(?aCtx, ?alloc, ?ctx, ?toVar) :-
    callgraph.reachable_load(?ctx, ?toVar, ?fromAddress),
    operand_points_to(?baseACtx, ?origAlloc, ?ctx, ?fromAddress),
    subset_aliases.alloc_matches(?lessGenericAlloc, ?origAlloc),
    ptr_points_to(?aCtx, ?alloc, ?baseACtx, ?lessGenericAlloc).





  ptr_points_to(?aCtx, ?alloc, ?ptrACtx, ?origAlloc) :-
    ptr_points_to(?aCtx, ?alloc, ?ptrACtx, ?moreGenericAlloc),
    subset_aliases.alloc_matches(?origAlloc, ?moreGenericAlloc).
}

.init subset = SubsetPointsTo

subset.callgraph.called_at_exit(?func) :-
  subset_at_exit.called_at_exit(?func).


subset.var_points_to(?aCtx, ?typedAlloc, ?ctx, ?var) :-
  subset.type_indication.assign_rebase_alloc(?typedAlloc, ?aCtx, ?alloc, ?var),
  subset.var_points_to(?aCtx, ?alloc, ?ctx, ?var).

.init subset_signatures = Signatures

subset_signatures.allocation_type(?alloc, ?type) :-
  subset_allocation_type.allocation_type(?alloc, ?type).

subset_signatures.alloc_may_alias(?alloc1, ?alloc2) :-
  subset_aliases.alloc_may_alias(?alloc1, ?alloc2).

subset_signatures.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr) :-
  subset.callgraph.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr).

subset_signatures.reachable_context(?ctx, ?func) :-
  subset.callgraph.reachable_context(?ctx, ?func).

subset_signatures.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand) :-
  subset.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand).

subset_signatures.ptr_points_to(?aCtx, ?alloc, ?ctx, ?ptr) :-
  subset.ptr_points_to(?aCtx, ?alloc, ?ctx, ?ptr).

subset_signatures.var_points_to(?aCtx, ?alloc, ?ctx, ?var) :-
  subset.var_points_to(?aCtx, ?alloc, ?ctx, ?var).


subset.ptr_points_to(?aCtx, ?alloc, ?ctx, ?operand) :-
  subset_signatures.sig_ptr_points_to(?aCtx, ?alloc, ?ctx, ?operand).

subset.var_points_to(?aCtx, ?alloc, ?ctx, ?var) :-
  subset_signatures.sig_var_points_to(?aCtx, ?alloc, ?ctx, ?var).

.init subset_memcpy = Memcpy

subset_memcpy.allocation_type(?alloc, ?type) :-
  subset_allocation_type.allocation_type(?alloc, ?type).

subset_memcpy.alloc_subregion(?alloc) :-
  subset_subobjects.alloc_subregion(?alloc).

subset_memcpy.alloc_subregion_at_any_array_index(?alloc, ?region) :-
  subset_subobjects.alloc_subregion_at_any_array_index(?alloc, ?region).

subset_memcpy.alloc_subregion_offset(?alloc, ?region, ?offset) :-
  subset_subobjects.alloc_subregion_offset(?alloc, ?region, ?offset).

subset_memcpy.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr) :-
  subset.callgraph.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr).

subset_memcpy.memcpy_sig(?toCtx, ?to, ?fromCtx, ?from) :-
  subset_signatures.memcpy_sig(?toCtx, ?to, ?fromCtx, ?from).

subset_memcpy.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand) :-
  subset.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand).

subset_memcpy.var_points_to(?aCtx, ?alloc, ?ctx, ?var) :-
  subset.var_points_to(?aCtx, ?alloc, ?ctx, ?var).

subset.ptr_points_to(?aCtx, ?alloc, ?toCtx, ?to) :-
   subset_memcpy.rec_memcpy(?toCtx, ?to, ?fromCtx, ?from),
   subset.ptr_points_to(?aCtx, ?alloc, ?fromCtx, ?from).

.init subset_gep = GEP

subset_gep.allocation_type(?alloc, ?type) :-
  subset_allocation_type.allocation_type(?alloc, ?type).

subset_gep.alloc_subregion_at_path_component(?component, ?region) :-
  subset_subobjects.alloc_subregion_at_path_component(_, ?component, ?region).

subset_gep.alloc_subregion_at_field(?alloc, ?index, ?region) :-
  subset_subobjects.alloc_subregion_at_field(?alloc, ?index, ?region).

subset_gep.alloc_subregion_at_array_index(?alloc, ?index, ?region) :-
  subset_subobjects.alloc_subregion_at_array_index(?alloc, ?index, ?region).

subset_gep.alloc_subregion_at_any_array_index(?alloc, ?region) :-
  subset_subobjects.alloc_subregion_at_any_array_index(?alloc, ?region).

subset_gep.alloc_subregion_offset(?base, ?subAlloc, ?offset) :-
  subset_subobjects.alloc_subregion_offset(?base, ?subAlloc, ?offset).

subset_gep.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand) :-
  subset.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand).

subset.var_points_to(?aCtx, ?alloc, ?ctx, ?toVar) :-
  subset_gep.gep_var_points_to(?aCtx, ?alloc, ?ctx, ?toVar).

.init subset_cplusplus = CPlusPlus

subset_cplusplus.allocation_type(?alloc, ?type) :-
  subset_allocation_type.allocation_type(?alloc, ?type).

subset_cplusplus.stripctx_operand_points_to(?to, ?op) :-
  subset.stripctx.stripctx_operand_points_to(?to, ?op).

.init subset_at_exit = AtExit

subset_at_exit.alloc_aliases(?alloc1, ?alloc2) :-
  subset_aliases.alloc_aliases(?alloc1, ?alloc2).

subset_at_exit.reachable_context(?ctx, ?func) :-
  subset.callgraph.reachable_context(?ctx, ?func).

subset_at_exit.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr) :-
  subset.callgraph.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr).

subset_at_exit.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand) :-
  subset.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand).

subset.var_points_to(?aCtx, ?alloc, ?ctx, ?var) :-
  subset_at_exit.at_exit_var_points_to(?aCtx, ?alloc, ?ctx, ?var).

.init subset_allocations = Allocations

alloc_context(?aCtx) :- subset_allocations.alloc_with_ctx(?aCtx, _).

subset_allocations.alloc_subregion_base(?alloc, ?base) :-
  subset_subobjects.alloc_subregion_base(?alloc, ?base).

subset_allocations.alloc_with_ctx(?aCtx, ?alloc) :-
  subset_signatures.alloc_with_ctx(?aCtx, ?alloc).

subset_allocations.alloc_with_ctx(?aCtx, ?alloc) :-
  subset.type_indication.alloc_with_ctx(?aCtx, ?alloc).

subset_allocations.reachable_context(?ctx, ?func) :-
  subset.callgraph.reachable_context(?ctx, ?func).
subset.var_points_to(?aCtx, ?alloc, ?ctx, ?var) :-
  subset_allocations.allocated_at(?aCtx, ?alloc, ?ctx, ?var).

.init subset_allocation_type = AllocationType

subset_allocation_type.alloc_subregion_type(?alloc, ?type) :-
  subset_subobjects.alloc_subregion_type(?alloc, ?type).

subset_allocation_type.backpropagated_allocation_type(?alloc, ?type) :-
  subset.type_indication.backpropagated_allocation_type(?alloc, ?type).

subset_allocation_type.sig_allocation_type(?alloc, ?type) :-
  subset_signatures.sig_allocation_type(?alloc, ?type).

subset_allocation_type.is_init_by_ctor(?type, ?ctor, ?inFunction, ?alloc) :-
  subset_cplusplus.is_init_by_ctor(?type, ?ctor, ?inFunction, ?alloc).

subset_allocation_type.heap_allocation_by_alloc_exc(?insn, ?heapAlloc) :-
  subset.exception_object.heap_allocation_by_alloc_exc(?insn, ?heapAlloc).

.init subset_subobjects = AllocSubobjects

subset_subobjects.allocation_type(?alloc, ?type) :-
  subset_allocation_type.allocation_type(?alloc, ?type).

subset_subobjects.input_allocation_size(?alloc, ?size) :-
  allocation_size(?alloc, ?size).

static_subobjects.input_allocation_size(?alloc, ?size) :-
  allocation_size(?alloc, ?size).


subset_subobjects._alloc_subregion(?allocSub, ?base, ?component, ?root, ?path, ?type) :-
  static_subobjects._alloc_subregion(?allocSub, ?base, ?component, ?root, ?path, ?type).
subset_subobjects._non_func_basic_allocation(?alloc) :-
  static_subobjects._non_func_basic_allocation(?alloc).
subset_subobjects.alloc_subregion_at_field(?alloc, ?index, ?region) :-
  static_subobjects.alloc_subregion_at_field(?alloc, ?index, ?region).
subset_subobjects.alloc_subregion_at_any_array_index(?alloc, ?region) :-
  static_subobjects.alloc_subregion_at_any_array_index(?alloc, ?region).
subset_subobjects.alloc_subregion_at_array_index(?alloc, ?index, ?region) :-
  static_subobjects.alloc_subregion_at_array_index(?alloc, ?index, ?region).

.init subset_aliases = Aliases

subset_aliases.alloc_subregion_at_field(?alloc, ?index, ?region) :-
  subset_subobjects.alloc_subregion_at_field(?alloc, ?index, ?region).

subset_aliases.alloc_subregion_at_array_index(?alloc, ?index, ?region) :-
  subset_subobjects.alloc_subregion_at_array_index(?alloc, ?index, ?region).

subset_aliases.alloc_subregion_at_any_array_index(?alloc, ?region) :-
  subset_subobjects.alloc_subregion_at_any_array_index(?alloc, ?region).

.init subset_lift = Lift

subset_lift.alloc_aliases(?alloc1, ?alloc2) :-
  subset_aliases.alloc_aliases(?alloc1, ?alloc2).
subset_lift.alloc_may_alias(?alloc1, ?alloc2) :-
  subset_aliases.alloc_may_alias(?alloc1, ?alloc2).

subset_lift.alloc_subregion_at_path(?base, ?path, ?obj) :-
  subset_subobjects.alloc_subregion_at_path(?base, ?path, ?obj).

subset_lift.alloc_subregion_base(?base, ?obj) :-
  subset_subobjects.alloc_subregion_base(?base, ?obj).

subset_lift.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand) :-
  subset.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand).

subset_lift.reachable_context(?ctx, ?func) :-
  subset.callgraph.reachable_context(?ctx, ?func).

subset_lift.ptr_points_to(?aCtx, ?alloc, ?ctx, ?ptr) :-
  subset.ptr_points_to(?aCtx, ?alloc, ?ctx, ?ptr).

subset_lift.var_points_to(?aCtx, ?alloc, ?ctx, ?var) :-
  subset.var_points_to(?aCtx, ?alloc, ?ctx, ?var).

alloc_region(?subAlloc, ?region) :-
  subset_subobjects.alloc_subregion_base(?subAlloc, ?alloc),
  alloc_region(?alloc, ?region).
alloc_region(?alloc, "heap") :-
  subset.exception_object.heap_allocation_by_alloc_exc(_, ?alloc).
alloc_region(?alloc, "heap") :-
  subset.type_indication.heap_allocation_by_type_instr(_, _, ?alloc).
alloc_region(?alloc, "heap") :-
  subset_signatures.sig_allocation_type(?alloc, _).
alloc_region(?alloc, "stack") :-
  subset.type_indication.stack_allocation_by_type_instr(_, _, ?alloc).
#line 7 "subset-and-unification.project"
#line 1 "points-to/unification.dl"
#line 24 "points-to/unification.dl"
.comp UnificationPointsTo : PointsTo {
#line 78 "points-to/unification.dl"
  .decl var_points_to_choice(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable, ?region: Region, ?type: Type, ?info: GEPAllocInfo) choice-domain (?ctx, ?var, ?region, ?type, ?info)
  .decl ptr_points_to_choice(?aCtx: Context, ?alloc: Allocation, ?ptrACtx: Context, ?ptrAlloc: Allocation, ?region: Region, ?type: Type, ?info: GEPAllocInfo) choice-domain (?ptrACtx, ?ptrAlloc, ?region, ?type, ?info)

  .type GEPAllocInfo = PathComponent | symbol

  .decl _gep_alloc_info(?alloc: Allocation, ?info: GEPAllocInfo)

  _gep_alloc_info(?alloc, "basic") :- basic_allocation(?alloc).
  _gep_alloc_info(?alloc, "basic") :- non_allocation(?alloc).

  _gep_alloc_info(?alloc, "struct") :-
    unification_subobjects.alloc_subregion_at_path_component(_, ?component, ?alloc),
    path_component_at_field(?component, _).

  _gep_alloc_info(?alloc, ?component) :-
    unification_subobjects.alloc_subregion_at_path_component(_, ?component, ?alloc),
    path_component_at_any_index(?component).

  _gep_alloc_info(?alloc, ?alloc) :-
    unification_subobjects.alloc_subregion_at_path_component(_, ?component, ?alloc),
    path_component_at_index(?component, _).










  var_points_to(?aCtx, ?alloc, ?ctx, ?var) :-
    var_points_to_choice(?aCtx, ?alloc, ?ctx, ?var, _, _, _).


  var_points_to_choice(?aCtx, ?alloc, ?ctx, ?var, ?region, ?type, ?info) :-
    unify_var_expanded(?aCtx, ?alloc, ?ctx, ?var, ?region, ?type, ?info).




  .decl _unify_allocation_info(?alloc: Allocation, ?region: Region, ?type: Type, ?info: GEPAllocInfo)
  _unify_allocation_info(?alloc, ?region, ?type, ?info) :-
    alloc_region(?alloc, ?region),

    ( unification_allocation_type.allocation_type(?alloc, ?type)
    ; ( non_allocation(?alloc)
      , int8_type(?type)
      )
    ),
    _gep_alloc_info(?alloc, ?info).

  .decl unify_var_expanded(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable, ?region: Region, ?type: Type, ?info: GEPAllocInfo)
  unify_var_expanded(?aCtx, ?alloc, ?ctx, ?var, ?region, ?type, ?info) :-
    unify_var(?aCtx, ?alloc, ?ctx, ?var),
    _unify_allocation_info(?alloc, ?region, ?type, ?info).


  .decl unify_var(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable)

  unify_var(?aCtx, ?alloc, ?toCtx, ?toVar) :-
    interp_assignment.interp_assignment(?toCtx, ?toVar, ?fromCtx, ?fromValue),
    operand_points_to(?aCtx, ?alloc, ?fromCtx, ?fromValue).





  ptr_points_to(?aCtx, ?alloc, ?ctx, ?ptr) :-
    ptr_points_to_choice(?aCtx, ?alloc, ?ctx, ?ptr, _, _, _).

  .decl unify_ptr_expanded(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?ptr: Allocation, ?region: Region, ?type: Type, ?info: GEPAllocInfo)
  unify_ptr_expanded(?aCtx, ?alloc, ?ctx, ?ptr, ?region, ?type, ?info) :-
    unify_ptr(?aCtx, ?alloc, ?ctx, ?ptr),
    _unify_allocation_info(?alloc, ?region, ?type, ?info).


  .decl unify_ptr(?aCtx: Context, ?alloc: Allocation, ?baseACtx: Context, ?ptr: Allocation)

  ptr_points_to_choice(?aCtx, ?alloc, ?baseACtx, ?ptr, ?region, ?type, ?info) :-
    unify_ptr_expanded(?aCtx, ?alloc, ?baseACtx, ?ptr, ?region, ?type, ?info).


  unify_ptr(?aCtx, ?alloc, ?baseACtx, ?baseAlloc1) :-
    ptr_points_to(?aCtx, ?alloc, ?baseACtx, ?baseAlloc2),
    unification_aliases.alloc_aliases(?baseAlloc1, ?baseAlloc2).



  unify_ptr(?aCtx, ?alloc1, ?baseACtx, ?baseAlloc) :-
    ptr_points_to(?aCtx, ?alloc2, ?baseACtx, ?baseAlloc),
    unification_aliases.alloc_aliases(?alloc1, ?alloc2).
  .plan 0: (1, 2),
        1: (2, 1)





  unify_ptr(?aCtx, ?alloc, ?baseACtx, ?baseAlloc) :-
     callgraph.reachable_store(?ctx, ?toAddress, ?value),
     operand_points_to(?aCtx, ?alloc, ?ctx, ?value),
     operand_points_to(?baseACtx, ?baseAlloc, ?ctx, ?toAddress),
     ptr_compatible_allocation(?baseAlloc).
  .plan 0: (1, 2, 3, 4),
        1: (2, 1, 3, 4),
        2: (3, 1, 2, 4),
        3: (4, 3, 1, 2)



  .decl _load_operand_points_to(?baseCtx: Context, ?base: Allocation, ?ctx: Context, ?toVar: Variable)
  _load_operand_points_to(?baseACtx, ?baseAlloc, ?ctx, ?toVar) :-
    callgraph.reachable_load(?ctx, ?toVar, ?fromAddress),
    operand_points_to(?baseACtx, ?baseAlloc, ?ctx, ?fromAddress).
  .plan 0: (1, 2),
        1: (2, 1)




  .decl _load_ptr_points_to(?aCtx: Context, ?alloc: Allocation, ?baseCtx: Context, ?base: Allocation)
  _load_ptr_points_to(?ctx, ?alloc, ?baseACtx, ?baseAlloc) :-
    ptr_points_to(?ctx, ?alloc, ?baseACtx, ?baseAlloc).



  _load_ptr_points_to(?ctx, ?alloc, ?baseACtx, ?baseAlloc) :-
    unification_aliases.alloc_matches(?lessGenericAlloc, ?baseAlloc),
    ptr_points_to(?ctx, ?alloc, ?baseACtx, ?lessGenericAlloc).
  .plan 0: (1, 2),
        1: (2, 1)

  unify_var(?aCtx, ?alloc, ?ctx, ?toVar) :-
    _load_operand_points_to(?baseCtx, ?base, ?ctx, ?toVar),
    unify(?reprCtx, ?repr, ?baseCtx, ?base),
    unify(?reprCtx, ?repr, ?newCtx, ?new),
    _load_ptr_points_to(?aCtx, ?alloc, ?newCtx, ?new).



  .plan 0: (1, 2, 3, 4),
        1: (2, 3, 1, 4),
        2: (3, 2, 1, 4),
        3: (4, 3, 2, 1)








  unify_ptr(?aCtx, ?alloc, ?ptrACtx, ?origAlloc) :-
    ptr_points_to(?aCtx, ?alloc, ?ptrACtx, ?moreGenericAlloc),
    unification_aliases.alloc_matches(?origAlloc, ?moreGenericAlloc).





  .type AllocWithContext = [?aCtx: Context, ?alloc: Allocation]










  .decl unify0(?reprCtx: Context, ?reprAlloc: Allocation, ?elemCtx: Context, ?elemAlloc: Allocation)
  .decl unify(?reprCtx: Context, ?reprAlloc: Allocation, ?elemCtx: Context, ?elemAlloc: Allocation) btree_delete



  unify(?aCtx, ?alloc, ?aCtx, ?alloc) :-
    unification_allocations.alloc_with_ctx(?aCtx, ?alloc).


  unify(?xCtx, ?x, ?zCtx, ?z) :-
    unify(?xCtx, ?x, ?yCtx, ?y),
    unify(?yCtx, ?y, ?zCtx, ?z).
  .plan 0: (1, 2),
        1: (2, 1)










  unify(?xCtx, ?x, ?yCtx, ?y) <= unify(?zCtx, ?z, ?yCtx, ?y) :-
    (ord(?zCtx) < ord(?xCtx); (ord(?zCtx) = ord(?xCtx), ord(?z) < ord(?x))) .


  unify(?rCtx1, ?r1, ?rCtx2, ?r2) :-
    unify0(?xCtx, ?x, ?yCtx, ?y),
    ( ( unify(?rCtx1, ?r1, ?xCtx, ?x),
        unify(?rCtx2, ?r2, ?yCtx, ?y),
        (ord(?rCtx1) < ord(?rCtx2); (ord(?rCtx1) = ord(?rCtx2), ord(?r1) < ord(?r2)))
      )
    ; ( unify(?rCtx1, ?r1, ?yCtx, ?y),
        unify(?rCtx2, ?r2, ?xCtx, ?x),
        (ord(?rCtx1) < ord(?rCtx2); (ord(?rCtx1) = ord(?rCtx2), ord(?r1) < ord(?r2)))
      )
    ).
  .plan 0: (1, 2, 3),
        1: (2, 1, 3),
        2: (3, 1, 2)
#line 324 "points-to/unification.dl"
  unify0(?aCtx1, ?subAlloc1, ?aCtx2, ?subAlloc2) :-
    var_points_to_choice(?aCtx1, ?alloc1, ?ctx, ?var, ?region, ?type, ?info),
    unify_var_expanded(?aCtx2, ?alloc2, ?ctx, ?var, ?region, ?type, ?info),
    unification_subobjects.alloc_subregion_at_path(?alloc1, ?path, ?subAlloc1),
    unification_subobjects.alloc_subregion_at_path(?alloc2, ?path, ?subAlloc2).
  .plan 0: (1, 2, 3, 4),
        1: (2, 1, 3, 4),
        2: (3, 1, 2, 4),
        3: (4, 2, 1, 3)

  unify0(?aCtx1, ?subAlloc1, ?aCtx2, ?subAlloc2) :-
    ptr_points_to_choice(?aCtx1, ?alloc1, ?baseACtx, ?ptr, ?region, ?type, ?info),
    unify_ptr_expanded(?aCtx2, ?alloc2, ?baseACtx, ?ptr, ?region, ?type, ?info),
    unification_subobjects.alloc_subregion_at_path(?alloc1, ?path, ?subAlloc1),
    unification_subobjects.alloc_subregion_at_path(?alloc2, ?path, ?subAlloc2).
  .plan 0: (1, 2, 3, 4),
        1: (2, 1, 3, 4),
        2: (3, 1, 2, 4),
        3: (4, 2, 1, 3)


  unify0(?aCtx, ?subAlloc1, ?aCtx, ?subAlloc2) :-
    unification_allocations.alloc_with_ctx(?aCtx, ?alloc),
    unification_aliases.alloc_aliases(?mustAlias, ?alloc),
    unification_subobjects.alloc_subregion_at_path(?alloc, ?path, ?subAlloc1),
    unification_subobjects.alloc_subregion_at_path(?mustAlias, ?path, ?subAlloc2).
  .plan 0: (1, 2, 3, 4),
        1: (2, 1, 3, 4),
        2: (3, 1, 2, 4),
        3: (4, 2, 1, 3)


  unify0(?aCtx, ?subAlloc1, ?aCtx, ?subAlloc2) :-
    heap_allocation_by_instr(?instr, ?alloc1),
    heap_allocation_by_instr(?instr, ?alloc2),
    instr_assigns_to(?instr, ?var),
    var_points_to(?aCtx, ?alloc1, _, ?var),
    unification_subobjects.alloc_subregion_at_path(?alloc1, ?path, ?subAlloc1),
    unification_subobjects.alloc_subregion_at_path(?alloc2, ?path, ?subAlloc2).


  .plan 0: (1, 2, 3, 4, 5, 6),
        1: (2, 1, 3, 4, 5, 6),
        2: (4, 3, 2, 1, 5, 6),
        3: (5, 1, 2, 3, 4, 6),
        4: (6, 2, 1, 3, 4, 5)
#line 391 "points-to/unification.dl"
  .decl is_repr(?reprCtx: Context, ?repr: Allocation)
  is_repr(?reprCtx, ?repr) :-
    unify(?reprCtx, ?repr, _, _),
    0 = count : {
      unify(?reprCtx0, _, ?reprCtx, ?repr),
      ?reprCtx0 != ?reprCtx
    },
    0 = count : {
      unify(_, ?repr0, ?reprCtx, ?repr),
      ?repr0 != ?repr
    }.


  .decl unify_repr(?inpCtx: Context, ?inpAlloc: Allocation, ?reprCtx: Context, ?reprAlloc: Allocation)
  unify_repr(?inpCtx, ?inpAlloc, ?reprCtx, ?reprAlloc) :-
    is_repr(?reprCtx, ?reprAlloc),
    unify(?reprCtx, ?reprAlloc, ?inpCtx, ?inpAlloc).
  .plan 0: (1, 2),
        1: (2, 1)



  .decl ptr_points_to_final(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?ptr: Allocation)
  ptr_points_to_final(?reprCtx, ?repr, ?ctx, ?ptr) :-
    ptr_points_to(?aCtx, ?alloc, ?ctx, ?ptr),
    unify_repr(?aCtx, ?alloc, ?reprCtx, ?repr).

  .decl operand_points_to_final(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?operand: Operand)
  operand_points_to_final(?reprCtx, ?repr, ?ctx, ?operand) :-
    var_points_to_final(?reprCtx, ?repr, ?ctx, ?operand).
  operand_points_to_final(?reprCtx, ?repr, ?ctx, ?cons) :-
    empty_alloc_context(?aCtx),
    constant_in_func(?cons, ?enclosingFunc),
    constant_points_to(?cons, ?alloc),
    callgraph.reachable_context(?ctx, ?enclosingFunc),
    unify_repr(?aCtx, ?alloc, ?reprCtx, ?repr).

  .decl var_points_to_final(?aCtx: Context, ?alloc: Allocation, ?ctx: Context, ?var: Variable)
  var_points_to_final(?reprCtx, ?repr, ?ctx, ?var) :-
    var_points_to(?aCtx, ?alloc, ?ctx, ?var),
    unify_repr(?aCtx, ?alloc, ?reprCtx, ?repr).
}


.init unification = UnificationPointsTo

unification.callgraph.called_at_exit(?func) :-
  unification_at_exit.called_at_exit(?func).


unification.unify_var(?aCtx, ?typedAlloc, ?ctx, ?var) :-
  unification.type_indication.assign_rebase_alloc(?typedAlloc, ?aCtx, ?alloc, ?var),
  unification.var_points_to(?aCtx, ?alloc, ?ctx, ?var).

.init unification_signatures = Signatures

unification_signatures.allocation_type(?alloc, ?type) :-
  unification_allocation_type.allocation_type(?alloc, ?type).

unification_signatures.alloc_may_alias(?alloc1, ?alloc2) :-
  unification_aliases.alloc_may_alias(?alloc1, ?alloc2).

unification_signatures.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr) :-
  unification.callgraph.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr).

unification_signatures.reachable_context(?ctx, ?func) :-
  unification.callgraph.reachable_context(?ctx, ?func).

unification_signatures.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand) :-
  unification.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand).

unification_signatures.ptr_points_to(?aCtx, ?alloc, ?ctx, ?ptr) :-
  unification.ptr_points_to(?aCtx, ?alloc, ?ctx, ?ptr).

unification_signatures.var_points_to(?aCtx, ?alloc, ?ctx, ?var) :-
  unification.var_points_to(?aCtx, ?alloc, ?ctx, ?var).


unification.unify_ptr(?aCtx, ?alloc, ?ctx, ?operand) :-
  unification_signatures.sig_ptr_points_to(?aCtx, ?alloc, ?ctx, ?operand).

unification.unify_var(?aCtx, ?alloc, ?ctx, ?var) :-
  unification_signatures.sig_var_points_to(?aCtx, ?alloc, ?ctx, ?var).

.init unification_memcpy = Memcpy

unification_memcpy.allocation_type(?alloc, ?type) :-
  unification_allocation_type.allocation_type(?alloc, ?type).

unification_memcpy.alloc_subregion(?alloc) :-
  unification_subobjects.alloc_subregion(?alloc).

unification_memcpy.alloc_subregion_at_any_array_index(?alloc, ?region) :-
  unification_subobjects.alloc_subregion_at_any_array_index(?alloc, ?region).

unification_memcpy.alloc_subregion_offset(?alloc, ?region, ?offset) :-
  unification_subobjects.alloc_subregion_offset(?alloc, ?region, ?offset).

unification_memcpy.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr) :-
  unification.callgraph.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr).

unification_memcpy.memcpy_sig(?toCtx, ?to, ?fromCtx, ?from) :-
  unification_signatures.memcpy_sig(?toCtx, ?to, ?fromCtx, ?from).

unification_memcpy.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand) :-
  unification.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand).

unification_memcpy.var_points_to(?aCtx, ?alloc, ?ctx, ?var) :-
  unification.var_points_to(?aCtx, ?alloc, ?ctx, ?var).

unification.unify_ptr(?aCtx, ?alloc, ?toCtx, ?to) :-
   unification_memcpy.rec_memcpy(?toCtx, ?to, ?fromCtx, ?from),
   unification.ptr_points_to(?aCtx, ?alloc, ?fromCtx, ?from).

.init unification_gep = GEP

unification_gep.allocation_type(?alloc, ?type) :-
  unification_allocation_type.allocation_type(?alloc, ?type).

unification_gep.alloc_subregion_at_path_component(?component, ?region) :-
  unification_subobjects.alloc_subregion_at_path_component(_, ?component, ?region).

unification_gep.alloc_subregion_at_field(?alloc, ?index, ?region) :-
  unification_subobjects.alloc_subregion_at_field(?alloc, ?index, ?region).

unification_gep.alloc_subregion_at_array_index(?alloc, ?index, ?region) :-
  unification_subobjects.alloc_subregion_at_array_index(?alloc, ?index, ?region).

unification_gep.alloc_subregion_at_any_array_index(?alloc, ?region) :-
  unification_subobjects.alloc_subregion_at_any_array_index(?alloc, ?region).

unification_gep.alloc_subregion_offset(?base, ?subAlloc, ?offset) :-
  unification_subobjects.alloc_subregion_offset(?base, ?subAlloc, ?offset).

unification_gep.operand_points_to(?aCtx, ?alloc, ?ctx, ?op) :-
  unification.operand_points_to(?aCtx, ?alloc, ?ctx, ?op).

unification.unify_var(?aCtx, ?alloc, ?ctx, ?toVar) :-
  unification_gep.gep_var_points_to(?aCtx, ?alloc, ?ctx, ?toVar).

.init unification_cplusplus = CPlusPlus

unification_cplusplus.allocation_type(?alloc, ?type) :-
  unification_allocation_type.allocation_type(?alloc, ?type).

unification_cplusplus.stripctx_operand_points_to(?to, ?op) :-
  unification.stripctx.stripctx_operand_points_to(?to, ?op).

.init unification_at_exit = AtExit

unification_at_exit.alloc_aliases(?alloc1, ?alloc2) :-
  unification_aliases.alloc_aliases(?alloc1, ?alloc2).

unification_at_exit.reachable_context(?ctx, ?func) :-
  unification.callgraph.reachable_context(?ctx, ?func).

unification_at_exit.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr) :-
  unification.callgraph.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr).

unification_at_exit.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand) :-
  unification.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand).

unification.unify_var(?aCtx, ?alloc, ?ctx, ?var) :-
  unification_at_exit.at_exit_var_points_to(?aCtx, ?alloc, ?ctx, ?var).

.init unification_allocations = Allocations

alloc_context(?aCtx) :- unification_allocations.alloc_with_ctx(?aCtx, _).

unification_allocations.alloc_subregion_base(?alloc, ?base) :-
  unification_subobjects.alloc_subregion_base(?alloc, ?base).

unification_allocations.alloc_with_ctx(?aCtx, ?alloc) :-
  unification_signatures.alloc_with_ctx(?aCtx, ?alloc).

unification_allocations.alloc_with_ctx(?aCtx, ?alloc) :-
  unification.type_indication.alloc_with_ctx(?aCtx, ?alloc).

unification_allocations.reachable_context(?ctx, ?func) :-
  unification.callgraph.reachable_context(?ctx, ?func).
unification.unify_var(?aCtx, ?alloc, ?ctx, ?var) :-
  unification_allocations.allocated_at(?aCtx, ?alloc, ?ctx, ?var).

.init unification_allocation_type = AllocationType

unification_allocation_type.alloc_subregion_type(?alloc, ?type) :-
  unification_subobjects.alloc_subregion_type(?alloc, ?type).

unification_allocation_type.backpropagated_allocation_type(?alloc, ?type) :-
  unification.type_indication.backpropagated_allocation_type(?alloc, ?type).

unification_allocation_type.sig_allocation_type(?alloc, ?type) :-
  unification_signatures.sig_allocation_type(?alloc, ?type).

unification_allocation_type.is_init_by_ctor(?type, ?ctor, ?inFunction, ?alloc) :-
  unification_cplusplus.is_init_by_ctor(?type, ?ctor, ?inFunction, ?alloc).

unification_allocation_type.heap_allocation_by_alloc_exc(?insn, ?heapAlloc) :-
  unification.exception_object.heap_allocation_by_alloc_exc(?insn, ?heapAlloc).



.init unification_subobjects = AllocSubobjects

unification_subobjects.allocation_type(?alloc, ?type) :-
  unification_allocation_type.allocation_type(?alloc, ?type).





.decl unify_allocation_size(?alloc: Allocation, ?size: Bytes)

unify_allocation_size(?alloc, ?size) :-
  allocation_size(?alloc, ?size).

unify_allocation_size(?repr, ?size) :-
  unification.unify(_, ?repr, _, ?base),
  allocation_size(?base, ?size).

unify_allocation_size(?base, ?size) :-
  unification.unify(_, ?repr, _, ?base),
  allocation_size(?repr, ?size).

dynamically_sized_alloc(?repr) :-
  unification.unify(_, ?repr, _, ?base),
  dynamically_sized_alloc(?base).

dynamically_sized_alloc(?base) :-
  unification.unify(_, ?repr, _, ?base),
  dynamically_sized_alloc(?repr).

unification_subobjects.input_allocation_size(?alloc, ?size) :-
  unify_allocation_size(?alloc, ?size).

static_subobjects.input_allocation_size(?alloc, ?size) :-
  unify_allocation_size(?alloc, ?size).


unification_subobjects._alloc_subregion(?allocSub, ?base, ?component, ?root, ?path, ?type) :-
  static_subobjects._alloc_subregion(?allocSub, ?base, ?component, ?root, ?path, ?type).
unification_subobjects._non_func_basic_allocation(?alloc) :-
  static_subobjects._non_func_basic_allocation(?alloc).
unification_subobjects.alloc_subregion_at_field(?alloc, ?index, ?region) :-
  static_subobjects.alloc_subregion_at_field(?alloc, ?index, ?region).
unification_subobjects.alloc_subregion_at_any_array_index(?alloc, ?region) :-
  static_subobjects.alloc_subregion_at_any_array_index(?alloc, ?region).
unification_subobjects.alloc_subregion_at_array_index(?alloc, ?index, ?region) :-
  static_subobjects.alloc_subregion_at_array_index(?alloc, ?index, ?region).

.init unification_aliases = Aliases

unification_aliases.alloc_subregion_at_field(?alloc, ?index, ?region) :-
  unification_subobjects.alloc_subregion_at_field(?alloc, ?index, ?region).

unification_aliases.alloc_subregion_at_array_index(?alloc, ?index, ?region) :-
  unification_subobjects.alloc_subregion_at_array_index(?alloc, ?index, ?region).

unification_aliases.alloc_subregion_at_any_array_index(?alloc, ?region) :-
  unification_subobjects.alloc_subregion_at_any_array_index(?alloc, ?region).

.init unification_lift = Lift

unification_lift.alloc_aliases(?alloc1, ?alloc2) :-
  unification_aliases.alloc_aliases(?alloc1, ?alloc2).
unification_lift.alloc_may_alias(?alloc1, ?alloc2) :-
  unification_aliases.alloc_may_alias(?alloc1, ?alloc2).

unification_lift.alloc_subregion_at_path(?base, ?path, ?obj) :-
  unification_subobjects.alloc_subregion_at_path(?base, ?path, ?obj).

unification_lift.alloc_subregion_base(?base, ?obj) :-
  unification_subobjects.alloc_subregion_base(?base, ?obj).

unification_lift.reachable_context(?ctx, ?func) :-
  unification.callgraph.reachable_context(?ctx, ?func).

unification_lift.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand) :-
  unification.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand).

unification_lift.ptr_points_to(?aCtx, ?alloc, ?ctx, ?ptr) :-
  unification.ptr_points_to(?aCtx, ?alloc, ?ctx, ?ptr).

unification_lift.var_points_to(?aCtx, ?alloc, ?ctx, ?var) :-
  unification.var_points_to(?aCtx, ?alloc, ?ctx, ?var).

alloc_region(?subAlloc, ?region) :-
  unification_subobjects.alloc_subregion_base(?subAlloc, ?alloc),
  alloc_region(?alloc, ?region).
alloc_region(?alloc, "heap") :-
  unification.exception_object.heap_allocation_by_alloc_exc(_, ?alloc).
alloc_region(?alloc, "heap") :-
  unification.type_indication.heap_allocation_by_type_instr(_, _, ?alloc).
alloc_region(?alloc, "heap") :-
  unification_signatures.sig_allocation_type(?alloc, _).
#line 8 "subset-and-unification.project"
#line 2 ".cclyzerpp/datalog/debug.project"
#line 1 "export/statistics.dl"
.output subset._merge.count_context_items (compress=true)
.output subset._merge.count_contexts (compress=true)
.output func_degree (compress=true)
.output func_out_degree (compress=true)
.output var_alias_sizes (compress=true)
.output var_points_to_sizes (compress=true)
#line 3 ".cclyzerpp/datalog/debug.project"
#line 1 "export/debug-output.dl"
.output _alias (compress=true)
.output _aliasee (compress=true)
.output _alloc_pt_size (compress=true)
.output _alloc_region (compress=true)
.output _assert_every_gep_instr_points_to_something (compress=true)
.output _assert_type_compatible_ptr_points_to_alias (compress=true)
.output _assert_type_compatible_relaxed (compress=true)
.output _assert_type_compatible_relaxed_inner (compress=true)
.output _constant_contains_typeinfo (compress=true)
.output _constant_expression_next_index (compress=true)
.output _eligible_base_type (compress=true)
.output _getelementptr_constant_expression_base_type (compress=true)
.output _getelementptr_constant_expression_index_type (compress=true)
.output _getelementptr_constant_expression_interm_type (compress=true)
.output _getelementptr_constant_expression_value_type (compress=true)
.output _instr_calls_func (compress=true)
.output _landingpad_contains_landingpad_instr (compress=true)
.output _landingpad_first_nonphi (compress=true)
.output _landingpad_starting_phi (compress=true)
.output _string_iteration_trick (compress=true)
.output _type_expands_base_type (compress=true)
.output _type_info_by_alloc (compress=true)
.output _typed_alloc (compress=true)
.output _typeinfo_class_name (compress=true)
.output _typeinfo_class_type (compress=true)
.output _typeinfo_contains_typeinfo (compress=true)
.output _valid_landingpad (compress=true)
.output _vtable_class_name (compress=true)
.output acq_rel_ordering (compress=true)
.output acquire_ordering (compress=true)
.output actual_arg (compress=true)
.output add_instr (compress=true)
.output add_instr_first_operand (compress=true)
.output add_instr_second_operand (compress=true)
.output aggregate_type (compress=true)
.output alias (compress=true)
.output alias_aliasee (compress=true)
.output alias_linkage (compress=true)
.output alias_name (compress=true)
.output alias_type (compress=true)
.output alias_visibility (compress=true)
.output aliased_constants (compress=true)
.output alloc_context (compress=true)
.output alloc_points_to_sizes (compress=true)
.output alloc_region (compress=true)
.output alloca_instr (compress=true)
.output alloca_instr_alignment (compress=true)
.output alloca_instr_size (compress=true)
.output alloca_instr_type (compress=true)
.output allocation (compress=true)
.output allocation_by_instr (compress=true)
.output allocation_pos (compress=true)
.output allocation_size (compress=true)
.output analyze_pointer_arithmetic (compress=true)
.output and_instr (compress=true)
.output and_instr_first_operand (compress=true)
.output and_instr_second_operand (compress=true)
.output appending_linkage_type (compress=true)
.output argv_alloc (compress=true)
.output argv_ptr_points_to (compress=true)
.output argv_var_points_to (compress=true)
.output arm_aapcs_calling_convention (compress=true)
.output arm_aapcs_vfp_calling_convention (compress=true)
.output arm_apcs_calling_convention (compress=true)
.output array_allocation (compress=true)
.output array_indices (compress=true)
.output array_indices__no_typecomp (compress=true)
.output array_offset (compress=true)
.output array_pointer_type (compress=true)
.output array_type (compress=true)
.output array_type_has_component (compress=true)
.output array_type_has_size (compress=true)
.output ashr_instr (compress=true)
.output ashr_instr_first_operand (compress=true)
.output ashr_instr_second_operand (compress=true)
.output asm_call_instr (compress=true)
.output assert_alloc_with_ctx_complete (compress=true)
.output assert_array_type_size (compress=true)
.output assert_basic_or_path (compress=true)
.output assert_bitcast_operand_in_same_func (compress=true)
.output assert_dynamic_or_known_size (compress=true)
.output assert_every_allocation_has_a_region (compress=true)
.output assert_every_allocation_has_a_type (compress=true)
.output assert_every_allocation_has_one_region (compress=true)
.output assert_every_gep_constant_expr_points_to_something (compress=true)
.output assert_every_pointer_constant_points_to_something (compress=true)
.output assert_global_allocations_have_dynamic_types (compress=true)
.output assert_global_allocations_have_one_type (compress=true)
.output assert_global_allocations_have_static_types (compress=true)
.output assert_has_repr (compress=true)
.output assert_reachable_direct_calls_have_callees (compress=true)
.output assert_size_less_than_parent (compress=true)
.output assert_size_sum_less_than_parent (compress=true)
.output assert_subset_aliases_are_unification_aliases (compress=true)
.output assert_subset_callgraph_edge_implies_unification_callgraph_edge (compress=true)
.output assert_subset_reachable_ctx_implies_unification_reachable_ctx (compress=true)
.output assert_subset_var_points_to_inhabited_implies_unification (compress=true)
.output assert_type_compatible_constant_points_to (compress=true)
.output assert_type_compatible_ptr_points_to (compress=true)
.output assert_type_has_size (compress=true)
.output assert_type_unique_size (compress=true)
.output assert_unification_var_points_to_unique (compress=true)
.output assert_unique_repr (compress=true)
.output assert_var_points_to_implies_reachable (compress=true)
.output assign_instr (compress=true)
.output atomic_operation (compress=true)
.output atomic_operation_add (compress=true)
.output atomic_operation_and (compress=true)
.output atomic_operation_max (compress=true)
.output atomic_operation_min (compress=true)
.output atomic_operation_nand (compress=true)
.output atomic_operation_nor (compress=true)
.output atomic_operation_or (compress=true)
.output atomic_operation_sub (compress=true)
.output atomic_operation_umax (compress=true)
.output atomic_operation_umin (compress=true)
.output atomic_operation_xchg (compress=true)
.output atomic_operation_xor (compress=true)
.output atomicrmw_instr (compress=true)
.output atomicrmw_instr_address (compress=true)
.output atomicrmw_instr_is_volatile (compress=true)
.output atomicrmw_instr_operation (compress=true)
.output atomicrmw_instr_ordering (compress=true)
.output atomicrmw_instr_value (compress=true)
.output attr (compress=true)
.output available_externally_linkage_type (compress=true)
.output basic_allocation (compress=true)
.output bitcast_constant_expression (compress=true)
.output bitcast_constant_expression_from (compress=true)
.output bitcast_constant_expression_to_type (compress=true)
.output bitcast_instr (compress=true)
.output bitcast_instr_from_operand (compress=true)
.output bitcast_instr_from_type (compress=true)
.output bitcast_instr_to_type (compress=true)
.output block (compress=true)
.output block_first_instr (compress=true)
.output block_last_instr (compress=true)
.output block_of_label (compress=true)
.output block_predecessor (compress=true)
.output block_predecessors (compress=true)
.output boolean_type (compress=true)
.output boolean_vector_type (compress=true)
.output br_instr (compress=true)
.output br_instr_cond (compress=true)
.output br_instr_condition (compress=true)
.output br_instr_false_label (compress=true)
.output br_instr_true_label (compress=true)
.output br_instr_uncond (compress=true)
.output br_instr_uncond_label (compress=true)
.output call_instr (compress=true)
.output call_instr_arg (compress=true)
.output call_instr_func_operand (compress=true)
.output call_instr_fn_target (compress=true)
.output call_instr_fn_type (compress=true)
.output call_instr_tail_opt (compress=true)
.output call_instr_return_type (compress=true)
.output call_instr_calling_conv (compress=true)
.output call_instr_func_attr (compress=true)
.output call_instr_param_attr (compress=true)
.output call_instr_return_attr (compress=true)
.output call_or_invoke_instr_fn_type (compress=true)
.output called_at_startup (compress=true)
.output calling_convention (compress=true)
.output catch_clause (compress=true)
.output class_type (compress=true)
.output class_type_constructor (compress=true)
.output class_type_destructor (compress=true)
.output class_type_name (compress=true)
.output class_type_typeinfo (compress=true)
.output class_type_vtable (compress=true)
.output clause (compress=true)
.output cmpxchg_instr (compress=true)
.output cmpxchg_instr_address (compress=true)
.output cmpxchg_instr_cmp_value (compress=true)
.output cmpxchg_instr_cmp_value_type (compress=true)
.output cmpxchg_instr_is_volatile (compress=true)
.output cmpxchg_instr_new_value (compress=true)
.output cmpxchg_instr_ordering (compress=true)
.output cmpxchg_instr_type (compress=true)
.output cold_calling_convention (compress=true)
.output common_linkage_type (compress=true)
.output constant (compress=true)
.output constant_array (compress=true)
.output constant_array_has_size (compress=true)
.output constant_array_index (compress=true)
.output constant_contains_vptr (compress=true)
.output constant_expression (compress=true)
.output constant_has_type (compress=true)
.output constant_has_value (compress=true)
.output constant_hashes_to (compress=true)
.output constant_in_func (compress=true)
.output constant_in_func_name (compress=true)
.output constant_points_to (compress=true)
.output constant_ptr_points_to (compress=true)
.output constant_references_func (compress=true)
.output constant_references_variable (compress=true)
.output constant_struct (compress=true)
.output constant_struct_has_size (compress=true)
.output constant_struct_index (compress=true)
.output constant_to_int (compress=true)
.output constant_vector (compress=true)
.output constant_vector_has_size (compress=true)
.output constant_vector_index (compress=true)
.output context (compress=true)
.output context_depth (compress=true)
.output context_item_by_invoc (compress=true)
.output context_item_by_invoc_interim (compress=true)
.output context_to_string (compress=true)
.output cxx_alloc_exception (compress=true)
.output cxx_atexit_func (compress=true)
.output cxx_new_func (compress=true)
.output cxx_throw_func (compress=true)
.output default_visibility (compress=true)
.output derived_type (compress=true)
.output direct_call_instr (compress=true)
.output direct_invoke_instr (compress=true)
.output direct_subclass (compress=true)
.output direct_superclass (compress=true)
.output dllexport_linkage_type (compress=true)
.output dllimport_linkage_type (compress=true)
.output double_type (compress=true)
.output drop_context_by_invoc (compress=true)
.output drop_context_item_by_invoc (compress=true)
.output drop_last (compress=true)
.output dynamically_sized_alloc (compress=true)
.output empty_alloc_context (compress=true)
.output empty_context (compress=true)
.output empty_path (compress=true)
.output empty_path_component (compress=true)
.output empty_ptr (compress=true)
.output empty_ptrs (compress=true)
.output empty_var (compress=true)
.output empty_vars (compress=true)
.output entry_point (compress=true)
.output eq_size_vector_types (compress=true)
.output eq_size_vector_types_ (compress=true)
.output exit_context (compress=true)
.output extern_weak_linkage_type (compress=true)
.output external_linkage_type (compress=true)
.output external_typeinfo (compress=true)
.output extractelement_instr (compress=true)
.output extractelement_instr_base (compress=true)
.output extractelement_instr_index (compress=true)
.output extractelement_instr_type (compress=true)
.output extractvalue_instr (compress=true)
.output extractvalue_instr_base (compress=true)
.output extractvalue_instr_base_type (compress=true)
.output extractvalue_instr_index (compress=true)
.output extractvalue_instr_nindices (compress=true)
.output extractvalue_instr_value_type (compress=true)
.output extractvalue_instrterm_type (compress=true)
.output fadd_instr (compress=true)
.output fadd_instr_first_operand (compress=true)
.output fadd_instr_second_operand (compress=true)
.output failing_assert_every_gep_instr_points_to_something (compress=true)
.output failing_assert_global_allocations_have_sizes (compress=true)
.output failing_assert_reachable_pointer_vars_point_to_something (compress=true)
.output failing_assert_type_compatible_var_points_to (compress=true)
.output fast_calling_convention (compress=true)
.output fcmp_condition (compress=true)
.output fcmp_condition__false (compress=true)
.output fcmp_condition__oeq (compress=true)
.output fcmp_condition__oge (compress=true)
.output fcmp_condition__ogt (compress=true)
.output fcmp_condition__ole (compress=true)
.output fcmp_condition__olt (compress=true)
.output fcmp_condition__one (compress=true)
.output fcmp_condition__ord (compress=true)
.output fcmp_condition__true (compress=true)
.output fcmp_condition__ueq (compress=true)
.output fcmp_condition__uge (compress=true)
.output fcmp_condition__ugt (compress=true)
.output fcmp_condition__ule (compress=true)
.output fcmp_condition__ult (compress=true)
.output fcmp_condition__une (compress=true)
.output fcmp_condition__uno (compress=true)
.output fcmp_instr (compress=true)
.output fcmp_instr_condition (compress=true)
.output fcmp_instr_first_operand (compress=true)
.output fcmp_instr_from_type (compress=true)
.output fcmp_instr_second_operand (compress=true)
.output fcmp_instr_to_type (compress=true)
.output fdiv_instr (compress=true)
.output fdiv_instr_first_operand (compress=true)
.output fdiv_instr_second_operand (compress=true)
.output fence_instr (compress=true)
.output fence_instr_ordering (compress=true)
.output filter_clause (compress=true)
.output flag (compress=true)
.output float_type (compress=true)
.output fmul_instr (compress=true)
.output fmul_instr_first_operand (compress=true)
.output fmul_instr_second_operand (compress=true)
.output fp128_type (compress=true)
.output fp_constant (compress=true)
.output fp_pointer_type (compress=true)
.output fp_type (compress=true)
.output fp_vector_type (compress=true)
.output fpext_instr (compress=true)
.output fpext_instr_from_operand (compress=true)
.output fpext_instr_from_type (compress=true)
.output fpext_instr_to_type (compress=true)
.output fptosi_instr (compress=true)
.output fptosi_instr_from_operand (compress=true)
.output fptosi_instr_from_type (compress=true)
.output fptosi_instr_to_type (compress=true)
.output fptoui_instr (compress=true)
.output fptoui_instr_from_operand (compress=true)
.output fptoui_instr_from_type (compress=true)
.output fptoui_instr_to_type (compress=true)
.output fptrunc_instr (compress=true)
.output fptrunc_instr_from_operand (compress=true)
.output fptrunc_instr_from_type (compress=true)
.output fptrunc_instr_to_type (compress=true)
.output frem_instr (compress=true)
.output frem_instr_first_operand (compress=true)
.output frem_instr_second_operand (compress=true)
.output fsub_instr (compress=true)
.output fsub_instr_first_operand (compress=true)
.output fsub_instr_second_operand (compress=true)
.output func (compress=true)
.output func_alignment (compress=true)
.output func_by_location (compress=true)
.output func_by_value_param (compress=true)
.output func_calling_conv (compress=true)
.output func_calls_func (compress=true)
.output func_constant (compress=true)
.output func_constant_fn_name (compress=true)
.output func_decl (compress=true)
.output func_decl_to_defn (compress=true)
.output func_degree (compress=true)
.output func_func_attr (compress=true)
.output func_func_attr__alignstack (compress=true)
.output func_func_attr__alwaysinline (compress=true)
.output func_func_attr__argmemonly (compress=true)
.output func_func_attr__builtin (compress=true)
.output func_func_attr__cold (compress=true)
.output func_func_attr__convergent (compress=true)
.output func_func_attr__inaccessiblemem_or_argmemonly (compress=true)
.output func_func_attr__inaccessiblememonly (compress=true)
.output func_func_attr__inlinehint (compress=true)
.output func_func_attr__jumptable (compress=true)
.output func_func_attr__minsize (compress=true)
.output func_func_attr__naked (compress=true)
.output func_func_attr__nobuiltin (compress=true)
.output func_func_attr__noduplicate (compress=true)
.output func_func_attr__noimplicitfloat (compress=true)
.output func_func_attr__noinline (compress=true)
.output func_func_attr__nonlazybind (compress=true)
.output func_func_attr__norecurse (compress=true)
.output func_func_attr__noredzone (compress=true)
.output func_func_attr__noreturn (compress=true)
.output func_func_attr__nounwind (compress=true)
.output func_func_attr__optnone (compress=true)
.output func_func_attr__optsize (compress=true)
.output func_func_attr__readnone (compress=true)
.output func_func_attr__readonly (compress=true)
.output func_func_attr__returns_twice (compress=true)
.output func_func_attr__safestack (compress=true)
.output func_func_attr__sanitize_address (compress=true)
.output func_func_attr__sanitize_memory (compress=true)
.output func_func_attr__sanitize_thread (compress=true)
.output func_func_attr__ssp (compress=true)
.output func_func_attr__sspreq (compress=true)
.output func_func_attr__sspstrong (compress=true)
.output func_func_attr__uwtable (compress=true)
.output func_gc (compress=true)
.output func_is_illformed (compress=true)
.output func_is_wellformed (compress=true)
.output func_linkage (compress=true)
.output func_missing_signature (compress=true)
.output func_name (compress=true)
.output func_needs_signature (compress=true)
.output func_nparams (compress=true)
.output func_out_degree (compress=true)
.output func_param (compress=true)
.output func_param_attr (compress=true)
.output func_param_by_value (compress=true)
.output func_param_not_by_value (compress=true)
.output func_pers_fn (compress=true)
.output func_pts_signature (compress=true)
.output func_return_attr (compress=true)
.output func_returns_value (compress=true)
.output func_section (compress=true)
.output func_signature (compress=true)
.output func_ty (compress=true)
.output func_type (compress=true)
.output func_type_has_no_pointer_args (compress=true)
.output func_type_has_no_pointer_return (compress=true)
.output func_type_has_pointer_arg (compress=true)
.output func_type_has_pointer_return (compress=true)
.output func_type_has_varargs (compress=true)
.output func_type_nparams (compress=true)
.output func_type_param (compress=true)
.output func_type_return (compress=true)
.output func_unnamed_addr (compress=true)
.output func_visibility (compress=true)
.output funcs_by_in_degree (compress=true)
.output funcs_by_out_degree (compress=true)
.output gep_constant_expr_index_offset (compress=true)
.output gep_constant_expr_indexes_from (compress=true)
.output gep_constant_expr_points_to (compress=true)
.output gep_is_vector_based (compress=true)
.output gep_zero_index_offset (compress=true)
.output getelementptr_constant_expression (compress=true)
.output getelementptr_constant_expression_base (compress=true)
.output getelementptr_constant_expression_index (compress=true)
.output getelementptr_constant_expression_nindices (compress=true)
.output getelementptr_instr (compress=true)
.output getelementptr_instr_base (compress=true)
.output getelementptr_instr_base_type (compress=true)
.output getelementptr_instr_inbounds (compress=true)
.output getelementptr_instr_index (compress=true)
.output getelementptr_instr_index_type (compress=true)
.output getelementptr_instr_nindices (compress=true)
.output getelementptr_instr_value_type (compress=true)
.output getelementptr_instrterm_type (compress=true)
.output global_allocation (compress=true)
.output global_allocation_by_func (compress=true)
.output global_allocation_by_name (compress=true)
.output global_allocation_by_variable (compress=true)
.output global_region (compress=true)
.output global_var (compress=true)
.output global_var_aligned_to (compress=true)
.output global_var_constant (compress=true)
.output global_var_constant_name (compress=true)
.output global_var_constant_reference (compress=true)
.output global_var_demangled_name (compress=true)
.output global_var_flag (compress=true)
.output global_var_initializer (compress=true)
.output global_var_is_constant (compress=true)
.output global_var_linkage (compress=true)
.output global_var_name (compress=true)
.output global_var_section (compress=true)
.output global_var_threadlocal_mode (compress=true)
.output global_var_type (compress=true)
.output global_var_visibility (compress=true)
.output half_type (compress=true)
.output heap_alloc_func (compress=true)
.output heap_allocation (compress=true)
.output heap_allocation_by_calloc (compress=true)
.output heap_allocation_by_instr (compress=true)
.output heap_allocation_by_malloc (compress=true)
.output heap_allocation_by_mmap (compress=true)
.output heap_allocation_by_new (compress=true)
.output heap_allocation_by_realloc (compress=true)
.output heap_allocation_by_type_instr (compress=true)
.output heap_region (compress=true)
.output hidden_visibility (compress=true)
.output icmp_condition (compress=true)
.output icmp_condition__eq (compress=true)
.output icmp_condition__ne (compress=true)
.output icmp_condition__sge (compress=true)
.output icmp_condition__sgt (compress=true)
.output icmp_condition__sle (compress=true)
.output icmp_condition__slt (compress=true)
.output icmp_condition__uge (compress=true)
.output icmp_condition__ugt (compress=true)
.output icmp_condition__ule (compress=true)
.output icmp_condition__ult (compress=true)
.output icmp_instr (compress=true)
.output icmp_instr_condition (compress=true)
.output icmp_instr_first_operand (compress=true)
.output icmp_instr_from_type (compress=true)
.output icmp_instr_second_operand (compress=true)
.output icmp_instr_to_type (compress=true)
.output indirect_call_instr (compress=true)
.output indirect_call_or_invoke_instr (compress=true)
.output indirect_invoke_instr (compress=true)
.output indirectbr_instr (compress=true)
.output indirectbr_instr_address (compress=true)
.output indirectbr_instr_label (compress=true)
.output indirectbr_instr_nlabels (compress=true)
.output initial_exec_threadlocal_mode (compress=true)
.output initialized_by_constant (compress=true)
.output inline_asm (compress=true)
.output inline_asm_constraints (compress=true)
.output inline_asm_text (compress=true)
.output inlined_constructors (compress=true)
.output insensitive (compress=true)
.output insertelement_instr (compress=true)
.output insertelement_instr_base (compress=true)
.output insertelement_instr_index (compress=true)
.output insertelement_instr_type (compress=true)
.output insertelement_instr_value (compress=true)
.output insertvalue_instr (compress=true)
.output insertvalue_instr_base (compress=true)
.output insertvalue_instr_base_type (compress=true)
.output insertvalue_instr_index (compress=true)
.output insertvalue_instr_nindices (compress=true)
.output insertvalue_instr_value (compress=true)
.output insertvalue_instr_value_type (compress=true)
.output insertvalue_instrterm_type (compress=true)
.output instr (compress=true)
.output instr_assigns_to (compress=true)
.output instr_bb_entry (compress=true)
.output instr_block (compress=true)
.output instr_flag (compress=true)
.output instr_func (compress=true)
.output instr_pos (compress=true)
.output instr_returns_type (compress=true)
.output instr_successor (compress=true)
.output instr_successor_index (compress=true)
.output int1_type (compress=true)
.output int32_type (compress=true)
.output int32_vector_type (compress=true)
.output int64_type (compress=true)
.output int8_array_type (compress=true)
.output int8_type (compress=true)
.output integer_constant (compress=true)
.output integer_pointer_type (compress=true)
.output integer_type (compress=true)
.output integer_vector_type (compress=true)
.output intel_ocl_bi_calling_convention (compress=true)
.output internal_linkage_type (compress=true)
.output inttoptr_constant_expression (compress=true)
.output inttoptr_constant_expression_from (compress=true)
.output inttoptr_instr (compress=true)
.output inttoptr_instr_from_operand (compress=true)
.output inttoptr_instr_from_type (compress=true)
.output inttoptr_instr_to_type (compress=true)
.output invoke_instr (compress=true)
.output invoke_instr_arg (compress=true)
.output invoke_instr_exception_label (compress=true)
.output invoke_instr_func_operand (compress=true)
.output invoke_instr_fn_target (compress=true)
.output invoke_instr_fn_type (compress=true)
.output invoke_instr_normal_label (compress=true)
.output invoke_instr_return_type (compress=true)
.output invoke_instr_calling_conv (compress=true)
.output invoke_instr_func_attr (compress=true)
.output invoke_instr_param_attr (compress=true)
.output invoke_instr_return_attr (compress=true)
.output label_type (compress=true)
.output landingpad (compress=true)
.output landingpad_instr (compress=true)
.output landingpad_instr_catch_clause (compress=true)
.output landingpad_instr_clause (compress=true)
.output landingpad_instr_filter_clause (compress=true)
.output landingpad_instr_is_cleanup (compress=true)
.output landingpad_instr_nclauses (compress=true)
.output landingpad_instr_pers_fn (compress=true)
.output landingpad_instr_type (compress=true)
.output linkage_type (compress=true)
.output linker_private_linkage_type (compress=true)
.output linker_private_weak_linkage_type (compress=true)
.output linkonce_linkage_type (compress=true)
.output linkonce_odr_linkage_type (compress=true)
.output load_instr (compress=true)
.output load_instr_address (compress=true)
.output load_instr_address_ptr_type (compress=true)
.output load_instr_alignment (compress=true)
.output load_instr_is_atomic (compress=true)
.output load_instr_is_volatile (compress=true)
.output load_instr_ordering (compress=true)
.output local_dynamic_threadlocal_mode (compress=true)
.output local_exec_threadlocal_mode (compress=true)
.output lshr_instr (compress=true)
.output lshr_instr_first_operand (compress=true)
.output lshr_instr_second_operand (compress=true)
.output main_context (compress=true)
.output main_func (compress=true)
.output max_context_depth (compress=true)
.output max_num_callsites (compress=true)
.output memcpy_pass_by_value (compress=true)
.output metadata_type (compress=true)
.output minimal_suffix (compress=true)
.output minimal_suffix_len (compress=true)
.output monotonic_ordering (compress=true)
.output msp430_intr_calling_convention (compress=true)
.output mul_instr (compress=true)
.output mul_instr_first_operand (compress=true)
.output mul_instr_second_operand (compress=true)
.output nallocs_by_pt_size (compress=true)
.output non_allocation (compress=true)
.output nonempty_ptr (compress=true)
.output nonempty_ptrs (compress=true)
.output nonempty_var (compress=true)
.output nonempty_vars (compress=true)
.output not_array_index (compress=true)
.output null_location (compress=true)
.output nullptr_constant (compress=true)
.output num_direct_calls_to_func (compress=true)
.output num_indirect_calls_to_compatible_func (compress=true)
.output nvars_by_pt_size (compress=true)
.output opaque_struct_type (compress=true)
.output operand (compress=true)
.output operand_has_type (compress=true)
.output operand_is_firstclass (compress=true)
.output operand_is_pointer (compress=true)
.output operand_to_int (compress=true)
.output or_instr (compress=true)
.output or_instr_first_operand (compress=true)
.output or_instr_second_operand (compress=true)
.output ordering (compress=true)
.output parameter_attr__align (compress=true)
.output parameter_attr__byval (compress=true)
.output parameter_attr__dereferenceable (compress=true)
.output parameter_attr__dereferenceable_or_null (compress=true)
.output parameter_attr__inalloca (compress=true)
.output parameter_attr__inreg (compress=true)
.output parameter_attr__nest (compress=true)
.output parameter_attr__noalias (compress=true)
.output parameter_attr__nocapture (compress=true)
.output parameter_attr__nonnull (compress=true)
.output parameter_attr__returned (compress=true)
.output parameter_attr__signext (compress=true)
.output parameter_attr__sret (compress=true)
.output parameter_attr__zeroext (compress=true)
.output path (compress=true)
.output path_component (compress=true)
.output path_component_at_any_index (compress=true)
.output path_component_at_field (compress=true)
.output path_component_at_index (compress=true)
.output path_ends_in (compress=true)
.output path_ends_in_array_index (compress=true)
.output phi_instr (compress=true)
.output phi_instr_npairs (compress=true)
.output phi_instr_pair (compress=true)
.output phi_instr_pair_label (compress=true)
.output phi_instr_pair_value (compress=true)
.output phi_instr_type (compress=true)
.output pointer_index (compress=true)
.output pointer_offset (compress=true)
.output pointer_type (compress=true)
.output pointer_type_base_component (compress=true)
.output pointer_type_has_addr_space (compress=true)
.output pointer_type_has_component (compress=true)
.output pointer_type_to_firstclass (compress=true)
.output pointer_vector_type (compress=true)
.output poison_constant (compress=true)
.output ppc_fp128_type (compress=true)
.output primary_superclass (compress=true)
.output primitive_type (compress=true)
.output private_linkage_type (compress=true)
.output protected_visibility (compress=true)
.output ptr_compatible_allocation (compress=true)
.output ptrtoint_constant_expression (compress=true)
.output ptrtoint_constant_expression_from (compress=true)
.output ptrtoint_instr (compress=true)
.output ptrtoint_instr_from_operand (compress=true)
.output ptrtoint_instr_from_type (compress=true)
.output ptrtoint_instr_to_type (compress=true)
.output ptx_device_calling_convention (compress=true)
.output ptx_kernel_calling_convention (compress=true)
.output reachable_var (compress=true)
.output reachable_vars (compress=true)
.output region (compress=true)
.output release_ordering (compress=true)
.output relevant_suffix_position (compress=true)
.output resume_instr (compress=true)
.output resume_instr_operand (compress=true)
.output ret_instr (compress=true)
.output ret_instr_operand (compress=true)
.output ret_instr_void_ (compress=true)
.output schema_invalid_alias (compress=true)
.output schema_invalid_constant (compress=true)
.output schema_invalid_func (compress=true)
.output schema_invalid_global_var (compress=true)
.output schema_invalid_instr (compress=true)
.output schema_invalid_type (compress=true)
.output schema_multiple_func_names (compress=true)
.output schema_sanity (compress=true)
.output sdiv_instr (compress=true)
.output sdiv_instr_first_operand (compress=true)
.output sdiv_instr_second_operand (compress=true)
.output secondary_superclass (compress=true)
.output select_instr (compress=true)
.output select_instr_condition (compress=true)
.output select_instr_first_operand (compress=true)
.output select_instr_second_operand (compress=true)
.output seq_cst_ordering (compress=true)
.output sext_instr (compress=true)
.output sext_instr_from_operand (compress=true)
.output sext_instr_from_type (compress=true)
.output sext_instr_to_type (compress=true)
.output shl_instr (compress=true)
.output shl_instr_first_operand (compress=true)
.output shl_instr_second_operand (compress=true)
.output shufflevector_instr (compress=true)
.output shufflevector_instr_element_type (compress=true)
.output shufflevector_instr_first_vector (compress=true)
.output shufflevector_instr_mask (compress=true)
.output shufflevector_instr_mask_type (compress=true)
.output shufflevector_instr_second_vector (compress=true)
.output shufflevector_instrput_type (compress=true)
.output signature_allocation (compress=true)
.output signature_arg_alloc (compress=true)
.output signature_arg_alloc_once (compress=true)
.output signature_arg_memcpy_arg (compress=true)
.output signature_arg_memcpy_arg_reachable (compress=true)
.output signature_arg_memcpy_global (compress=true)
.output signature_arg_memcpy_global_reachable (compress=true)
.output signature_arg_points_to_global (compress=true)
.output signature_global_memcpy_arg (compress=true)
.output signature_global_memcpy_arg_reachable (compress=true)
.output signature_none (compress=true)
.output signature_return_aliases_arg (compress=true)
.output signature_return_aliases_arg_reachable (compress=true)
.output signature_return_aliases_global (compress=true)
.output signature_return_aliases_global_reachable (compress=true)
.output signature_return_alloc (compress=true)
.output signature_return_alloc_once (compress=true)
.output signature_return_points_to_global (compress=true)
.output sitofp_instr (compress=true)
.output sitofp_instr_from_operand (compress=true)
.output sitofp_instr_from_type (compress=true)
.output sitofp_instr_to_type (compress=true)
.output sized_alloc_instr (compress=true)
.output split_path (compress=true)
.output srem_instr (compress=true)
.output srem_instr_first_operand (compress=true)
.output srem_instr_second_operand (compress=true)
.output stack_allocation (compress=true)
.output stack_allocation_by_instr (compress=true)
.output stack_allocation_by_parameter (compress=true)
.output stack_allocation_by_type_instr (compress=true)
.output stack_region (compress=true)
.output startup_context (compress=true)
.output static_allocation_type (compress=true)
.output store_instr (compress=true)
.output store_instr_address (compress=true)
.output store_instr_address_ptr_type (compress=true)
.output store_instr_alignment (compress=true)
.output store_instr_is_atomic (compress=true)
.output store_instr_is_volatile (compress=true)
.output store_instr_ordering (compress=true)
.output store_instr_value (compress=true)
.output store_instr_value_type (compress=true)
.output stripctx_var_alias (compress=true)
.output struct_pointer_type (compress=true)
.output struct_type (compress=true)
.output struct_type_field (compress=true)
.output struct_type_field_bit_offset (compress=true)
.output struct_type_field_offset (compress=true)
.output struct_type_has_name (compress=true)
.output struct_type_nfields (compress=true)
.output sub_instr (compress=true)
.output sub_instr_first_operand (compress=true)
.output sub_instr_second_operand (compress=true)
.output suffix (compress=true)
.output superclass (compress=true)
.output switch_instr (compress=true)
.output switch_instr_case (compress=true)
.output switch_instr_case_label (compress=true)
.output switch_instr_case_value (compress=true)
.output switch_instr_default_label (compress=true)
.output switch_instr_ncases (compress=true)
.output switch_instr_operand (compress=true)
.output target_dependent_attr (compress=true)
.output template_type (compress=true)
.output template_typeinfo (compress=true)
.output terminator_instr (compress=true)
.output threadlocal_mode (compress=true)
.output trunc_instr (compress=true)
.output trunc_instr_from_operand (compress=true)
.output trunc_instr_from_type (compress=true)
.output trunc_instr_to_type (compress=true)
.output type (compress=true)
.output type_compatible (compress=true)
.output type_compatible_up_to_arg (compress=true)
.output type_compatible_up_to_field (compress=true)
.output type_contains_pointer (compress=true)
.output type_has_size (compress=true)
.output type_has_subelement (compress=true)
.output type_has_unpadded_size (compress=true)
.output type_is_firstclass (compress=true)
.output typeinfo (compress=true)
.output typeinfo_base_class (compress=true)
.output typeinfo_baseclass (compress=true)
.output typeinfo_has_vtable (compress=true)
.output typeinfo_multiple_inheritance (compress=true)
.output typeinfo_single_inheritance (compress=true)
.output typeinfo_vtable (compress=true)
.output typeinfo_vtable_baseclass (compress=true)
.output typeinfo_vtable_multiple_inheritance (compress=true)
.output typeinfo_vtable_single_inheritance (compress=true)
.output udiv_instr (compress=true)
.output udiv_instr_first_operand (compress=true)
.output udiv_instr_second_operand (compress=true)
.output uitofp_instr (compress=true)
.output uitofp_instr_from_operand (compress=true)
.output uitofp_instr_from_type (compress=true)
.output uitofp_instr_to_type (compress=true)
.output undef_constant (compress=true)
.output unify_allocation_size (compress=true)
.output unknown_location (compress=true)
.output unordered_ordering (compress=true)
.output unpadded_struct_type (compress=true)
.output unreachable_instr (compress=true)
.output urem_instr (compress=true)
.output urem_instr_first_operand (compress=true)
.output urem_instr_second_operand (compress=true)
.output user_option_default (compress=true)
.output user_option_defaulted (compress=true)
.output user_option_invalid (compress=true)
.output user_option_selected (compress=true)
.output user_option_valid_value (compress=true)
.output user_option_value (compress=true)
.output user_options (compress=true)
.output va_arg_instr (compress=true)
.output va_arg_instr_type (compress=true)
.output va_arg_instr_va_list (compress=true)
.output var_alias (compress=true)
.output var_alias_sizes (compress=true)
.output var_points_to_sizes (compress=true)
.output variable (compress=true)
.output variable_has_debug_decl_pos (compress=true)
.output variable_has_debug_source_name (compress=true)
.output variable_has_name (compress=true)
.output variable_has_type (compress=true)
.output variable_in_func (compress=true)
.output variable_in_func_name (compress=true)
.output variable_is_firstclass (compress=true)
.output variable_is_label (compress=true)
.output variable_is_pointer (compress=true)
.output vector_pointer_type (compress=true)
.output vector_type (compress=true)
.output vector_type_has_component (compress=true)
.output vector_type_has_size (compress=true)
.output visibility (compress=true)
.output void_type (compress=true)
.output vtable (compress=true)
.output vtable_func (compress=true)
.output vtable_typeinfo (compress=true)
.output weak_linkage_type (compress=true)
.output weak_odr_linkage_type (compress=true)
.output x86_fastcall_calling_convention (compress=true)
.output x86_fp80_type (compress=true)
.output x86_stdcall_calling_convention (compress=true)
.output x86_thiscall_calling_convention (compress=true)
.output x86mmx_type (compress=true)
.output xor_instr (compress=true)
.output xor_instr_first_operand (compress=true)
.output xor_instr_second_operand (compress=true)
.output zext_instr (compress=true)
.output zext_instr_from_operand (compress=true)
.output zext_instr_from_type (compress=true)
.output zext_instr_to_type (compress=true)
#line 4 ".cclyzerpp/datalog/debug.project"
#line 1 "points-to/debug.dl"




.init subset_throw_instr = ThrowInstruction

subset_throw_instr.allocation_type(?alloc, ?type) :-
  subset_allocation_type.allocation_type(?alloc, ?type).

subset_throw_instr.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr) :-
  subset.callgraph.callgraph_edge(?calleeCtx, ?callee, ?callerCtx, ?callerInstr).

subset_throw_instr.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand) :-
  subset.operand_points_to(?aCtx, ?alloc, ?ctx, ?operand).

subset_throw_instr.stripctx_operand_points_to(?to, ?op) :-
  subset.stripctx.stripctx_operand_points_to(?to, ?op).

subset.type_indication.ty_indication(?type, ?aCtx, ?alloc) :-
  subset_throw_instr.ty_indication4(?type, ?aCtx, ?alloc).

subset.type_indication.ty_indication(?type, ?aCtx, ?alloc) :-
  subset_throw_instr.ty_indication5(?type, ?aCtx, ?alloc).

subset_throw_instr.untyped_allocation(?insn, ?alloc) :-
  subset.exception_object.untyped_allocation(?insn, ?alloc).
#line 5 ".cclyzerpp/datalog/debug.project"




.output subset_aliases.alloc_aliases (compress=true)
.output subset_aliases.alloc_matches (compress=true)
.output subset_allocations.alloc_with_ctx (compress=true)
.output subset_allocation_type.allocation_type (compress=true)
.output subset_subobjects._alloc_subregion (compress=true)
.output subset_subobjects.alloc_subregion_at_array_index (compress=true)
.output subset_subobjects.alloc_subregion_at_field (compress=true)
.output subset_subobjects.alloc_subregion_at_path (compress=true)
.output subset_subobjects.alloc_subregion_offset (compress=true)
.output subset_lift._allocation_with_context (compress=true)
.output subset_memcpy.rec_memcpy (compress=true)
.output subset_memcpy._try_memcpy (compress=true)
.output subset_memcpy._stripctx_memcpy (compress=true)
.output subset_memcpy._type_compatible_memcpy (compress=true)
.output subset_memcpy._well_typed_and_sized_memcpy (compress=true)
.output subset_memcpy._do_memcpy (compress=true)
.output subset.callgraph.callgraph_edge (compress=true)
.output subset._merge.merge (compress=true)
.output subset._merge.assert_reachable_calls_have_contexts (compress=true)
.output subset._merge.assert_reachable_calls_have_context_items (compress=true)
.output subset_gep.gep_indexes_from (compress=true)
.output subset_gep.gep_points_to (compress=true)
.output subset_gep._gep_type_compatible (compress=true)
.output subset_gep._gep_last_index_points_to (compress=true)
.output subset.type_indication.assign_rebase_alloc (compress=true)
.output subset.type_indication.heap_allocation_by_type_instr (compress=true)
.output subset.type_indication.ty_indication (compress=true)
.output subset.type_indication.ty_indication1 (compress=true)
.output subset.type_indication.ty_indication2 (compress=true)
.output subset.type_indication.ty_indication3 (compress=true)

.output unification_aliases.alloc_aliases (compress=true)
.output unification_aliases.alloc_matches (compress=true)
.output unification_allocation_type.allocation_type (compress=true)
.output unification_subobjects._alloc_subregion (compress=true)
.output unification_subobjects.alloc_subregion_at_array_index (compress=true)
.output unification_subobjects.alloc_subregion_at_field (compress=true)
.output unification_subobjects.alloc_subregion_at_path (compress=true)
.output unification_subobjects.alloc_subregion_offset (compress=true)
.output unification_memcpy.rec_memcpy (compress=true)
.output unification_memcpy._try_memcpy (compress=true)
.output unification_memcpy._stripctx_memcpy (compress=true)
.output unification_memcpy._type_compatible_memcpy (compress=true)
.output unification_memcpy._well_typed_and_sized_memcpy (compress=true)
.output unification_memcpy._do_memcpy (compress=true)
.output unification.callgraph.callgraph_edge (compress=true)
.output unification._merge.merge (compress=true)
.output unification._merge.assert_reachable_calls_have_contexts (compress=true)
.output unification._merge.assert_reachable_calls_have_context_items (compress=true)
.output unification.type_indication.assign_rebase_alloc (compress=true)
.output unification.type_indication.heap_allocation_by_type_instr (compress=true)
.output unification.type_indication.ty_indication (compress=true)
.output unification.type_indication.ty_indication1 (compress=true)
.output unification.type_indication.ty_indication2 (compress=true)
.output unification.type_indication.ty_indication3 (compress=true)

.output unification.operand_points_to (compress=true)
.output unification.ptr_points_to (compress=true)
.output unification._gep_alloc_info (compress=true)
.output unification.unify (compress=true)
.output unification.unify_ptr (compress=true)
.output unification.unify_var (compress=true)
.output unification.unify_ptr_expanded (compress=true)
.output unification.unify_var_expanded (compress=true)
.output unification.unify_repr (compress=true)
.output unification.var_points_to (compress=true)
.output unification.var_points_to_final (compress=true)
.output unification_allocations.alloc_with_ctx (compress=true)
.output unification_gep.gep_indexes_from (compress=true)
.output unification_gep.gep_points_to (compress=true)
.output unification_gep._gep_type_compatible (compress=true)
.output unification_gep._gep_last_index_points_to (compress=true)
.output unification_subobjects._alloc_subregion (compress=true)
.output unification_subobjects.alloc_subregion_at_path (compress=true)
.output unification_subobjects.alloc_subregion_at_field (compress=true)
.output unification_subobjects.alloc_subregion_at_any_array_index (compress=true)
.output unification_subobjects.alloc_subregion_at_array_index (compress=true)
